{"version":3,"file":"pixi-layers.es.js","sources":["../src/DisplayMixin.ts","../src/RendererMixin.ts","../src/Group.ts","../src/Layer.ts","../src/Stage.ts","../src/index.ts"],"sourcesContent":["import { DisplayObject, Container } from '@pixi/display';\r\n\r\n/** @ignore */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function generateLayerContainerRenderMethod(originalRender: any)\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    return function render(renderer: any): void\r\n    {\r\n        if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!this.visible)\r\n        {\r\n            this.displayOrder = 0;\r\n\r\n            return;\r\n        }\r\n\r\n        this.displayOrder = renderer.incDisplayOrder();\r\n\r\n        // if the object is not visible or the alpha is 0 then no need to render this element\r\n        if (this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        renderer._activeLayer = null;\r\n        originalRender.call(this, renderer);\r\n        renderer._activeLayer = this._activeParentLayer;\r\n    };\r\n}\r\n\r\n// special case - container render method, because we want it to be faster\r\n/**\r\n * @internal\r\n * @private\r\n * @ignore\r\n */\r\nfunction containerRender(renderer: any): void\r\n{\r\n    if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!this.visible)\r\n    {\r\n        this.displayOrder = 0;\r\n\r\n        return;\r\n    }\r\n\r\n    this.displayOrder = renderer.incDisplayOrder();\r\n\r\n    // if the object is not visible or the alpha is 0 then no need to render this element\r\n    if (this.worldAlpha <= 0 || !this.renderable)\r\n    {\r\n        return;\r\n    }\r\n\r\n    renderer._activeLayer = null;\r\n    this.containerRenderWebGL(renderer);\r\n    renderer._activeLayer = this._activeParentLayer;\r\n}\r\n\r\nexport function applyDisplayMixin(): void\r\n{\r\n    if (DisplayObject.prototype.displayOrder !== undefined)\r\n    {\r\n        return;\r\n    }\r\n\r\n    (Object as any).assign(DisplayObject.prototype, {\r\n        parentLayer: null,\r\n        _activeParentLayer: null,\r\n        parentGroup: null,\r\n        zOrder: 0,\r\n        zIndex: 0,\r\n        updateOrder: 0,\r\n        displayOrder: 0,\r\n        layerableChildren: true,\r\n        isLayer: false\r\n    });\r\n\r\n    const ContainerProto = Container.prototype as any;\r\n\r\n    ContainerProto.containerRenderWebGL = ContainerProto.render;\r\n    ContainerProto.render = containerRender;\r\n}\r\n\r\n/** Apply mixin to your custom Container class (not needed if using built-in {@link PIXI.Container})\r\n * Call it for `myClass.prototype`, not for `myClass` !\r\n * */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyContainerRenderMixin(CustomRenderContainer: any): void\r\n{\r\n    if (CustomRenderContainer.originalRenderWebGL)\r\n    {\r\n        return;\r\n    }\r\n\r\n    CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.render;\r\n    CustomRenderContainer.render = generateLayerContainerRenderMethod(CustomRenderContainer.render);\r\n\r\n    if (CustomRenderContainer.renderCanvas)\r\n    {\r\n        CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.renderCanvas;\r\n        CustomRenderContainer.renderCanvas = generateLayerContainerRenderMethod(CustomRenderContainer.renderCanvas);\r\n    }\r\n}\r\n\r\n/** Apply mixin for particles */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyParticleMixin(ParticleContainer: any): void\r\n{\r\n    ParticleContainer.prototype.layerableChildren = false;\r\n    applyContainerRenderMixin(ParticleContainer.prototype);\r\n}\r\n","import { IRenderableObject, IRendererRenderOptions, Renderer } from '@pixi/core';\r\nimport { Container } from '@pixi/display';\r\nimport { LayersTreeSearch } from './LayersTreeSearch';\r\nimport { generateLayerContainerRenderMethod } from './DisplayMixin';\r\n\r\nimport type { Stage } from './Stage';\r\nimport type { Layer } from './Layer';\r\n\r\n/**\r\n * Mixin applied on {@link PIXI.Renderer} when using @pixi/layers.\r\n */\r\nexport interface ILayeredRenderer\r\n{\r\n    /** Order/index of last rendered object */\r\n    _lastDisplayOrder: number;\r\n\r\n    /** {@link Layer} currently being rendered */\r\n    _activeLayer: Layer;\r\n\r\n    /** **Internal** method for updating {@link ILayeredRenderer#_lastDisplayOrder} */\r\n    incDisplayOrder(): number;\r\n\r\n    /** **Internal** reference to old render method */\r\n    _oldRender(displayObject: IRenderableObject, options?: IRendererRenderOptions): void;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nfunction generateLayerRendererMethod(_oldRender: any)\r\n{\r\n    return function render(displayObject: IRenderableObject, options: any, arg1?: any, arg2?: any, arg3?: any)\r\n    {\r\n        if (!options || (!options.renderTexture && !options.baseTexture))\r\n        {\r\n            this._lastDisplayOrder = 0;\r\n        }\r\n        this._activeLayer = null;\r\n\r\n        if ((displayObject as Stage).isStage)\r\n        {\r\n            (displayObject as Stage).updateStage();\r\n        }\r\n        if (this.plugins.interaction && !this.plugins.interaction.search.worksWithLayers)\r\n        {\r\n            this.plugins.interaction.search = new LayersTreeSearch();\r\n        }\r\n\r\n        _oldRender.call(this, displayObject, options, arg1, arg2, arg3);\r\n    };\r\n}\r\n\r\n/**\r\n * Mixes {@link ILayeredRenderer} into {@link PIXI.Renderer}.\r\n *\r\n * This is automatically done on importing @pixi/layers.\r\n */\r\nexport function applyRendererMixin(rendererClass: typeof Renderer): void\r\n{\r\n    const RendererProto = rendererClass.prototype as (Renderer & Partial<ILayeredRenderer>);\r\n\r\n    // Skip if mixin already applied.\r\n    if (RendererProto._oldRender)\r\n    {\r\n        return;\r\n    }\r\n\r\n    Object.assign(RendererProto, {\r\n        _lastDisplayOrder: 0,\r\n        _activeLayer: null,\r\n        incDisplayOrder()\r\n        {\r\n            return ++this._lastDisplayOrder;\r\n        },\r\n        _oldRender: Renderer.prototype.render,\r\n    });\r\n\r\n    RendererProto._oldRender = RendererProto.render;\r\n    RendererProto.render = generateLayerRendererMethod(RendererProto.render);\r\n}\r\n\r\n/**\r\n * Mixes renderer mixin + container mixin for canvas.\r\n *\r\n * If you are using PixiJS' canvas renderer, you'll need to invoke this manually.\r\n *\r\n * @example\r\n * import { CanvasRenderer } from '@pixi/canvas-renderer';\r\n * import { applyCanvasMixin } from '@pixi/layers';\r\n *\r\n * applyCanvasMixin(CanvasRenderer);\r\n */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyCanvasMixin(canvasRenderClass: any): void\r\n{\r\n    if (!canvasRenderClass)\r\n    {\r\n        // eslint-disable-next-line max-len,no-console\r\n        console.log('@pixi/layers: Canvas mixin was called with empty parameter. Are you sure that you even need this line?');\r\n\r\n        return;\r\n    }\r\n\r\n    applyRendererMixin(canvasRenderClass);\r\n\r\n    const ContainerProto = Container.prototype as any;\r\n\r\n    if (ContainerProto.containerRenderCanvas)\r\n    {\r\n        return;\r\n    }\r\n\r\n    ContainerProto.containerRenderCanvas = ContainerProto.renderCanvas;\r\n    ContainerProto.renderCanvas = generateLayerContainerRenderMethod(ContainerProto.renderCanvas);\r\n}\r\n\r\n","import * as utils from '@pixi/utils';\r\n\r\nimport type { DisplayObject } from '@pixi/display';\r\nimport type { Layer } from './Layer';\r\nimport type { Stage } from './Stage';\r\n\r\n/**\r\n * A context for z-ordering {@link PIXI.DisplayObject}s within the same {@link Layer}.\r\n */\r\nexport class Group extends utils.EventEmitter\r\n{\r\n    static _layerUpdateId = 0;\r\n\r\n    /** See {@link Layer#useRenderTexture} */\r\n    public useRenderTexture = false;\r\n\r\n    /** See {@link Layer#useDoubleBuffer} */\r\n    public useDoubleBuffer = false;\r\n\r\n    /**\r\n     * Groups with a non-zero sort priority are sorted first.\r\n     *\r\n     * Unsure of the exact purpose yet :)\r\n     */\r\n    public sortPriority = 0;\r\n\r\n    /** See {@link Layer#clearColor} */\r\n    public clearColor : ArrayLike<number> = new Float32Array([0, 0, 0, 0]);\r\n\r\n    // TODO: handle orphan groups\r\n    // TODO: handle groups that don't want to be drawn in parent\r\n    canDrawWithoutLayer = false;\r\n    canDrawInParentStage = true;\r\n\r\n    /** Default zIndex value for layers that are created with this Group */\r\n    public zIndex: number;\r\n\r\n    /** Enabling sorting objects within this group by {@link PIXI.DisplayObject#zOrder zOrder}. */\r\n    public enableSort: boolean;\r\n\r\n    private _activeLayer: Layer = null;\r\n    private _activeStage: Stage = null;\r\n    /** @private */\r\n    _activeChildren: Array<DisplayObject> = [];\r\n    private _lastUpdateId = -1;\r\n\r\n    /**\r\n     * @param zIndex - The z-index for the entire group.\r\n     * @param sorting - This will enable sorting by z-order. You can also pass a callback that will assign\r\n     *  the z-index _before_ sorting. This is useful, for example, when you want to sort by \"y\" - the callback\r\n     *  can then set the {@link PIXI.DisplayObject#zOrder zOrder} to the y-coordinate. This callback is invoked\r\n     *  as an event-listener to the {@link Group#sort} event.\r\n     */\r\n    constructor(zIndex = 0, sorting: boolean | ((displayObject: DisplayObject) => void) = false)\r\n    {\r\n        super();\r\n\r\n        this.zIndex = zIndex || 0;\r\n        this.enableSort = !!sorting;\r\n\r\n        if (typeof sorting === 'function')\r\n        {\r\n            this.on('sort', sorting);\r\n        }\r\n    }\r\n\r\n    doSort(layer: Layer, sorted: Array<DisplayObject>): void\r\n    {\r\n        if ((this.listeners as any)('sort', true))\r\n        {\r\n            for (let i = 0; i < sorted.length; i++)\r\n            {\r\n                this.emit('sort', sorted[i]);\r\n            }\r\n        }\r\n\r\n        sorted.sort(Group.compareZIndex);\r\n    }\r\n\r\n    private static compareZIndex(a: DisplayObject, b: DisplayObject): number\r\n    {\r\n        if (a.zOrder < b.zOrder)\r\n        {\r\n            return -1;\r\n        }\r\n        if (a.zOrder > b.zOrder)\r\n        {\r\n            return 1;\r\n        }\r\n\r\n        return a.updateOrder - b.updateOrder;\r\n    }\r\n\r\n    /**\r\n     * clears temporary variables\r\n     */\r\n    private clear(): void\r\n    {\r\n        this._activeLayer = null;\r\n        this._activeStage = null;\r\n        this._activeChildren.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Resolve a child {@link PIXI.DisplayObject} that is set to be in this group.\r\n     *\r\n     * This is an **internal** method.\r\n     *\r\n     * @see Stage#updateStage\r\n     */\r\n    _resolveChildDisplayObject(stage: Stage, displayObject: DisplayObject): void\r\n    {\r\n        this.check(stage);\r\n        displayObject._activeParentLayer = this._activeLayer;\r\n\r\n        if (this._activeLayer)\r\n        {\r\n            this._activeLayer._activeChildren.push(displayObject);\r\n        }\r\n        else\r\n        {\r\n            this._activeChildren.push(displayObject);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resolve the layer rendering this group of {@link DisplayObject display objects}.\r\n     *\r\n     * This is an **internal** method.\r\n     *\r\n     * @see Layer#_onBeginLayerSubtreeTraversal\r\n     */\r\n    _resolveLayer(stage: Stage, layer: Layer): void\r\n    {\r\n        this.check(stage);\r\n\r\n        if (this._activeLayer)\r\n        {\r\n            Group.conflict();\r\n        }\r\n\r\n        this._activeLayer = layer;\r\n        this._activeStage = stage;\r\n    }\r\n\r\n    private check(stage: Stage): void\r\n    {\r\n        if (this._lastUpdateId < Group._layerUpdateId)\r\n        {\r\n            this._lastUpdateId = Group._layerUpdateId;\r\n            this.clear();\r\n            this._activeStage = stage;\r\n        }\r\n        else if (this.canDrawInParentStage)\r\n        {\r\n            let current = this._activeStage;\r\n\r\n            while (current && current !== stage)\r\n            {\r\n                current = current._activeParentStage;\r\n            }\r\n            this._activeStage = current;\r\n            if (current === null)\r\n            {\r\n                this.clear();\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _lastLayerConflict = 0;\r\n\r\n    /** Log a conflict that occurs when multiple layers render the same group. */\r\n    private static conflict(): void\r\n    {\r\n        if (Group._lastLayerConflict + 5000 < Date.now())\r\n        {\r\n            Group._lastLayerConflict = Date.now();\r\n            // eslint-disable-next-line max-len,no-console\r\n            console.log(`@pixi/layers found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fired for each {@link DisplayObject} in this group, right before they are sorted.\r\n     *\r\n     * @event sort\r\n     * @param {PIXI.DisplayObject} object - The object that will be sorted.\r\n     */\r\n}\r\n","/**\r\n * Created by ivanp on 29.01.2017.\r\n */\r\n\r\nimport { Container } from '@pixi/display';\r\nimport { Group } from './Group';\r\nimport { RenderTexture, Renderer } from '@pixi/core';\r\nimport { Rectangle } from '@pixi/math';\r\nimport { settings } from '@pixi/settings';\r\n\r\nimport type { DisplayObject, IDestroyOptions } from '@pixi/display';\r\nimport type { Stage } from './Stage';\r\nimport type { ILayeredRenderer } from './RendererMixin';\r\n\r\n/**\r\n * This manages the render-texture a {@link Layer} renders into.\r\n *\r\n * This is used internally by {@link Layer#render}.\r\n */\r\nexport class LayerTextureCache\r\n{\r\n    constructor(public layer: Layer) {}\r\n\r\n    private renderTexture: RenderTexture = null;\r\n    private doubleBuffer: Array<RenderTexture> = null;\r\n    private currentBufferIndex = 0;\r\n    _tempRenderTarget: RenderTexture = null;\r\n    _tempRenderTargetSource = new Rectangle();\r\n    _tempRenderTargetDestination = new Rectangle();\r\n\r\n    private init(renderer?: Renderer): void\r\n    {\r\n        const width = renderer ? renderer.screen.width : 100;\r\n        const height = renderer ? renderer.screen.height : 100;\r\n        const resolution = renderer ? renderer.resolution : settings.RESOLUTION;\r\n\r\n        this.renderTexture = RenderTexture.create({ width, height, resolution });\r\n\r\n        if (this.layer.group.useDoubleBuffer)\r\n        {\r\n            this.doubleBuffer = [\r\n                RenderTexture.create({ width, height, resolution }),\r\n                RenderTexture.create({ width, height, resolution })\r\n            ];\r\n        }\r\n    }\r\n\r\n    /** See {@link Layer#getRenderTexture}. */\r\n    getRenderTexture(): RenderTexture\r\n    {\r\n        if (!this.renderTexture)\r\n        {\r\n            this.init();\r\n        }\r\n\r\n        return this.renderTexture;\r\n    }\r\n\r\n    /** Prepares the layer's render-texture and set it as the render-target. */\r\n    pushTexture(renderer: Renderer): void\r\n    {\r\n        // TODO: take not screen, but offset screen, in case there's matrix transform\r\n        const screen = renderer.screen;\r\n\r\n        if (!this.renderTexture)\r\n        {\r\n            this.init(renderer);\r\n        }\r\n\r\n        const rt = this.renderTexture;\r\n        const group = this.layer.group;\r\n        const db = this.doubleBuffer;\r\n\r\n        if (rt.width !== screen.width\r\n            || rt.height !== screen.height\r\n            || rt.baseTexture.resolution !== renderer.resolution)\r\n        {\r\n            rt.baseTexture.resolution = renderer.resolution;\r\n            rt.resize(screen.width, screen.height);\r\n\r\n            if (db)\r\n            {\r\n                db[0].baseTexture.resolution = renderer.resolution;\r\n                db[0].resize(screen.width, screen.height);\r\n                db[1].baseTexture.resolution = renderer.resolution;\r\n                db[1].resize(screen.width, screen.height);\r\n            }\r\n        }\r\n\r\n        if (db)\r\n        {\r\n            db[0].framebuffer.multisample = rt.framebuffer.multisample;\r\n            db[1].framebuffer.multisample = rt.framebuffer.multisample;\r\n        }\r\n\r\n        this._tempRenderTarget = renderer.renderTexture.current;\r\n        this._tempRenderTargetSource.copyFrom(renderer.renderTexture.sourceFrame);\r\n        this._tempRenderTargetDestination.copyFrom(renderer.renderTexture.destinationFrame);\r\n\r\n        renderer.batch.flush();\r\n\r\n        if (group.useDoubleBuffer)\r\n        {\r\n            // double-buffer logic\r\n            let buffer = db[this.currentBufferIndex];\r\n\r\n            if (!(buffer.baseTexture as any)._glTextures[renderer.CONTEXT_UID])\r\n            {\r\n                renderer.renderTexture.bind(buffer, undefined, undefined);\r\n                renderer.texture.bind(buffer);\r\n                if (group.clearColor)\r\n                {\r\n                    renderer.renderTexture.clear(group.clearColor as any);\r\n                }\r\n            }\r\n            renderer.texture.unbind(rt.baseTexture);\r\n            (rt.baseTexture as any)._glTextures = (buffer.baseTexture as any)._glTextures;\r\n            (rt.baseTexture as any).framebuffer = (buffer.baseTexture as any).framebuffer;\r\n\r\n            buffer = db[1 - this.currentBufferIndex];\r\n            renderer.renderTexture.bind(buffer, undefined, undefined);\r\n        }\r\n        else\r\n        {\r\n            // simple logic\r\n            renderer.renderTexture.bind(rt, undefined, undefined);\r\n        }\r\n\r\n        if (group.clearColor)\r\n        {\r\n            renderer.renderTexture.clear(group.clearColor as any);\r\n        }\r\n\r\n        // fix for filters\r\n        const filterStack = renderer.filter.defaultFilterStack;\r\n\r\n        if (filterStack.length > 1)\r\n        {\r\n            filterStack[filterStack.length - 1].renderTexture = renderer.renderTexture.current;\r\n        }\r\n    }\r\n\r\n    /** Flushes the renderer and restores the old render-target. */\r\n    popTexture(renderer: Renderer): void\r\n    {\r\n        renderer.batch.flush();\r\n        renderer.framebuffer.blit();\r\n        // switch filters back\r\n        const filterStack = renderer.filter.defaultFilterStack;\r\n\r\n        if (filterStack.length > 1)\r\n        {\r\n            filterStack[filterStack.length - 1].renderTexture = this._tempRenderTarget;\r\n        }\r\n        renderer.renderTexture.bind(this._tempRenderTarget,\r\n            this._tempRenderTargetSource, this._tempRenderTargetDestination);\r\n        this._tempRenderTarget = null;\r\n\r\n        const rt = this.renderTexture;\r\n        const group = this.layer.group;\r\n        const db = this.doubleBuffer;\r\n\r\n        if (group.useDoubleBuffer)\r\n        {\r\n            renderer.texture.unbind(rt.baseTexture);\r\n            this.currentBufferIndex = 1 - this.currentBufferIndex;\r\n\r\n            const buffer = db[this.currentBufferIndex];\r\n\r\n            (rt.baseTexture as any)._glTextures = (buffer.baseTexture as any)._glTextures;\r\n            (rt.baseTexture as any).framebuffer = (buffer.baseTexture as any).framebuffer;\r\n        }\r\n    }\r\n\r\n    /** Destroy the texture-cache. Set {@link Layer.textureCache} to {@code null} after destroying it! */\r\n    destroy(): void\r\n    {\r\n        if (this.renderTexture)\r\n        {\r\n            this.renderTexture.destroy();\r\n            if (this.doubleBuffer)\r\n            {\r\n                this.doubleBuffer[0].destroy(true);\r\n                this.doubleBuffer[1].destroy(true);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A {@link Layer layer} can be used to render {@link PIXI.DisplayObject}s in a different part of the scene graph together.\r\n *\r\n * A layer can be used to structure a scene graph in a data-oriented manner and separate the z-ordering hierarchy in\r\n * a different tree. Each layer is associated with a {@link Group} that provides the context for sorting objects\r\n * in the same layer.\r\n *\r\n * All layers must be placed underneath a {@link Stage} - generally, you should assign a {@link Stage} as your\r\n * scene's root.\r\n */\r\nexport class Layer extends Container\r\n{\r\n    /** Flags that this container is a layer! */\r\n    public readonly isLayer = true;\r\n\r\n    /** The group of {@link DisplayObject}s that are rendered within this layer */\r\n    public group: Group = null;\r\n\r\n    /** The texture manager used when rendering into a {@link Layer#useRenderTexture layer render-texture}. */\r\n    public textureCache: LayerTextureCache;\r\n\r\n    _activeChildren: Array<DisplayObject> = [];\r\n    _tempChildren: Array<DisplayObject> = null;\r\n    _activeStageParent: Stage = null;\r\n    _sortedChildren: Array<DisplayObject> = [];\r\n    _tempLayerParent: Layer = null;\r\n\r\n    insertChildrenBeforeActive = true;\r\n    insertChildrenAfterActive = true;\r\n\r\n    /**\r\n     * @param group - The group of {@link DisplayObject}s to be rendered by this layer.\r\n     */\r\n    constructor(group: Group = null)\r\n    {\r\n        super();\r\n\r\n        if (group)\r\n        {\r\n            this.group = group;\r\n            this.zIndex = group.zIndex;\r\n        }\r\n        else\r\n        {\r\n            this.group = new Group(0, false);\r\n        }\r\n\r\n        this._tempChildren = this.children;\r\n    }\r\n\r\n    /**\r\n     * Flags whether this layer should render into a render-texture.\r\n     *\r\n     * This is useful if you want to use the layer as a texture elsewhere - for example, in sprites or to apply\r\n     * filters. The layer's render-texture is resized to the size of the renderer's screen.\r\n     */\r\n    get useRenderTexture(): boolean\r\n    {\r\n        return this.group.useRenderTexture;\r\n    }\r\n    set useRenderTexture(value: boolean)\r\n    {\r\n        this.group.useRenderTexture = value;\r\n    }\r\n\r\n    /**\r\n     * This will enable double buffering for this layer.\r\n     *\r\n     * This layer will keep two render-textures to render into - choosing one each frame on a flip-flop\r\n     * basis. This is useful when you\r\n     *\r\n     * **Caveat**: You must enable {@link Layer#useRenderTexture} to prevent framebuffer errors in rendering.\r\n     */\r\n    get useDoubleBuffer(): boolean\r\n    {\r\n        return this.group.useDoubleBuffer;\r\n    }\r\n    set useDoubleBuffer(value: boolean)\r\n    {\r\n        this.group.useDoubleBuffer = value;\r\n    }\r\n\r\n    /**\r\n     * The background color to clear the layer.\r\n     *\r\n     * This should be used when {@link Layer#useRenderTexture} is enabled.\r\n     */\r\n    get clearColor(): ArrayLike<number>\r\n    {\r\n        return this.group.clearColor;\r\n    }\r\n    set clearColor(value: ArrayLike<number>)\r\n    {\r\n        this.group.clearColor = value;\r\n    }\r\n\r\n    get sortPriority(): number\r\n    {\r\n        return this.group.sortPriority;\r\n    }\r\n    set sortPriority(value: number)\r\n    {\r\n        this.group.sortPriority = value;\r\n    }\r\n\r\n    /**\r\n     * The rendering {@link Layer#useRenderTexture into a render-texture} is enabled, this will return\r\n     * the render-texture used by this layer.\r\n     */\r\n    getRenderTexture(): RenderTexture\r\n    {\r\n        if (!this.textureCache)\r\n        {\r\n            this.textureCache = new LayerTextureCache(this);\r\n        }\r\n\r\n        return this.textureCache.getRenderTexture();\r\n    }\r\n\r\n    /**\r\n     * you can override this method for this particular layer, if you want\r\n     */\r\n    public doSort(): void\r\n    {\r\n        this.group.doSort(this, this._sortedChildren);\r\n    }\r\n\r\n    /** @override */\r\n    public destroy(options?: IDestroyOptions): void\r\n    {\r\n        if (this.textureCache)\r\n        {\r\n            this.textureCache.destroy();\r\n            this.textureCache = null;\r\n        }\r\n\r\n        super.destroy(options);\r\n    }\r\n\r\n    /** @override */\r\n    public render(renderer: Renderer): void\r\n    {\r\n        if (!this.prerender(renderer as any))\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.group.useRenderTexture)\r\n        {\r\n            if (!this.textureCache)\r\n            {\r\n                this.textureCache = new LayerTextureCache(this);\r\n            }\r\n            this.textureCache.pushTexture(renderer);\r\n        }\r\n\r\n        this.containerRenderWebGL(renderer);\r\n        this.postrender(renderer as any);\r\n\r\n        if (this.group.useRenderTexture)\r\n        {\r\n            this.textureCache.popTexture(renderer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * renderCanvas named this way because of some TS mixin problem\r\n     * @param renderer\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    public layerRenderCanvas(renderer: any): void\r\n    {\r\n        if (this.prerender(renderer))\r\n        {\r\n            this.containerRenderCanvas(renderer);\r\n            this.postrender(renderer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This should be called when the layer is found while traversing the scene for updating object-layer association.\r\n     *\r\n     * This is an **internal** method.\r\n     *\r\n     * @see Stage#updateStage\r\n     */\r\n    _onBeginLayerSubtreeTraversal(stage: Stage): void\r\n    {\r\n        // This will transfer all \"_activeChildren\" of \"this.group\" into \"this._activeChildren\". This is done\r\n        // because a DisplayObject in that group may be placed before the layer in the scene tree.\r\n\r\n        const active = this._activeChildren;\r\n\r\n        this._activeStageParent = stage;\r\n        this.group._resolveLayer(stage, this);\r\n        const groupChildren = this.group._activeChildren;\r\n\r\n        active.length = 0;\r\n        for (let i = 0; i < groupChildren.length; i++)\r\n        {\r\n            groupChildren[i]._activeParentLayer = this;\r\n            active.push(groupChildren[i]);\r\n        }\r\n        groupChildren.length = 0;\r\n    }\r\n\r\n    /**\r\n     * This should be called when the full subtree of the layer has been traversed while updating the stage's scene.\r\n     *\r\n     * This is an **internal** method.\r\n     *\r\n     * @see Stage#updateStage\r\n     */\r\n    _onEndLayerSubtreeTraversal(): void\r\n    {\r\n        const children = this.children;\r\n        const active = this._activeChildren;\r\n        const sorted = this._sortedChildren;\r\n\r\n        for (let i = 0; i < active.length; i++)\r\n        {\r\n            this.emit('display', active[i]);\r\n        }\r\n\r\n        sorted.length = 0;\r\n        if (this.insertChildrenBeforeActive)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                sorted.push(children[i]);\r\n            }\r\n        }\r\n        for (let i = 0; i < active.length; i++)\r\n        {\r\n            sorted.push(active[i]);\r\n        }\r\n        if (!this.insertChildrenBeforeActive\r\n            && this.insertChildrenAfterActive)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                sorted.push(children[i]);\r\n            }\r\n        }\r\n\r\n        if (this.group.enableSort)\r\n        {\r\n            this.doSort();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the renderer for this layer.\r\n     *\r\n     * It will assign {@link PIXI.Renderer#_activeLayer} to {@code this}, and set the active layer before\r\n     * this to {@link Layer#_activeParentLayer _activeParentLayer}. It will also temporarily sort the\r\n     * children by z-order.\r\n     *\r\n     * @return `true`, if the layer needs to be rendered; `false`, when the layer is invisible or has\r\n     * zero alpha.\r\n     */\r\n    protected prerender(renderer: ILayeredRenderer): boolean\r\n    {\r\n        // eslint-disable-next-line eqeqeq\r\n        if (this._activeParentLayer && this._activeParentLayer != renderer._activeLayer)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (!this.visible)\r\n        {\r\n            this.displayOrder = 0;\r\n\r\n            return false;\r\n        }\r\n\r\n        this.displayOrder = renderer.incDisplayOrder();\r\n\r\n        // if the object is not visible or the alpha is 0 then no need to render this element\r\n        if (this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // we are making a hack with swapping children, it can go wrong easily\r\n        // this is special \"recover\" if that allows stage to recover just after failed frame\r\n\r\n        if (this.children !== this._sortedChildren\r\n            && this._tempChildren !== this.children)\r\n        {\r\n            this._tempChildren = this.children;\r\n        }\r\n\r\n        // just a temporary feature - getBounds() for filters will work with that\r\n        // TODO: make a better hack for getBounds()\r\n\r\n        (this as any)._boundsID++;\r\n        (this as any).children = this._sortedChildren;\r\n\r\n        this._tempLayerParent = renderer._activeLayer;\r\n        renderer._activeLayer = this;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Cleans up the renderer after this layer is rendered.\r\n     *\r\n     * It restores {@link Renderer#_activeLayer} to the parent layer and restores the canonical\r\n     * order of children.\r\n     */\r\n    protected postrender(renderer: ILayeredRenderer): void\r\n    {\r\n        (this as any).children = this._tempChildren;\r\n        renderer._activeLayer = this._tempLayerParent;\r\n        this._tempLayerParent = null;\r\n    }\r\n}\r\n\r\n(Layer.prototype as any).renderCanvas = Layer.prototype.layerRenderCanvas;\r\n","import { Container, DisplayObject } from '@pixi/display';\r\nimport { Layer } from './Layer';\r\nimport { Group } from './Group';\r\n\r\n/**\r\n * The {@link Stage stage} manages all the layers in its scene tree.\r\n *\r\n *\r\n */\r\nexport class Stage extends Layer\r\n{\r\n    static _updateOrderCounter = 0;\r\n\r\n    /** Flags that this is a {@link Stage stage}! */\r\n    public readonly isStage = true;\r\n\r\n    _tempGroups: Array<DisplayObject> = [];\r\n\r\n    /**\r\n     * Found layers\r\n     */\r\n    _activeLayers: Array<Layer> = [];\r\n\r\n    _activeParentStage: Stage = null;\r\n\r\n    /**\r\n     * clears all display lists that were used in last rendering session\r\n     * please clear it when you stop using this displayList, otherwise you may have problems with GC in some cases\r\n     */\r\n    clear(): void\r\n    {\r\n        this._activeLayers.length = 0;\r\n        this._tempGroups.length = 0;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    destroy(options?: any): void\r\n    {\r\n        this.clear();\r\n        super.destroy(options);\r\n    }\r\n\r\n    /**\r\n     * This should be called before rendering for resolving items in the scene tree to their {@link Layer layers}.\r\n     *\r\n     * If your scene's root is a {@link Stage}, then the {@link ILayerRenderer} mixin will automatically\r\n     * call it.\r\n     */\r\n    updateStage(): void\r\n    {\r\n        this._activeParentStage = null;\r\n        Group._layerUpdateId++;\r\n        this._updateStageInner();\r\n    }\r\n\r\n    private updateAsChildStage(stage: Stage): void\r\n    {\r\n        this._activeParentStage = stage;\r\n        Stage._updateOrderCounter = 0;\r\n        this._updateStageInner();\r\n    }\r\n\r\n    private _updateStageInner(): void\r\n    {\r\n        this.clear();\r\n        this._addRecursive(this);\r\n        const layers = this._activeLayers;\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            const layer = layers[i];\r\n\r\n            if (layer.group.sortPriority)\r\n            {\r\n                layer._onEndLayerSubtreeTraversal();\r\n                const sorted = layer._sortedChildren;\r\n\r\n                for (let j = 0; j < sorted.length; j++)\r\n                {\r\n                    this._addRecursiveChildren(sorted[j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            const layer = layers[i];\r\n\r\n            if (!layer.group.sortPriority)\r\n            {\r\n                layer._onEndLayerSubtreeTraversal();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addRecursive(displayObject: DisplayObject): void\r\n    {\r\n        if (!displayObject.visible)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if ((displayObject as any).isLayer)\r\n        {\r\n            const layer = displayObject as any as Layer;\r\n\r\n            this._activeLayers.push(layer);\r\n            layer._onBeginLayerSubtreeTraversal(this);\r\n        }\r\n\r\n        if (displayObject !== this && (displayObject as any).isStage)\r\n        {\r\n            const stage = displayObject as Stage;\r\n\r\n            stage.updateAsChildStage(this);\r\n\r\n            return;\r\n        }\r\n\r\n        displayObject._activeParentLayer = null;\r\n        let group = displayObject.parentGroup;\r\n\r\n        if (group)\r\n        {\r\n            group._resolveChildDisplayObject(this, displayObject);\r\n        }\r\n        const layer = displayObject.parentLayer;\r\n\r\n        if (layer)\r\n        {\r\n            group = layer.group;\r\n            group._resolveChildDisplayObject(this, displayObject);\r\n        }\r\n\r\n        displayObject.updateOrder = ++Stage._updateOrderCounter;\r\n        if (displayObject.alpha <= 0 || !displayObject.renderable\r\n            || !displayObject.layerableChildren\r\n            || (group && group.sortPriority))\r\n        {\r\n            return;\r\n        }\r\n\r\n        const children = (displayObject as Container).children;\r\n\r\n        if (children && children.length)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                this._addRecursive(children[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addRecursiveChildren(displayObject: DisplayObject): void\r\n    {\r\n        if (displayObject.alpha <= 0 || !displayObject.renderable\r\n            || !displayObject.layerableChildren)\r\n        {\r\n            return;\r\n        }\r\n        const children = (displayObject as Container).children;\r\n\r\n        if (children && children.length)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                this._addRecursive(children[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable spaced-comment */\r\n/// <reference path=\"../global.d.ts\" />\r\n\r\nimport { applyDisplayMixin, applyContainerRenderMixin, applyParticleMixin } from './DisplayMixin';\r\nimport { applyRendererMixin, applyCanvasMixin, ILayeredRenderer } from './RendererMixin';\r\nimport { Renderer } from '@pixi/core';\r\n\r\nexport * from './Stage';\r\nexport * from './Layer';\r\nexport * from './Group';\r\n\r\nexport { applyDisplayMixin, applyCanvasMixin, applyContainerRenderMixin, applyRendererMixin, applyParticleMixin };\r\nexport { ILayeredRenderer };\r\n\r\napplyDisplayMixin();\r\napplyRendererMixin(Renderer);\r\n\r\n/**\r\n * The {@link Group group} in which this display object should be rendered.\r\n *\r\n * This is provided by **@pixi/layers**.\r\n *\r\n * @memberof PIXI.DisplayObject\r\n * @member {Group}\r\n * @name parentGroup\r\n */\r\n\r\n/**\r\n * The {@link Layer layer} in which this display object should be rendered; don't set this if you're\r\n * using {@link PIXI.DisplayObject#parentLayer}.\r\n *\r\n * This is provided by **@pixi/layers**.\r\n *\r\n * @memberof PIXI.DisplayObject\r\n * @member {Layer}\r\n * @name parentLayer\r\n */\r\n\r\n/**\r\n * Objects in a {@link Group group} are sorted by z-order.\r\n * This can be used alongside PixiJS' built-in {@link PIXI.DisplayObject#zIndex zIndex}.\r\n *\r\n * If you use both {@code zIndex} and {@code zOrder}, objects will first be sorted by z-index\r\n * and then @pixi/layers will sort by z-order.\r\n *\r\n * This is provided by **@pixi/layers**.\r\n *\r\n * @memberof PIXI.DisplayObject\r\n * @member {number}\r\n * @name zOrder\r\n */\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AAQA;;;;;;;;;;;;;;;AAyBA;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;;;;;AAqBA;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1FA;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;AA6BA;;;;;;;;;;;;;AAmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGW;AA8JQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmVlB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjfU;;ACGX;AACA;;;;"}