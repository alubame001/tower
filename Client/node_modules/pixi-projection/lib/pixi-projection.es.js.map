{"version":3,"file":"pixi-projection.es.js","sources":["../src/base/webgl/Sprite2dRenderer.ts","../src/base/AbstractProjection.ts","../src/base/LinearProjection.ts","../src/base/webgl/UniformBatchRenderer.ts","../src/base/index.ts","../src/utils.ts","../src/proj2d/Matrix2d.ts","../src/proj2d/tiling/TilingSprite2dRenderer.ts","../src/proj2d/Projection2d.ts","../src/proj2d/Container2d.ts","../src/proj2d/mesh/Mesh2d.ts","../src/proj2d/sprites/Sprite2d.ts","../src/proj2d/tiling/TilingSprite2d.ts","../src/proj2d/sprites/convert.ts","../src/proj2d/sprites/Text2d.ts","../src/proj2d/z_masks/SpriteMaskFilter.ts","../src/proj2d/z_masks/MaskHacker.ts","../src/proj2d/index.ts","../src/proj3d/Point3d.ts","../src/proj3d/Euler.ts","../src/proj3d/ObservableEuler.ts","../src/proj3d/Matrix3d.ts","../src/proj3d/Projection3d.ts","../src/proj3d/Container3d.ts","../src/proj3d/Camera3d.ts","../src/proj3d/mesh/Mesh3d2d.ts","../src/proj3d/sprites/Sprite3d.ts","../src/proj3d/sprites/convert.ts","../src/proj3d/sprites/Text3d.ts","../src/curve/SpriteBilinearRenderer.ts","../src/curve/BaseSurface.ts","../src/curve/BilinearSurface.ts","../src/curve/ProjectionSurface.ts","../src/curve/sprites/Sprite2s.ts","../src/curve/sprites/convert.ts","../src/curve/sprites/Text2s.ts","../src/curve/index.ts","../src/spine/Spine2d.ts","../src/spine/Spine3d.ts"],"sourcesContent":["import { AbstractBatchRenderer, BatchShaderGenerator, Renderer, ViewableBuffer, Buffer, Geometry } from '@pixi/core';\nimport { TYPES } from '@pixi/constants';\nimport { premultiplyTint } from '@pixi/utils';\n\nconst shaderVert\n    = `precision highp float;\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\ngl_Position.xyw = projectionMatrix * aVertexPosition;\ngl_Position.z = 0.0;\n\nvTextureCoord = aTextureCoord;\nvTextureId = aTextureId;\nvColor = aColor;\n}\n`;\nconst shaderFrag = `\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\nvec4 color;\n%forloop%\ngl_FragColor = color * vColor;\n}`;\n\nexport class Batch3dGeometry extends Geometry\n{\n    _buffer: Buffer;\n    _indexBuffer : Buffer;\n\n    constructor(_static = false)\n    {\n        super();\n\n        this._buffer = new Buffer(null, _static, false);\n\n        this._indexBuffer = new Buffer(null, _static, true);\n\n        this.addAttribute('aVertexPosition', this._buffer, 3, false, TYPES.FLOAT)\n            .addAttribute('aTextureCoord', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\n            .addAttribute('aTextureId', this._buffer, 1, true, TYPES.FLOAT)\n            .addIndex(this._indexBuffer);\n    }\n}\n\nexport class Batch2dPluginFactory\n{\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    static create(options: any): any\n    {\n        const { vertex, fragment, vertexSize, geometryClass } = (Object as any).assign({\n            vertex: shaderVert,\n            fragment: shaderFrag,\n            geometryClass: Batch3dGeometry,\n            vertexSize: 7,\n        }, options);\n\n        return class BatchPlugin extends AbstractBatchRenderer\n        {\n            constructor(renderer: Renderer)\n            {\n                super(renderer);\n\n                this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n                this.geometryClass = geometryClass;\n                this.vertexSize = vertexSize;\n            }\n\n            vertexSize: number;\n\n            // eslint-disable-next-line max-len\n            packInterleavedGeometry(element: any, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array, aIndex: number, iIndex: number)\n            {\n                const {\n                    uint32View,\n                    float32View,\n                } = attributeBuffer;\n\n                const p = aIndex / this.vertexSize;// float32View.length / 6 / 2;\n                const uvs = element.uvs;\n                const indices = element.indices;// geometry.getIndex().data;// indicies;\n                const vertexData = element.vertexData;\n                const vertexData2d = element.vertexData2d;\n                const textureId = element._texture.baseTexture._batchLocation;\n\n                const alpha = Math.min(element.worldAlpha, 1.0);\n\n                const argb = alpha < 1.0 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha)\n                    : element._tintRGB + (alpha * 255 << 24);\n\n                if (vertexData2d)\n                {\n                    let j = 0;\n\n                    for (let i = 0; i < vertexData2d.length; i += 3, j += 2)\n                    {\n                        float32View[aIndex++] = vertexData2d[i];\n                        float32View[aIndex++] = vertexData2d[i + 1];\n                        float32View[aIndex++] = vertexData2d[i + 2];\n                        float32View[aIndex++] = uvs[j];\n                        float32View[aIndex++] = uvs[j + 1];\n                        uint32View[aIndex++] = argb;\n                        float32View[aIndex++] = textureId;\n                    }\n                }\n                else\n                {\n                    for (let i = 0; i < vertexData.length; i += 2)\n                    {\n                        float32View[aIndex++] = vertexData[i];\n                        float32View[aIndex++] = vertexData[i + 1];\n                        float32View[aIndex++] = 1.0;\n                        float32View[aIndex++] = uvs[i];\n                        float32View[aIndex++] = uvs[i + 1];\n                        uint32View[aIndex++] = argb;\n                        float32View[aIndex++] = textureId;\n                    }\n                }\n\n                for (let i = 0; i < indices.length; i++)\n                {\n                    indexBuffer[iIndex++] = p + indices[i];\n                }\n            }\n        };\n    }\n}\n","import { Transform } from '@pixi/math';\n\nexport class AbstractProjection\n{\n    constructor(legacy: Transform, enable = true)\n    {\n        this.legacy = legacy;\n\n        if (enable)\n        {\n            this.enabled = true;\n        }\n\n        // sorry for hidden class, it would be good to have special projection field in official pixi\n        // TODO: pixi 6.1.0 global mixin\n        (this.legacy as any).proj = this;\n    }\n\n    legacy: Transform;\n\n    _enabled = false;\n\n    get enabled(): boolean\n    {\n        return this._enabled;\n    }\n\n    set enabled(value: boolean)\n    {\n        this._enabled = value;\n    }\n\n    clear(): void\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    {\n    }\n}\n\nexport enum TRANSFORM_STEP {\n    NONE = 0,\n    // POS = 1,\n    // ROT = 2,\n    // SCALE = 3,\n    // PIVOT = 4,\n    BEFORE_PROJ = 4,\n    PROJ = 5,\n    // POS_2 = 6,\n    // ROT_2 = 7,\n    // SCALE_2 = 8,\n    // PIVOT_2 = 9,\n    ALL = 9\n}\n","import { AbstractProjection } from './AbstractProjection';\nimport { Matrix, Transform } from '@pixi/math';\nimport type { Projection2d } from '../proj2d';\n\nexport enum AFFINE {\n    NONE = 0,\n    FREE = 1,\n    AXIS_X = 2,\n    AXIS_Y = 3,\n    POINT = 4,\n    AXIS_XR = 5\n}\n\nexport function transformHack(this: Transform, parentTransform: Transform): void\n{\n    // implementation here\n    // TODO: pixi 6.1.0 global mixin\n    const proj = (this as any).proj as LinearProjection<any>;\n    const ta = this as any;\n    const pwid = (parentTransform as any)._worldID;\n\n    const lt = ta.localTransform;\n    const scaleAfterAffine = proj.scaleAfterAffine && proj.affine >= 2;\n\n    // this part is copied from\n    if (ta._localID !== ta._currentLocalID)\n    {\n        // get the matrix values of the displayobject based on its transform properties..\n        if (scaleAfterAffine)\n        {\n            lt.a = ta._cx;\n            lt.b = ta._sx;\n            lt.c = ta._cy;\n            lt.d = ta._sy;\n\n            lt.tx = ta.position._x;\n            lt.ty = ta.position._y;\n        }\n        else\n        {\n            lt.a = ta._cx * ta.scale._x;\n            lt.b = ta._sx * ta.scale._x;\n            lt.c = ta._cy * ta.scale._y;\n            lt.d = ta._sy * ta.scale._y;\n\n            lt.tx = ta.position._x - ((ta.pivot._x * lt.a) + (ta.pivot._y * lt.c));\n            lt.ty = ta.position._y - ((ta.pivot._x * lt.b) + (ta.pivot._y * lt.d));\n        }\n\n        ta._currentLocalID = ta._localID;\n\n        // force an update..\n        proj._currentProjID = -1;\n    }\n\n    const _matrixID = proj._projID;\n\n    if (proj._currentProjID !== _matrixID)\n    {\n        proj._currentProjID = _matrixID;\n        proj.updateLocalTransform(lt);\n        ta._parentID = -1;\n    }\n\n    if (ta._parentID !== pwid)\n    {\n        // TODO: pixi 6.1.0 global mixin\n        const pp = (parentTransform as any).proj as Projection2d;\n\n        if (pp && !pp._affine)\n        {\n            proj.world.setToMult(pp.world, proj.local);\n        }\n        else\n        {\n            proj.world.setToMultLegacy(parentTransform.worldTransform, proj.local);\n        }\n\n        const wa = ta.worldTransform;\n\n        proj.world.copyTo(wa, proj._affine, proj.affinePreserveOrientation);\n\n        if (scaleAfterAffine)\n        {\n            wa.a *= ta.scale._x;\n            wa.b *= ta.scale._x;\n            wa.c *= ta.scale._y;\n            wa.d *= ta.scale._y;\n\n            wa.tx -= ((ta.pivot._x * wa.a) + (ta.pivot._y * wa.c));\n            wa.ty -= ((ta.pivot._x * wa.b) + (ta.pivot._y * wa.d));\n        }\n        ta._parentID = pwid;\n        ta._worldID++;\n    }\n}\n\nexport class LinearProjection<T> extends AbstractProjection\n{\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    updateLocalTransform(lt: Matrix): void\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    {\n    }\n\n    _projID = 0;\n    _currentProjID = -1;\n    _affine = AFFINE.NONE;\n    affinePreserveOrientation = false;\n    scaleAfterAffine = true;\n\n    set affine(value: AFFINE)\n    {\n        if (this._affine === value) return;\n        this._affine = value;\n        this._currentProjID = -1;\n        // this is because scaleAfterAffine\n        (this.legacy as any)._currentLocalID = -1;\n    }\n\n    get affine(): AFFINE\n    {\n        return this._affine;\n    }\n\n    local: T;\n    world: T;\n\n    // eslint-disable-next-line accessor-pairs\n    set enabled(value: boolean)\n    {\n        if (value === this._enabled)\n        {\n            return;\n        }\n        this._enabled = value;\n        if (value)\n        {\n            this.legacy.updateTransform = transformHack;\n            (this.legacy as any)._parentID = -1;\n        }\n        else\n        {\n            this.legacy.updateTransform = Transform.prototype.updateTransform;\n            (this.legacy as any)._parentID = -1;\n        }\n    }\n\n    clear(): void\n    {\n        this._currentProjID = -1;\n        this._projID = 0;\n    }\n}\n","import {\n    AbstractBatchRenderer,\n    ViewableBuffer,\n    BatchTextureArray\n} from '@pixi/core';\nimport { Dict, premultiplyBlendMode } from '@pixi/utils';\nimport { Sprite } from '@pixi/sprite';\n\nexport class UniformBatchRenderer extends AbstractBatchRenderer\n{\n    _iIndex: number;\n    _aIndex: number;\n    _dcIndex: number;\n    _bufferedElements: Array<any>;\n    _attributeBuffer: ViewableBuffer;\n    _indexBuffer: Uint16Array;\n    vertexSize: number;\n    forceMaxTextures = 0;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getUniforms(sprite: Sprite): any\n    {\n        return this.defUniforms;\n    }\n\n    syncUniforms(obj: Dict<any>): void\n    {\n        if (!obj) return;\n        const sh = this._shader;\n\n        for (const key in obj)\n        {\n            sh.uniforms[key] = obj[key];\n        }\n    }\n\n    defUniforms = {};\n\n    buildDrawCalls(texArray: BatchTextureArray, start: number, finish: number): void\n    {\n        const thisAny = this as any;\n\n        const {\n            _bufferedElements: elements,\n            _attributeBuffer,\n            _indexBuffer,\n            vertexSize,\n        } = this;\n        const drawCalls = AbstractBatchRenderer._drawCallPool;\n\n        let dcIndex: number = this._dcIndex;\n        let aIndex: number = this._aIndex;\n        let iIndex: number = this._iIndex;\n\n        let drawCall = drawCalls[dcIndex] as any;\n\n        drawCall.start = this._iIndex;\n        drawCall.texArray = texArray;\n\n        for (let i = start; i < finish; ++i)\n        {\n            const sprite = elements[i];\n            const tex = sprite._texture.baseTexture;\n            const spriteBlendMode = premultiplyBlendMode[\n                tex.alphaMode ? 1 : 0][sprite.blendMode];\n            const uniforms = this.getUniforms(sprite);\n\n            elements[i] = null;\n\n            // here is the difference\n            if (start < i && (drawCall.blend !== spriteBlendMode || drawCall.uniforms !== uniforms))\n            {\n                drawCall.size = iIndex - drawCall.start;\n                start = i;\n                drawCall = drawCalls[++dcIndex];\n                drawCall.texArray = texArray;\n                drawCall.start = iIndex;\n            }\n\n            this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n            aIndex += sprite.vertexData.length / 2 * vertexSize;\n            iIndex += sprite.indices.length;\n\n            drawCall.blend = spriteBlendMode;\n            // here is the difference\n            drawCall.uniforms = uniforms;\n        }\n\n        if (start < finish)\n        {\n            drawCall.size = iIndex - drawCall.start;\n            ++dcIndex;\n        }\n\n        thisAny._dcIndex = dcIndex;\n        thisAny._aIndex = aIndex;\n        thisAny._iIndex = iIndex;\n    }\n\n    drawBatches(): void\n    {\n        const dcCount = this._dcIndex;\n        const { gl, state: stateSystem, shader: shaderSystem } = this.renderer;\n        const drawCalls = AbstractBatchRenderer._drawCallPool;\n        let curUniforms: any = null;\n        let curTexArray: BatchTextureArray = null;\n\n        for (let i = 0; i < dcCount; i++)\n        {\n            const { texArray, type, size, start, blend, uniforms } = drawCalls[i] as any;\n\n            if (curTexArray !== texArray)\n            {\n                curTexArray = texArray;\n                this.bindAndClearTexArray(texArray);\n            }\n            // here is the difference\n            if (curUniforms !== uniforms)\n            {\n                curUniforms = uniforms;\n                this.syncUniforms(uniforms);\n                (shaderSystem as any).syncUniformGroup((this._shader as any).uniformGroup);\n            }\n\n            this.state.blendMode = blend;\n            stateSystem.set(this.state);\n            gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n        }\n    }\n\n    contextChange(): void\n    {\n        if (!this.forceMaxTextures)\n        {\n            super.contextChange();\n            this.syncUniforms(this.defUniforms);\n\n            return;\n        }\n\n        // we can override MAX_TEXTURES with this hack\n\n        const thisAny = this as any;\n\n        thisAny.MAX_TEXTURES = this.forceMaxTextures;\n        this._shader = thisAny.shaderGenerator.generateShader(this.MAX_TEXTURES);\n        this.syncUniforms(this.defUniforms);\n        for (let i = 0; i < thisAny._packedGeometryPoolSize; i++)\n        {\n            /* eslint-disable max-len */\n            thisAny._packedGeometries[i] = new (this.geometryClass)();\n        }\n        this.initFlushBuffers();\n    }\n}\n","import { Renderer } from '@pixi/core';\nimport { Batch2dPluginFactory } from './webgl/Sprite2dRenderer';\n\nexport * from './AbstractProjection';\nexport * from './LinearProjection';\nexport * from './webgl/Sprite2dRenderer';\nexport * from './webgl/UniformBatchRenderer';\n\nRenderer.registerPlugin('batch2d', Batch2dPluginFactory.create({}));\n","/* eslint-disable no-mixed-operators */\nimport { IPointData, Point } from '@pixi/math';\n\n// eslint-disable-next-line max-len\nexport function getIntersectionFactor(p1: IPointData, p2: IPointData, p3: IPointData, p4: IPointData, out: IPointData): number\n{\n    const A1 = p2.x - p1.x; const B1 = p3.x - p4.x;\n    const C1 = p3.x - p1.x;\n    const A2 = p2.y - p1.y; const B2 = p3.y - p4.y;\n    const C2 = p3.y - p1.y;\n    const D = A1 * B2 - A2 * B1;\n\n    if (Math.abs(D) < 1e-7)\n    {\n        out.x = A1;\n        out.y = A2;\n\n        return 0;\n    }\n    const T = C1 * B2 - C2 * B1;\n    const U = A1 * C2 - A2 * C1;\n\n    const t = T / D; const\n        u = U / D;\n\n    if (u < (1e-6) || u - 1 > -1e-6)\n    {\n        return -1;\n    }\n\n    out.x = p1.x + t * (p2.x - p1.x);\n    out.y = p1.y + t * (p2.y - p1.y);\n\n    return 1;\n}\n\nexport function getPositionFromQuad(p: Array<IPointData>, anchor: IPointData, out: IPointData): IPointData\n{\n    out = out || new Point();\n    const a1 = 1.0 - anchor.x; const\n        a2 = 1.0 - a1;\n    const b1 = 1.0 - anchor.y; const\n        b2 = 1.0 - b1;\n\n    out.x = (p[0].x * a1 + p[1].x * a2) * b1 + (p[3].x * a1 + p[2].x * a2) * b2;\n    out.y = (p[0].y * a1 + p[1].y * a2) * b1 + (p[3].y * a1 + p[2].y * a2) * b2;\n\n    return out;\n}\n","/* eslint-disable no-mixed-operators,max-statements-per-line */\n// according to https://jsperf.com/obj-vs-array-view-access/1 , Float64Array is the best here\nimport { IPointData, Matrix, Point } from '@pixi/math';\nimport { AFFINE } from '../base';\n\nconst mat3id = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\nexport class Matrix2d\n{\n    /**\n     * A default (identity) matrix\n     *\n     * @static\n     * @const\n     */\n    static readonly IDENTITY = new Matrix2d();\n\n    /**\n     * A temp matrix\n     *\n     * @static\n     * @const\n     */\n    static readonly TEMP_MATRIX = new Matrix2d();\n\n    /**\n     * mat3 implementation through array of 9 elements\n     */\n    mat3: Float64Array;\n\n    floatArray: Float32Array = null;\n\n    constructor(backingArray?: ArrayLike<number>)\n    {\n        this.mat3 = new Float64Array(backingArray || mat3id);\n    }\n\n    get a(): number\n    {\n        return this.mat3[0] / this.mat3[8];\n    }\n\n    set a(value: number)\n    {\n        this.mat3[0] = value * this.mat3[8];\n    }\n\n    get b(): number\n    {\n        return this.mat3[1] / this.mat3[8];\n    }\n\n    set b(value: number)\n    {\n        this.mat3[1] = value * this.mat3[8];\n    }\n\n    get c(): number\n    {\n        return this.mat3[3] / this.mat3[8];\n    }\n\n    set c(value: number)\n    {\n        this.mat3[3] = value * this.mat3[8];\n    }\n\n    get d(): number\n    {\n        return this.mat3[4] / this.mat3[8];\n    }\n\n    set d(value: number)\n    {\n        this.mat3[4] = value * this.mat3[8];\n    }\n\n    get tx(): number\n    {\n        return this.mat3[6] / this.mat3[8];\n    }\n\n    set tx(value: number)\n    {\n        this.mat3[6] = value * this.mat3[8];\n    }\n\n    get ty(): number\n    {\n        return this.mat3[7] / this.mat3[8];\n    }\n\n    set ty(value: number)\n    {\n        this.mat3[7] = value * this.mat3[8];\n    }\n\n    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] = a;\n        mat3[1] = b;\n        mat3[2] = 0;\n        mat3[3] = c;\n        mat3[4] = d;\n        mat3[5] = 0;\n        mat3[6] = tx;\n        mat3[7] = ty;\n        mat3[8] = 1;\n\n        return this;\n    }\n\n    toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.floatArray)\n        {\n            this.floatArray = new Float32Array(9);\n        }\n\n        const array = out || this.floatArray;\n        const mat3 = this.mat3;\n\n        if (transpose)\n        {\n            array[0] = mat3[0];\n            array[1] = mat3[1];\n            array[2] = mat3[2];\n            array[3] = mat3[3];\n            array[4] = mat3[4];\n            array[5] = mat3[5];\n            array[6] = mat3[6];\n            array[7] = mat3[7];\n            array[8] = mat3[8];\n        }\n        else\n        {\n            // this branch is NEVER USED in pixi\n            array[0] = mat3[0];\n            array[1] = mat3[3];\n            array[2] = mat3[6];\n            array[3] = mat3[1];\n            array[4] = mat3[4];\n            array[5] = mat3[7];\n            array[6] = mat3[2];\n            array[7] = mat3[5];\n            array[8] = mat3[8];\n        }\n\n        return array;\n    }\n\n    // TODO: remove props\n    apply(pos: IPointData, newPos: IPointData): IPointData\n    {\n        newPos = newPos || new Point();\n\n        const mat3 = this.mat3;\n        const x = pos.x;\n        const y = pos.y;\n\n        const z = 1.0 / (mat3[2] * x + mat3[5] * y + mat3[8]);\n\n        newPos.x = z * (mat3[0] * x + mat3[3] * y + mat3[6]);\n        newPos.y = z * (mat3[1] * x + mat3[4] * y + mat3[7]);\n\n        return newPos;\n    }\n\n    translate(tx: number, ty: number): this\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] += tx * mat3[2];\n        mat3[1] += ty * mat3[2];\n        mat3[3] += tx * mat3[5];\n        mat3[4] += ty * mat3[5];\n        mat3[6] += tx * mat3[8];\n        mat3[7] += ty * mat3[8];\n\n        return this;\n    }\n\n    scale(x: number, y: number): this\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] *= x;\n        mat3[1] *= y;\n        mat3[3] *= x;\n        mat3[4] *= y;\n        mat3[6] *= x;\n        mat3[7] *= y;\n\n        return this;\n    }\n\n    scaleAndTranslate(scaleX: number, scaleY: number, tx: number, ty: number): void\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] = scaleX * mat3[0] + tx * mat3[2];\n        mat3[1] = scaleY * mat3[1] + ty * mat3[2];\n        mat3[3] = scaleX * mat3[3] + tx * mat3[5];\n        mat3[4] = scaleY * mat3[4] + ty * mat3[5];\n        mat3[6] = scaleX * mat3[6] + tx * mat3[8];\n        mat3[7] = scaleY * mat3[7] + ty * mat3[8];\n    }\n\n    // TODO: remove props\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData\n    {\n        newPos = newPos || new Point();\n\n        const a = this.mat3;\n        const x = pos.x;\n        const y = pos.y;\n\n        const a00 = a[0]; const a01 = a[3]; const a02 = a[6];\n        const a10 = a[1]; const a11 = a[4]; const a12 = a[7];\n        const a20 = a[2]; const a21 = a[5]; const\n            a22 = a[8];\n\n        const newX = (a22 * a11 - a12 * a21) * x + (-a22 * a01 + a02 * a21) * y + (a12 * a01 - a02 * a11);\n        const newY = (-a22 * a10 + a12 * a20) * x + (a22 * a00 - a02 * a20) * y + (-a12 * a00 + a02 * a10);\n        const newZ = (a21 * a10 - a11 * a20) * x + (-a21 * a00 + a01 * a20) * y + (a11 * a00 - a01 * a10);\n\n        newPos.x = newX / newZ;\n        newPos.y = newY / newZ;\n\n        return newPos;\n    }\n\n    invert(): Matrix2d\n    {\n        const a = this.mat3;\n\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\n\n        const b01 = a22 * a11 - a12 * a21;\n        const b11 = -a22 * a10 + a12 * a20;\n        const b21 = a21 * a10 - a11 * a20;\n\n        // Calculate the determinant\n        let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n        if (!det)\n        {\n            return this;\n        }\n        det = 1.0 / det;\n\n        a[0] = b01 * det;\n        a[1] = (-a22 * a01 + a02 * a21) * det;\n        a[2] = (a12 * a01 - a02 * a11) * det;\n        a[3] = b11 * det;\n        a[4] = (a22 * a00 - a02 * a20) * det;\n        a[5] = (-a12 * a00 + a02 * a10) * det;\n        a[6] = b21 * det;\n        a[7] = (-a21 * a00 + a01 * a20) * det;\n        a[8] = (a11 * a00 - a01 * a10) * det;\n\n        return this;\n    }\n\n    identity(): Matrix2d\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] = 1;\n        mat3[1] = 0;\n        mat3[2] = 0;\n        mat3[3] = 0;\n        mat3[4] = 1;\n        mat3[5] = 0;\n        mat3[6] = 0;\n        mat3[7] = 0;\n        mat3[8] = 1;\n\n        return this;\n    }\n\n    clone(): Matrix2d\n    {\n        return new Matrix2d(this.mat3);\n    }\n\n    copyTo2dOr3d(matrix: Matrix2d): Matrix2d\n    {\n        const mat3 = this.mat3;\n        const ar2 = matrix.mat3;\n\n        ar2[0] = mat3[0];\n        ar2[1] = mat3[1];\n        ar2[2] = mat3[2];\n        ar2[3] = mat3[3];\n        ar2[4] = mat3[4];\n        ar2[5] = mat3[5];\n        ar2[6] = mat3[6];\n        ar2[7] = mat3[7];\n        ar2[8] = mat3[8];\n\n        return matrix;\n    }\n\n    /**\n     * legacy method, change the values of given pixi matrix\n     * @param matrix\n     * @param affine\n     * @param preserveOrientation\n     * @return matrix\n     */\n    copyTo(matrix: Matrix, affine?: AFFINE, preserveOrientation?: boolean): Matrix\n    {\n        const mat3 = this.mat3;\n        const d = 1.0 / mat3[8];\n        const tx = mat3[6] * d; const\n            ty = mat3[7] * d;\n\n        matrix.a = (mat3[0] - mat3[2] * tx) * d;\n        matrix.b = (mat3[1] - mat3[2] * ty) * d;\n        matrix.c = (mat3[3] - mat3[5] * tx) * d;\n        matrix.d = (mat3[4] - mat3[5] * ty) * d;\n        matrix.tx = tx;\n        matrix.ty = ty;\n\n        if (affine >= 2)\n        {\n            let D = matrix.a * matrix.d - matrix.b * matrix.c;\n\n            if (!preserveOrientation)\n            {\n                D = Math.abs(D);\n            }\n            if (affine === AFFINE.POINT)\n            {\n                if (D > 0)\n                {\n                    D = 1;\n                }\n                else D = -1;\n                matrix.a = D;\n                matrix.b = 0;\n                matrix.c = 0;\n                matrix.d = D;\n            }\n            else if (affine === AFFINE.AXIS_X)\n            {\n                D /= Math.sqrt(matrix.b * matrix.b + matrix.d * matrix.d);\n                matrix.c = 0;\n                matrix.d = D;\n            }\n            else if (affine === AFFINE.AXIS_Y)\n            {\n                D /= Math.sqrt(matrix.a * matrix.a + matrix.c * matrix.c);\n                matrix.a = D;\n                matrix.c = 0;\n            }\n            else if (affine === AFFINE.AXIS_XR)\n            {\n                matrix.a = matrix.d * D;\n                matrix.c = -matrix.b * D;\n            }\n        }\n\n        return matrix;\n    }\n\n    /**\n     * legacy method, change the values of given pixi matrix\n     * @param matrix\n     * @return\n     */\n    copyFrom(matrix: Matrix): this\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] = matrix.a;\n        mat3[1] = matrix.b;\n        mat3[2] = 0;\n        mat3[3] = matrix.c;\n        mat3[4] = matrix.d;\n        mat3[5] = 0;\n        mat3[6] = matrix.tx;\n        mat3[7] = matrix.ty;\n        mat3[8] = 1.0;\n\n        return this;\n    }\n\n    setToMultLegacy(pt: Matrix, lt: Matrix2d): this\n    {\n        const out = this.mat3;\n        const b = lt.mat3;\n\n        const a00 = pt.a; const a01 = pt.b;\n        const a10 = pt.c; const a11 = pt.d;\n        const a20 = pt.tx; const a21 = pt.ty;\n\n        const b00 = b[0]; const b01 = b[1]; const b02 = b[2];\n        const b10 = b[3]; const b11 = b[4]; const b12 = b[5];\n        const b20 = b[6]; const b21 = b[7]; const\n            b22 = b[8];\n\n        out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n        out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n        out[2] = b02;\n\n        out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n        out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n        out[5] = b12;\n\n        out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n        out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n        out[8] = b22;\n\n        return this;\n    }\n\n    setToMultLegacy2(pt: Matrix2d, lt: Matrix): this\n    {\n        const out = this.mat3;\n        const a = pt.mat3;\n\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\n\n        const b00 = lt.a; const b01 = lt.b;\n        const b10 = lt.c; const b11 = lt.d;\n        const b20 = lt.tx; const\n            b21 = lt.ty;\n\n        out[0] = b00 * a00 + b01 * a10;\n        out[1] = b00 * a01 + b01 * a11;\n        out[2] = b00 * a02 + b01 * a12;\n\n        out[3] = b10 * a00 + b11 * a10;\n        out[4] = b10 * a01 + b11 * a11;\n        out[5] = b10 * a02 + b11 * a12;\n\n        out[6] = b20 * a00 + b21 * a10 + a20;\n        out[7] = b20 * a01 + b21 * a11 + a21;\n        out[8] = b20 * a02 + b21 * a12 + a22;\n\n        return this;\n    }\n\n    // that's transform multiplication we use\n    setToMult(pt: Matrix2d, lt: Matrix2d): this\n    {\n        const out = this.mat3;\n        const a = pt.mat3; const\n            b = lt.mat3;\n\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\n\n        const b00 = b[0]; const b01 = b[1]; const b02 = b[2];\n        const b10 = b[3]; const b11 = b[4]; const b12 = b[5];\n        const b20 = b[6]; const b21 = b[7]; const\n            b22 = b[8];\n\n        out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n        out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n        out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n        out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n        out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n        out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n        out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n        out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n        out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n\n        return this;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    prepend(lt: any): this\n    {\n        if (lt.mat3)\n        {\n            return this.setToMult(lt, this);\n        }\n\n        return this.setToMultLegacy(lt, this);\n    }\n}\n","import { Matrix2d } from '../Matrix2d';\nimport { ObjectRenderer, QuadUv, Renderer, Shader } from '@pixi/core';\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\nimport { correctBlendMode, premultiplyTintToRgba } from '@pixi/utils';\n\nconst shaderVert\n    = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec3 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\n\nvTextureCoord = uTransform * vec3(aTextureCoord, 1.0);\n}\n`;\nconst shaderFrag = `\nvarying vec3 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\nvec2 coord = mod(vTextureCoord.xy / vTextureCoord.z - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\ncoord = (uMapCoord * vec3(coord, 1.0)).xy;\ncoord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\nvec4 sample = texture2D(uSampler, coord);\ngl_FragColor = sample * uColor;\n}\n`;\nconst shaderSimpleFrag = `\nvarying vec3 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\nvec4 sample = texture2D(uSampler, vTextureCoord.xy / vTextureCoord.z);\ngl_FragColor = sample * uColor;\n}\n`;\n\n// changed\nconst tempMat = new Matrix2d();\n\nexport class TilingSprite2dRenderer extends ObjectRenderer\n{\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        const uniforms = { globals: this.renderer.globalUniforms };\n\n        this.shader = Shader.from(shaderVert, shaderFrag, uniforms);\n\n        this.simpleShader = Shader.from(shaderVert, shaderSimpleFrag, uniforms);\n    }\n\n    shader: Shader;\n    simpleShader: Shader;\n    quad = new QuadUv();\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    render(ts: any): void\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        if (ts.uvRespectAnchor)\n        {\n            vertices = quad.uvs;\n\n            vertices[0] = vertices[6] = -ts.anchor.x;\n            vertices[1] = vertices[3] = -ts.anchor.y;\n\n            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n        }\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const lt = ts.tileProj.world;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[(renderer as any).CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        // changed\n        tempMat.identity();\n        tempMat.scale(tex.width, tex.height);\n        tempMat.prepend(lt);\n        tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha,\n            shader.uniforms.uColor, baseTex.premultiplyAlpha);\n        shader.uniforms.translationMatrix = ts.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader, false);\n        renderer.geometry.bind(quad as any, undefined);// , renderer.shader.getGLShader());\n\n        renderer.state.setBlendMode(correctBlendMode(ts.blendMode, baseTex.premultiplyAlpha));\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES, 6, 0);\n    }\n}\n","/* eslint-disable no-mixed-operators */\nimport { Matrix2d } from './Matrix2d';\nimport { IPointData, Matrix, ObservablePoint, Point, Rectangle, Transform } from '@pixi/math';\nimport { Sprite } from '@pixi/sprite';\nimport { LinearProjection } from '../base';\nimport { getIntersectionFactor } from '../utils';\n\nconst t0 = new Point();\nconst tt = [new Point(), new Point(), new Point(), new Point()];\nconst tempRect = new Rectangle();\nconst tempMat = new Matrix2d();\n\nexport class Projection2d extends LinearProjection<Matrix2d>\n{\n    constructor(legacy: Transform, enable?: boolean)\n    {\n        super(legacy, enable);\n        this.local = new Matrix2d();\n        this.world = new Matrix2d();\n    }\n\n    matrix = new Matrix2d();\n    pivot = new ObservablePoint(this.onChange, this, 0, 0);\n\n    reverseLocalOrder = false;\n\n    onChange(): void\n    {\n        const pivot = this.pivot;\n        const mat3 = this.matrix.mat3;\n\n        mat3[6] = -(pivot._x * mat3[0] + pivot._y * mat3[3]);\n        mat3[7] = -(pivot._x * mat3[1] + pivot._y * mat3[4]);\n\n        this._projID++;\n    }\n\n    setAxisX(p: IPointData, factor = 1): void\n    {\n        const x = p.x; const\n            y = p.y;\n        const d = Math.sqrt(x * x + y * y);\n        const mat3 = this.matrix.mat3;\n\n        mat3[0] = x / d;\n        mat3[1] = y / d;\n        mat3[2] = factor / d;\n\n        this.onChange();\n    }\n\n    setAxisY(p: IPointData, factor = 1): void\n    {\n        const x = p.x; const\n            y = p.y;\n        const d = Math.sqrt(x * x + y * y);\n        const mat3 = this.matrix.mat3;\n\n        mat3[3] = x / d;\n        mat3[4] = y / d;\n        mat3[5] = factor / d;\n        this.onChange();\n    }\n\n    mapSprite(sprite: Sprite, quad: Array<IPointData>): void\n    {\n        const tex = sprite.texture;\n\n        tempRect.x = -sprite.anchor.x * tex.orig.width;\n        tempRect.y = -sprite.anchor.y * tex.orig.height;\n        tempRect.width = tex.orig.width;\n        tempRect.height = tex.orig.height;\n\n        this.mapQuad(tempRect, quad);\n    }\n\n    mapQuad(rect: Rectangle, p: Array<IPointData>): void\n    {\n        // utils.getPositionFromQuad(p, anchor, t0);\n        tt[0].set(rect.x, rect.y);\n        tt[1].set(rect.x + rect.width, rect.y);\n        tt[2].set(rect.x + rect.width, rect.y + rect.height);\n        tt[3].set(rect.x, rect.y + rect.height);\n\n        let k1 = 1; let k2 = 2;\n        let k3 = 3;\n        const f = getIntersectionFactor(p[0], p[2], p[1], p[3], t0);\n\n        if (f !== 0)\n        {\n            k1 = 1;\n            k2 = 3;\n            k3 = 2;\n        }\n        else\n        {\n            return;\n            /* f = utils.getIntersectionFactor(p[0], p[1], p[2], p[3], t0);\n            if (f > 0) {\n                k1 = 2;\n                k2 = 3;\n                k3 = 1;\n            } else {\n                f = utils.getIntersectionFactor(p[0], p[3], p[1], p[2], t0);\n                if (f > 0) {\n                    // cant find it :(\n                    k1 = 1;\n                    k2 = 2;\n                    k3 = 3;\n                } else {\n                    return;\n                }\n            }*/\n        }\n        const d0 = Math.sqrt((p[0].x - t0.x) * (p[0].x - t0.x) + (p[0].y - t0.y) * (p[0].y - t0.y));\n        const d1 = Math.sqrt((p[k1].x - t0.x) * (p[k1].x - t0.x) + (p[k1].y - t0.y) * (p[k1].y - t0.y));\n        const d2 = Math.sqrt((p[k2].x - t0.x) * (p[k2].x - t0.x) + (p[k2].y - t0.y) * (p[k2].y - t0.y));\n        const d3 = Math.sqrt((p[k3].x - t0.x) * (p[k3].x - t0.x) + (p[k3].y - t0.y) * (p[k3].y - t0.y));\n\n        const q0 = (d0 + d3) / d3;\n        const q1 = (d1 + d2) / d2;\n        const q2 = (d1 + d2) / d1;\n\n        let mat3 = this.matrix.mat3;\n\n        mat3[0] = tt[0].x * q0;\n        mat3[1] = tt[0].y * q0;\n        mat3[2] = q0;\n        mat3[3] = tt[k1].x * q1;\n        mat3[4] = tt[k1].y * q1;\n        mat3[5] = q1;\n        mat3[6] = tt[k2].x * q2;\n        mat3[7] = tt[k2].y * q2;\n        mat3[8] = q2;\n        this.matrix.invert();\n\n        mat3 = tempMat.mat3;\n        mat3[0] = p[0].x;\n        mat3[1] = p[0].y;\n        mat3[2] = 1;\n        mat3[3] = p[k1].x;\n        mat3[4] = p[k1].y;\n        mat3[5] = 1;\n        mat3[6] = p[k2].x;\n        mat3[7] = p[k2].y;\n        mat3[8] = 1;\n\n        this.matrix.setToMult(tempMat, this.matrix);\n        this._projID++;\n    }\n\n    updateLocalTransform(lt: Matrix): void\n    {\n        if (this._projID !== 0)\n        {\n            if (this.reverseLocalOrder)\n            {\n                // tilingSprite inside order\n                this.local.setToMultLegacy2(this.matrix, lt);\n            }\n            else\n            {\n                // good order\n                this.local.setToMultLegacy(lt, this.matrix);\n            }\n        }\n        else\n        {\n            this.local.copyFrom(lt);\n        }\n    }\n\n    clear(): void\n    {\n        super.clear();\n        this.matrix.identity();\n        this.pivot.set(0, 0);\n    }\n}\n","import { Projection2d } from './Projection2d';\nimport { Container, DisplayObject } from '@pixi/display';\nimport { IPointData, Matrix, Point } from '@pixi/math';\nimport { TRANSFORM_STEP } from '../base';\n\nexport function container2dWorldTransform(): Matrix\n{\n    return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n}\n\nexport class Container2d extends Container\n{\n    constructor()\n    {\n        super();\n        this.proj = new Projection2d(this.transform);\n    }\n\n    proj: Projection2d;\n\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n        }\n\n        if (step >= TRANSFORM_STEP.PROJ)\n        {\n            if (!skipUpdate)\n            {\n                this.displayObjectUpdateTransform();\n            }\n            if (this.proj.affine)\n            {\n                return this.transform.worldTransform.applyInverse(position, point) as any;\n            }\n\n            return this.proj.world.applyInverse(position, point) as any;\n        }\n\n        if (this.parent)\n        {\n            point = this.parent.worldTransform.applyInverse(position, point) as any;\n        }\n        else\n        {\n            point.x = position.x;\n            point.y = position.y;\n        }\n        if (step === TRANSFORM_STEP.NONE)\n        {\n            return point;\n        }\n\n        return this.transform.localTransform.applyInverse(point, point) as any;\n    }\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n}\n\nexport const container2dToLocal = Container2d.prototype.toLocal;\n","import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { Geometry, Program, Renderer, State, Texture } from '@pixi/core';\nimport { Projection2d } from '../Projection2d';\nimport { IPointData, Matrix } from '@pixi/math';\nimport { DisplayObject } from '@pixi/display';\nimport { TRANSFORM_STEP } from '../../base';\nimport { container2dToLocal } from '../Container2d';\n\nexport class Mesh2d extends Mesh\n{\n    static defaultVertexShader =\n        `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\ngl_Position.z = 0.0;\n\nvTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n`;\n    static defaultFragmentShader = `\nvarying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\ngl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}`;\n    constructor(geometry: Geometry, shader: MeshMaterial, state: State, drawMode?: number)\n    {\n        super(geometry, shader, state, drawMode);\n        this.proj = new Projection2d(this.transform);\n    }\n\n    vertexData2d: Float32Array = null;\n    proj: Projection2d;\n\n    calculateVertices(): void\n    {\n        if (this.proj._affine)\n        {\n            this.vertexData2d = null;\n            super.calculateVertices();\n\n            return;\n        }\n\n        const geometry = this.geometry as any;\n        const vertices = geometry.buffers[0].data;\n        const thisAny = this as any;\n\n        if (geometry.vertexDirtyId === thisAny.vertexDirty && thisAny._transformID === thisAny.transform._worldID)\n        {\n            return;\n        }\n\n        thisAny._transformID = thisAny.transform._worldID;\n\n        if (thisAny.vertexData.length !== vertices.length)\n        {\n            thisAny.vertexData = new Float32Array(vertices.length);\n        }\n\n        if (!this.vertexData2d || this.vertexData2d.length !== vertices.length * 3 / 2)\n        {\n            this.vertexData2d = new Float32Array(vertices.length * 3);\n        }\n\n        const wt = this.proj.world.mat3;\n\n        const vertexData2d = this.vertexData2d;\n        const vertexData = thisAny.vertexData;\n\n        for (let i = 0; i < vertexData.length / 2; i++)\n        {\n            const x = vertices[(i * 2)];\n            const y = vertices[(i * 2) + 1];\n\n            const xx = (wt[0] * x) + (wt[3] * y) + wt[6];\n            const yy = (wt[1] * x) + (wt[4] * y) + wt[7];\n            const ww = (wt[2] * x) + (wt[5] * y) + wt[8];\n\n            vertexData2d[i * 3] = xx;\n            vertexData2d[(i * 3) + 1] = yy;\n            vertexData2d[(i * 3) + 2] = ww;\n\n            vertexData[(i * 2)] = xx / ww;\n            vertexData[(i * 2) + 1] = yy / ww;\n        }\n\n        thisAny.vertexDirty = geometry.vertexDirtyId;\n    }\n\n    _renderDefault(renderer: Renderer): void\n    {\n        const shader = this.shader as MeshMaterial;\n\n        shader.alpha = this.worldAlpha;\n        if (shader.update)\n        {\n            shader.update();\n        }\n\n        renderer.batch.flush();\n\n        if ((shader as any).program.uniformData?.translationMatrix)\n        {\n            shader.uniforms.translationMatrix = this.worldTransform.toArray(true);\n        }\n\n        // bind and sync uniforms..\n        renderer.shader.bind(shader, false);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // bind the geometry...\n        renderer.geometry.bind(this.geometry, shader);\n\n        // then render it\n        renderer.geometry.draw(this.drawMode, this.size, this.start, (this.geometry as any).instanceCount);\n    }\n\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\n        point?: T, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): T\n    {\n        return container2dToLocal.call(this, position, from, point, skipUpdate, step);\n    }\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n}\n\nexport class SimpleMesh2d extends Mesh2d\n{\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array,\n        indices?: Uint16Array, drawMode?: number)\n    {\n        super(new MeshGeometry(vertices, uvs, indices),\n            new MeshMaterial(texture, {\n                program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\n                pluginName: 'batch2d'\n            }),\n            null,\n            drawMode);\n\n        (this.geometry.getBuffer('aVertexPosition') as any).static = false;\n    }\n\n    autoUpdate = true;\n\n    get vertices(): Float32Array\n    {\n        return this.geometry.getBuffer('aVertexPosition').data as Float32Array;\n    }\n    set vertices(value: Float32Array)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    protected _render(renderer?: Renderer): void\n    {\n        if (this.autoUpdate)\n        {\n            this.geometry.getBuffer('aVertexPosition').update();\n        }\n\n        (super._render as any)(renderer);\n    }\n}\n","/* eslint-disable no-mixed-operators */\nimport { Sprite } from '@pixi/sprite';\nimport { Texture } from '@pixi/core';\nimport { Projection2d } from '../Projection2d';\nimport { IPointData, Matrix, Point } from '@pixi/math';\nimport { DisplayObject } from '@pixi/display';\nimport { TRANSFORM_STEP } from '../../base';\nimport { container2dToLocal } from '../Container2d';\n\nexport class Sprite2d extends Sprite\n{\n    constructor(texture: Texture)\n    {\n        super(texture);\n        this.proj = new Projection2d(this.transform);\n        this.pluginName = 'batch2d';\n    }\n\n    vertexData2d: Float32Array = null;\n    proj: Projection2d;\n\n    _calculateBounds(): void\n    {\n        this.calculateTrimmedVertices();\n        this._bounds.addQuad((this as any).vertexTrimmedData);\n    }\n\n    calculateVertices(): void\n    {\n        const texture = this._texture;\n        const thisAny = this as any;\n\n        if (this.proj._affine)\n        {\n            this.vertexData2d = null;\n            super.calculateVertices();\n\n            return;\n        }\n        if (!this.vertexData2d)\n        {\n            this.vertexData2d = new Float32Array(12);\n        }\n\n        const wid = (this.transform as any)._worldID;\n        const tuid = (texture as any)._updateID;\n\n        if (thisAny._transformID === wid && this._textureID === tuid)\n        {\n            return;\n        }\n        // update texture UV here, because base texture can be changed without calling `_onTextureUpdate`\n        if (this._textureID !== tuid)\n        {\n            (this as any).uvs = (texture as any)._uvs.uvsFloat32;\n        }\n\n        thisAny._transformID = wid;\n        this._textureID = tuid;\n\n        const wt = this.proj.world.mat3;\n        const vertexData2d = this.vertexData2d;\n        const vertexData = this.vertexData;\n        const trim = texture.trim;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        let w0: number;\n        let w1: number;\n        let h0: number;\n        let h1: number;\n\n        if (trim)\n        {\n            w1 = trim.x - (anchor._x * orig.width);\n            w0 = w1 + trim.width;\n\n            h1 = trim.y - (anchor._y * orig.height);\n            h0 = h1 + trim.height;\n        }\n        else\n        {\n            w1 = -anchor._x * orig.width;\n            w0 = w1 + orig.width;\n\n            h1 = -anchor._y * orig.height;\n            h0 = h1 + orig.height;\n        }\n\n        vertexData2d[0] = (wt[0] * w1) + (wt[3] * h1) + wt[6];\n        vertexData2d[1] = (wt[1] * w1) + (wt[4] * h1) + wt[7];\n        vertexData2d[2] = (wt[2] * w1) + (wt[5] * h1) + wt[8];\n\n        vertexData2d[3] = (wt[0] * w0) + (wt[3] * h1) + wt[6];\n        vertexData2d[4] = (wt[1] * w0) + (wt[4] * h1) + wt[7];\n        vertexData2d[5] = (wt[2] * w0) + (wt[5] * h1) + wt[8];\n\n        vertexData2d[6] = (wt[0] * w0) + (wt[3] * h0) + wt[6];\n        vertexData2d[7] = (wt[1] * w0) + (wt[4] * h0) + wt[7];\n        vertexData2d[8] = (wt[2] * w0) + (wt[5] * h0) + wt[8];\n\n        vertexData2d[9] = (wt[0] * w1) + (wt[3] * h0) + wt[6];\n        vertexData2d[10] = (wt[1] * w1) + (wt[4] * h0) + wt[7];\n        vertexData2d[11] = (wt[2] * w1) + (wt[5] * h0) + wt[8];\n\n        vertexData[0] = vertexData2d[0] / vertexData2d[2];\n        vertexData[1] = vertexData2d[1] / vertexData2d[2];\n\n        vertexData[2] = vertexData2d[3] / vertexData2d[5];\n        vertexData[3] = vertexData2d[4] / vertexData2d[5];\n\n        vertexData[4] = vertexData2d[6] / vertexData2d[8];\n        vertexData[5] = vertexData2d[7] / vertexData2d[8];\n\n        vertexData[6] = vertexData2d[9] / vertexData2d[11];\n        vertexData[7] = vertexData2d[10] / vertexData2d[11];\n    }\n\n    calculateTrimmedVertices(): void\n    {\n        if (this.proj._affine)\n        {\n            super.calculateTrimmedVertices();\n\n            return;\n        }\n\n        const wid = (this.transform as any)._worldID;\n        const tuid = (this._texture as any)._updateID;\n        const thisAny = this as any;\n\n        if (!thisAny.vertexTrimmedData)\n        {\n            thisAny.vertexTrimmedData = new Float32Array(8);\n        }\n        else if (thisAny._transformTrimmedID === wid && this._textureTrimmedID === tuid)\n        {\n            return;\n        }\n\n        thisAny._transformTrimmedID = wid;\n        this._textureTrimmedID = tuid;\n\n        // lets do some special trim code!\n        const texture = this._texture;\n        const vertexData = thisAny.vertexTrimmedData;\n        const orig = texture.orig;\n        const w = (this as any).tileProj ? this._width : orig.width;\n        const h = (this as any).tileProj ? this._height : orig.height;\n        const anchor = this._anchor;\n\n        // lets calculate the new untrimmed bounds..\n        const wt = this.proj.world.mat3;\n\n        const w1 = -anchor._x * w;\n        const w0 = w1 + w;\n\n        const h1 = -anchor._y * h;\n        const h0 = h1 + h;\n\n        let z = 1.0 / (wt[2] * w1 + wt[5] * h1 + wt[8]);\n\n        vertexData[0] = z * ((wt[0] * w1) + (wt[3] * h1) + wt[6]);\n        vertexData[1] = z * ((wt[1] * w1) + (wt[4] * h1) + wt[7]);\n\n        z = 1.0 / (wt[2] * w0 + wt[5] * h1 + wt[8]);\n        vertexData[2] = z * ((wt[0] * w0) + (wt[3] * h1) + wt[6]);\n        vertexData[3] = z * ((wt[1] * w0) + (wt[4] * h1) + wt[7]);\n\n        z = 1.0 / (wt[2] * w0 + wt[5] * h0 + wt[8]);\n        vertexData[4] = z * ((wt[0] * w0) + (wt[3] * h0) + wt[6]);\n        vertexData[5] = z * ((wt[1] * w0) + (wt[4] * h0) + wt[7]);\n\n        z = 1.0 / (wt[2] * w1 + wt[5] * h0 + wt[8]);\n        vertexData[6] = z * ((wt[0] * w1) + (wt[3] * h0) + wt[6]);\n        vertexData[7] = z * ((wt[1] * w1) + (wt[4] * h0) + wt[7]);\n    }\n\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): P\n    {\n        return container2dToLocal.call(this, position, from, point, skipUpdate, step);\n    }\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n}\n","import { Renderer, Texture } from '@pixi/core';\nimport { IPointData, Matrix, Point, Transform } from '@pixi/math';\nimport { Projection2d } from '../Projection2d';\nimport { DisplayObject } from '@pixi/display';\nimport { TRANSFORM_STEP } from '../../base';\nimport { container2dToLocal } from '../Container2d';\nimport { TilingSprite } from '@pixi/sprite-tiling';\n\nconst tempTransform = new Transform();\n\nexport class TilingSprite2d extends TilingSprite\n{\n    constructor(texture: Texture, width: number, height: number)\n    {\n        super(texture, width, height);\n\n        this.tileProj = new Projection2d(this.tileTransform);\n        this.tileProj.reverseLocalOrder = true;\n        this.proj = new Projection2d(this.transform);\n\n        this.pluginName = 'tilingSprite2d';\n        this.uvRespectAnchor = true;\n    }\n\n    tileProj: Projection2d;\n    proj: Projection2d;\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): P\n    {\n        return container2dToLocal.call(this, position, from, point, skipUpdate, step);\n    }\n\n    _render(renderer: Renderer): void\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        // changed\n        this.tileTransform.updateTransform(tempTransform);\n        this.uvMatrix.update();\n\n        renderer.batch.setObjectRenderer((renderer.plugins as any)[this.pluginName]);\n        (renderer.plugins as any)[this.pluginName].render(this);\n    }\n}\n","import { Projection2d } from '../Projection2d';\nimport { Container2d, container2dWorldTransform } from '../Container2d';\nimport { TilingSprite } from '@pixi/sprite-tiling';\nimport { Program } from '@pixi/core';\nimport { MeshMaterial } from '@pixi/mesh';\nimport { Mesh2d } from '../mesh/Mesh2d';\nimport { SimpleMesh, SimpleRope } from '@pixi/mesh-extras';\nimport { Container } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { Sprite2d } from './Sprite2d';\nimport { TilingSprite2d } from '../tiling/TilingSprite2d';\n\nfunction convertTo2d()\n{\n    if (this.proj) return;\n    this.proj = new Projection2d(this.transform);\n    this.toLocal = Container2d.prototype.toLocal;\n    Object.defineProperty(this, 'worldTransform', {\n        get: container2dWorldTransform,\n        enumerable: true,\n        configurable: true\n    });\n}\n\nContainer.prototype.convertTo2d = convertTo2d;\n\nSprite.prototype.convertTo2d = function spriteConvertTo2d()\n{\n    if (this.proj) return;\n    this.calculateVertices = Sprite2d.prototype.calculateVertices;\n    this.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\n    this._calculateBounds = Sprite2d.prototype._calculateBounds;\n    this.pluginName = 'batch2d';\n    convertTo2d.call(this);\n};\n\nContainer.prototype.convertSubtreeTo2d = function convertSubtreeTo2d()\n{\n    this.convertTo2d();\n    for (let i = 0; i < this.children.length; i++)\n    {\n        this.children[i].convertSubtreeTo2d();\n    }\n};\n\nSimpleMesh.prototype.convertTo2d\n    = SimpleRope.prototype.convertTo2d\n        = function meshConvertTo2d()\n        {\n            if (this.proj) return;\n            this.calculateVertices = Mesh2d.prototype.calculateVertices;\n            this._renderDefault = Mesh2d.prototype._renderDefault;\n            if (this.material.pluginName !== 'batch2d')\n            {\n                this.material = new MeshMaterial(this.material.texture, {\n                    program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\n                    pluginName: 'batch2d'\n                });\n            }\n            convertTo2d.call(this);\n        };\n\nTilingSprite.prototype.convertTo2d = function tilingConvertTo2d()\n{\n    if (this.proj) return;\n\n    this.tileProj = new Projection2d(this.tileTransform);\n    this.tileProj.reverseLocalOrder = true;\n    this.uvRespectAnchor = true;\n\n    this.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\n    this._calculateBounds = Sprite2d.prototype._calculateBounds;\n    this._render = TilingSprite2d.prototype._render;\n\n    this.pluginName = 'tilingSprite2d';\n    convertTo2d.call(this);\n};\n","import { Text, TextStyle } from '@pixi/text';\nimport { Projection2d } from '../Projection2d';\nimport { Sprite2d } from './Sprite2d';\nimport { Matrix } from '@pixi/math';\n\nexport class Text2d extends Text\n{\n    constructor(text?: string, style?: TextStyle, canvas?: HTMLCanvasElement)\n    {\n        super(text, style, canvas);\n        this.proj = new Projection2d(this.transform);\n        this.pluginName = 'batch2d';\n    }\n\n    proj: Projection2d;\n    vertexData2d: Float32Array = null;\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n}\n\nText2d.prototype.calculateVertices = Sprite2d.prototype.calculateVertices;\nText2d.prototype.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\n(Text2d.prototype as any)._calculateBounds = Sprite2d.prototype._calculateBounds;\n","import { Sprite } from '@pixi/sprite';\nimport { Matrix2d } from '../Matrix2d';\nimport { Filter, FilterSystem, RenderTexture, TextureMatrix } from '@pixi/core';\nimport { Projection2d } from '../Projection2d';\n\nconst spriteMaskVert = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec3 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\nvTextureCoord = aTextureCoord;\nvMaskCoord = otherMatrix * vec3( aTextureCoord, 1.0);\n}\n`;\nconst spriteMaskFrag = `\nvarying vec3 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\nvec2 uv = vMaskCoord.xy / vMaskCoord.z;\n\nfloat clip = step(3.5,\n    step(maskClamp.x, uv.x) +\n    step(maskClamp.y, uv.y) +\n    step(uv.x, maskClamp.z) +\n    step(uv.y, maskClamp.w));\n\nvec4 original = texture2D(uSampler, vTextureCoord);\nvec4 masky = texture2D(mask, uv);\n\noriginal *= (masky.r * masky.a * alpha * clip);\n\ngl_FragColor = original;\n}\n`;\n\nconst tempMat = new Matrix2d();\n\nexport class SpriteMaskFilter2d extends Filter\n{\n    constructor(sprite: Sprite)\n    {\n        super(spriteMaskVert, spriteMaskFrag);\n\n        sprite.renderable = false;\n\n        this.maskSprite = sprite;\n    }\n\n    maskSprite: Sprite;\n    maskMatrix = new Matrix2d();\n\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture,\n        clearMode?: number): void\n    {\n        const maskSprite = this.maskSprite;\n        const tex = this.maskSprite.texture;\n\n        if (!tex.valid)\n        {\n            return;\n        }\n        if (!tex.uvMatrix)\n        {\n            // margin = 0.0, let it bleed a bit, shader code becomes easier\n            // assuming that atlas textures were made with 1-pixel padding\n            tex.uvMatrix = new TextureMatrix(tex, 0.0);\n        }\n        tex.uvMatrix.update();\n\n        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0.0 : 1.0;\n        this.uniforms.mask = maskSprite.texture;\n        this.uniforms.otherMatrix = SpriteMaskFilter2d.calculateSpriteMatrix(input, this.maskMatrix, maskSprite)\n            .prepend(tex.uvMatrix.mapCoord);\n        this.uniforms.alpha = maskSprite.worldAlpha;\n        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    static calculateSpriteMatrix(input: RenderTexture, mappedMatrix: Matrix2d, sprite: Sprite): Matrix2d\n    {\n        const proj = (sprite as any).proj as Projection2d;\n\n        const filterArea = (input as any).filterFrame;\n\n        // eslint-disable-next-line max-len\n        const worldTransform = proj && !proj._affine ? proj.world.copyTo2dOr3d(tempMat) : tempMat.copyFrom(sprite.transform.worldTransform);\n        const texture = sprite.texture.orig;\n\n        mappedMatrix.set(input.width, 0, 0, input.height, filterArea.x, filterArea.y);\n        worldTransform.invert();\n        mappedMatrix.setToMult(worldTransform, mappedMatrix);\n        mappedMatrix.scaleAndTranslate(1.0 / texture.width, 1.0 / texture.height,\n            sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n}\n","import { MaskData, MaskSystem } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { SpriteMaskFilter2d } from './SpriteMaskFilter';\n\nMaskSystem.prototype.pushSpriteMask = function pushSpriteMask(maskData: MaskData): void\n{\n    const { maskObject } = maskData;\n    const target = (maskData as any)._target;\n\n    let alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n\n    if (!alphaMaskFilter)\n    {\n        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter2d(maskObject as Sprite)];\n    }\n\n    alphaMaskFilter[0].resolution = this.renderer.resolution;\n    alphaMaskFilter[0].maskSprite = maskObject;\n\n    const stashFilterArea = target.filterArea;\n\n    target.filterArea = maskObject.getBounds(true);\n    this.renderer.filter.push(target, alphaMaskFilter);\n    target.filterArea = stashFilterArea;\n\n    this.alphaMaskIndex++;\n};\n","import { Renderer } from '@pixi/core';\nimport { TilingSprite2dRenderer } from './tiling/TilingSprite2dRenderer';\n\nexport * from './Matrix2d';\nexport * from './Projection2d';\nexport * from './Container2d';\n\nexport * from './sprites/convert';\nexport * from './sprites/Sprite2d';\nexport * from './sprites/Text2d';\n\nexport * from './tiling/TilingSprite2d';\nexport * from './tiling/TilingSprite2dRenderer';\n\nexport * from './z_masks/MaskHacker';\nexport * from './z_masks/SpriteMaskFilter';\n\nexport * from './mesh/Mesh2d';\n\nRenderer.registerPlugin('tilingSprite2d', TilingSprite2dRenderer as any);\n","import { IPoint, IPointData, ObservablePoint, Point } from '@pixi/math';\n\nexport class Point3d extends Point\n{\n    // TODO: pixi 6.1.0 global mixin\n    z: number;\n    constructor(x?: number, y?: number, z?: number)\n    {\n        super(x, y);\n        this.z = z;\n    }\n\n    set(x?: number, y?: number, z?: number): this\n    {\n        this.x = x || 0;\n        this.y = (y === undefined) ? this.x : (y || 0);\n        this.z = (y === undefined) ? this.x : (z || 0);\n\n        return this;\n    }\n\n    copyFrom(p: IPointData): this\n    {\n        // TODO: pixi 6.1.0 global mixin\n        this.set(p.x, p.y, (p as any).z || 0);\n\n        return this;\n    }\n\n    copyTo<T extends IPoint>(p: T): T\n    {\n        (p as any).set(this.x, this.y, this.z);\n\n        return p;\n    }\n}\n\nexport class ObservablePoint3d extends ObservablePoint\n{\n    _z = 0;\n\n    get z(): number\n    {\n        return this._z;\n    }\n\n    set z(value: number)\n    {\n        if (this._z !== value)\n        {\n            this._z = value;\n            this.cb.call(this.scope);\n        }\n    }\n\n    set(x?: number, y?: number, z?: number): this\n    {\n        const _x = x || 0;\n        const _y = (y === undefined) ? _x : (y || 0);\n        const _z = (y === undefined) ? _x : (z || 0);\n\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\n        {\n            this._x = _x;\n            this._y = _y;\n            this._z = _z;\n            this.cb.call(this.scope);\n        }\n\n        return this;\n    }\n\n    copyFrom(p: IPointData): this\n    {\n        // TODO: pixi 6.1.0 global mixin\n        this.set(p.x, p.y, (p as any).z || 0);\n\n        return this;\n    }\n\n    copyTo<T extends IPoint>(p: T): T\n    {\n        (p as any).set(this._x, this._y, this._z);\n\n        return p;\n    }\n}\n","import { IEuler } from './ObservableEuler';\n\nexport class Euler\n{\n    constructor(x?: number, y?: number, z?: number)\n    {\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this._x = x || 0;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this._y = y || 0;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this._z = z || 0;\n\n        this.quaternion = new Float64Array(4);\n        this.quaternion[3] = 1;\n\n        this.update();\n    }\n\n    _quatUpdateId = -1;\n    _quatDirtyId = 0;\n\n    quaternion: Float64Array;\n\n    _x: number;\n    _y: number;\n    _z: number;\n    _sign = 1;\n\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._quatDirtyId++;\n        }\n    }\n\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._quatDirtyId++;\n        }\n    }\n\n    get z(): number\n    {\n        return this._z;\n    }\n\n    set z(value: number)\n    {\n        if (this._z !== value)\n        {\n            this._z = value;\n            this._quatDirtyId++;\n        }\n    }\n\n    get pitch(): number\n    {\n        return this._x;\n    }\n\n    set pitch(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._quatDirtyId++;\n        }\n    }\n\n    get yaw(): number\n    {\n        return this._y;\n    }\n\n    set yaw(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._quatDirtyId++;\n        }\n    }\n\n    get roll(): number\n    {\n        return this._z;\n    }\n\n    set roll(value: number)\n    {\n        if (this._z !== value)\n        {\n            this._z = value;\n            this._quatDirtyId++;\n        }\n    }\n\n    set(x?: number, y?: number, z?: number): void\n    {\n        const _x = x || 0;\n        const _y = y || 0;\n        const _z = z || 0;\n\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\n        {\n            this._x = _x;\n            this._y = _y;\n            this._z = _z;\n            this._quatDirtyId++;\n        }\n    }\n\n    copyFrom(euler: IEuler): this\n    {\n        const _x = euler.x;\n        const _y = euler.y;\n        const _z = euler.z;\n\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\n        {\n            this._x = _x;\n            this._y = _y;\n            this._z = _z;\n            this._quatDirtyId++;\n        }\n\n        return this;\n    }\n\n    copyTo(p: IEuler): IEuler\n    {\n        p.set(this._x, this._y, this._z);\n\n        return p;\n    }\n\n    equals(euler: IEuler): boolean\n    {\n        return this._x === euler.x\n            && this._y === euler.y\n            && this._z === euler.z;\n    }\n\n    clone(): Euler\n    {\n        return new Euler(this._x, this._y, this._z);\n    }\n\n    update(): boolean\n    {\n        if (this._quatUpdateId === this._quatDirtyId)\n        {\n            return false;\n        }\n        this._quatUpdateId = this._quatDirtyId;\n\n        const c1 = Math.cos(this._x / 2);\n        const c2 = Math.cos(this._y / 2);\n        const c3 = Math.cos(this._z / 2);\n\n        const s = this._sign;\n        const s1 = s * Math.sin(this._x / 2);\n        const s2 = s * Math.sin(this._y / 2);\n        const s3 = s * Math.sin(this._z / 2);\n\n        const q = this.quaternion;\n\n        q[0] = (s1 * c2 * c3) + (c1 * s2 * s3);\n        q[1] = (c1 * s2 * c3) - (s1 * c2 * s3);\n        q[2] = (c1 * c2 * s3) + (s1 * s2 * c3);\n        q[3] = (c1 * c2 * c3) - (s1 * s2 * s3);\n\n        return true;\n    }\n}\n","import { Euler } from './Euler';\n\nexport type IEuler = Euler | ObservableEuler;\n\n/**\n * The Euler angles, order is YZX. Except for projections (camera.lookEuler), its reversed XZY\n * @class\n * @namespace PIXI.projection\n * @param x pitch\n * @param y yaw\n * @param z roll\n * @constructor\n */\n\nexport class ObservableEuler\n{\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(public cb: any, public scope: any, x?: number, y?: number, z?: number)\n    {\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this._x = x || 0;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this._y = y || 0;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this._z = z || 0;\n\n        this.quaternion = new Float64Array(4);\n        this.quaternion[3] = 1;\n\n        this.update();\n    }\n\n    _quatUpdateId = -1;\n    _quatDirtyId = 0;\n\n    quaternion: Float64Array;\n\n    _x: number;\n    _y: number;\n    _z: number;\n    _sign = 1;\n\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._quatDirtyId++;\n            this.cb.call(this.scope);\n        }\n    }\n\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._quatDirtyId++;\n            this.cb.call(this.scope);\n        }\n    }\n\n    get z(): number\n    {\n        return this._z;\n    }\n\n    set z(value: number)\n    {\n        if (this._z !== value)\n        {\n            this._z = value;\n            this._quatDirtyId++;\n            this.cb.call(this.scope);\n        }\n    }\n\n    get pitch(): number\n    {\n        return this._x;\n    }\n\n    set pitch(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._quatDirtyId++;\n            this.cb.call(this.scope);\n        }\n    }\n\n    get yaw(): number\n    {\n        return this._y;\n    }\n\n    set yaw(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._quatDirtyId++;\n            this.cb.call(this.scope);\n        }\n    }\n\n    get roll(): number\n    {\n        return this._z;\n    }\n\n    set roll(value: number)\n    {\n        if (this._z !== value)\n        {\n            this._z = value;\n            this._quatDirtyId++;\n            this.cb.call(this.scope);\n        }\n    }\n\n    set(x?: number, y?: number, z?: number): this\n    {\n        const _x = x || 0;\n        const _y = y || 0;\n        const _z = z || 0;\n\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\n        {\n            this._x = _x;\n            this._y = _y;\n            this._z = _z;\n            this._quatDirtyId++;\n            this.cb.call(this.scope);\n        }\n\n        return this;\n    }\n\n    copyFrom(euler: IEuler): this\n    {\n        const _x = euler.x;\n        const _y = euler.y;\n        const _z = euler.z;\n\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\n        {\n            this._x = _x;\n            this._y = _y;\n            this._z = _z;\n            this._quatDirtyId++;\n            this.cb.call(this.scope);\n        }\n\n        return this;\n    }\n\n    copyTo(p: IEuler): IEuler\n    {\n        p.set(this._x, this._y, this._z);\n\n        return p;\n    }\n\n    equals(euler: IEuler): boolean\n    {\n        return this._x === euler.x\n            && this._y === euler.y\n            && this._z === euler.z;\n    }\n\n    clone(): Euler\n    {\n        return new Euler(this._x, this._y, this._z);\n    }\n\n    update(): boolean\n    {\n        if (this._quatUpdateId === this._quatDirtyId)\n        {\n            return false;\n        }\n        this._quatUpdateId = this._quatDirtyId;\n\n        const c1 = Math.cos(this._x / 2);\n        const c2 = Math.cos(this._y / 2);\n        const c3 = Math.cos(this._z / 2);\n\n        const s = this._sign;\n        const s1 = s * Math.sin(this._x / 2);\n        const s2 = s * Math.sin(this._y / 2);\n        const s3 = s * Math.sin(this._z / 2);\n\n        const q = this.quaternion;\n\n        q[0] = (s1 * c2 * c3) + (c1 * s2 * s3);\n        q[1] = (c1 * s2 * c3) - (s1 * c2 * s3);\n        q[2] = (c1 * c2 * s3) + (s1 * s2 * c3);\n        q[3] = (c1 * c2 * c3) - (s1 * s2 * s3);\n\n        return true;\n    }\n}\n","/* eslint-disable no-mixed-operators,max-statements-per-line */\n// according to https://jsperf.com/obj-vs-array-view-access/1 , Float64Array is the best here\n\nimport { IPointData, Matrix, Point } from '@pixi/math';\nimport { Matrix2d } from '../proj2d';\nimport { Point3d } from './Point3d';\nimport { AFFINE } from '../base';\n\nconst mat4id = [1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1];\n\nexport class Matrix3d\n{\n    /**\n     * A default (identity) matrix\n     *\n     * @static\n     * @const\n     */\n    static readonly IDENTITY = new Matrix3d();\n\n    /**\n     * A temp matrix\n     *\n     * @static\n     * @const\n     */\n    static readonly TEMP_MATRIX = new Matrix3d();\n\n    /**\n     * mat4 implementation through array of 16 elements\n     */\n    mat4: Float64Array;\n\n    floatArray: Float32Array = null;\n\n    _dirtyId = 0;\n    _updateId = -1;\n    _mat4inv: Float64Array = null;\n    cacheInverse = false;\n\n    constructor(backingArray?: ArrayLike<number>)\n    {\n        this.mat4 = new Float64Array(backingArray || mat4id);\n    }\n\n    get a(): number\n    {\n        return this.mat4[0] / this.mat4[15];\n    }\n\n    set a(value: number)\n    {\n        this.mat4[0] = value * this.mat4[15];\n    }\n\n    get b(): number\n    {\n        return this.mat4[1] / this.mat4[15];\n    }\n\n    set b(value: number)\n    {\n        this.mat4[1] = value * this.mat4[15];\n    }\n\n    get c(): number\n    {\n        return this.mat4[4] / this.mat4[15];\n    }\n\n    set c(value: number)\n    {\n        this.mat4[4] = value * this.mat4[15];\n    }\n\n    get d(): number\n    {\n        return this.mat4[5] / this.mat4[15];\n    }\n\n    set d(value: number)\n    {\n        this.mat4[5] = value * this.mat4[15];\n    }\n\n    get tx(): number\n    {\n        return this.mat4[12] / this.mat4[15];\n    }\n\n    set tx(value: number)\n    {\n        this.mat4[12] = value * this.mat4[15];\n    }\n\n    get ty(): number\n    {\n        return this.mat4[13] / this.mat4[15];\n    }\n\n    set ty(value: number)\n    {\n        this.mat4[13] = value * this.mat4[15];\n    }\n\n    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        const mat4 = this.mat4;\n\n        mat4[0] = a;\n        mat4[1] = b;\n        mat4[2] = 0;\n        mat4[3] = 0;\n        mat4[4] = c;\n        mat4[5] = d;\n        mat4[6] = 0;\n        mat4[7] = 0;\n        mat4[8] = 0;\n        mat4[9] = 0;\n        mat4[10] = 1;\n        mat4[11] = 0;\n        mat4[12] = tx;\n        mat4[13] = ty;\n        mat4[14] = 0;\n        mat4[15] = 1;\n\n        return this;\n    }\n\n    toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.floatArray)\n        {\n            this.floatArray = new Float32Array(9);\n        }\n\n        const array = out || this.floatArray;\n        const mat3 = this.mat4;\n\n        if (transpose)\n        {\n            array[0] = mat3[0];\n            array[1] = mat3[1];\n            array[2] = mat3[3];\n            array[3] = mat3[4];\n            array[4] = mat3[5];\n            array[5] = mat3[7];\n            array[6] = mat3[12];\n            array[7] = mat3[13];\n            array[8] = mat3[15];\n        }\n        else\n        {\n            // this branch is NEVER USED in pixi\n            array[0] = mat3[0];\n            array[1] = mat3[4];\n            array[2] = mat3[12];\n            array[3] = mat3[2];\n            array[4] = mat3[6];\n            array[5] = mat3[13];\n            array[6] = mat3[3];\n            array[7] = mat3[7];\n            array[8] = mat3[15];\n        }\n\n        return array;\n    }\n\n    setToTranslation(tx: number, ty: number, tz: number): void\n    {\n        const mat4 = this.mat4;\n\n        mat4[0] = 1;\n        mat4[1] = 0;\n        mat4[2] = 0;\n        mat4[3] = 0;\n\n        mat4[4] = 0;\n        mat4[5] = 1;\n        mat4[6] = 0;\n        mat4[7] = 0;\n\n        mat4[8] = 0;\n        mat4[9] = 0;\n        mat4[10] = 1;\n        mat4[11] = 0;\n\n        mat4[12] = tx;\n        mat4[13] = ty;\n        mat4[14] = tz;\n        mat4[15] = 1;\n    }\n\n    // eslint-disable-next-line max-len\n    setToRotationTranslationScale(quat: Float64Array, tx: number, ty: number, tz: number, sx: number, sy: number, sz: number): Float64Array\n    {\n        const out = this.mat4;\n\n        const x = quat[0]; const y = quat[1]; const z = quat[2]; const\n            w = quat[3];\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        out[0] = (1 - (yy + zz)) * sx;\n        out[1] = (xy + wz) * sx;\n        out[2] = (xz - wy) * sx;\n        out[3] = 0;\n        out[4] = (xy - wz) * sy;\n        out[5] = (1 - (xx + zz)) * sy;\n        out[6] = (yz + wx) * sy;\n        out[7] = 0;\n        out[8] = (xz + wy) * sz;\n        out[9] = (yz - wx) * sz;\n        out[10] = (1 - (xx + yy)) * sz;\n        out[11] = 0;\n        out[12] = tx;\n        out[13] = ty;\n        out[14] = tz;\n        out[15] = 1;\n\n        return out;\n    }\n\n    apply(pos: IPointData, newPos: IPointData): IPointData\n    {\n        newPos = newPos || new Point3d();\n\n        const mat4 = this.mat4;\n        const x = pos.x;\n        const y = pos.y;\n        // TODO: pixi 6.1.0 global mixin\n        const z = (pos as any).z || 0;\n\n        // TODO: apply for 2d point\n\n        const w = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\n\n        newPos.x = w * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\n        newPos.y = w * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\n        // TODO: pixi 6.1.0 global mixin\n        (newPos as any).z = w * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\n\n        return newPos;\n    }\n\n    translate(tx: number, ty: number, tz: number): this\n    {\n        const a = this.mat4;\n\n        a[12] = a[0] * tx + a[4] * ty + a[8] * tz + a[12];\n        a[13] = a[1] * tx + a[5] * ty + a[9] * tz + a[13];\n        a[14] = a[2] * tx + a[6] * ty + a[10] * tz + a[14];\n        a[15] = a[3] * tx + a[7] * ty + a[11] * tz + a[15];\n\n        return this;\n    }\n\n    scale(x: number, y: number, z?: number): this\n    {\n        const mat4 = this.mat4;\n\n        mat4[0] *= x;\n        mat4[1] *= x;\n        mat4[2] *= x;\n        mat4[3] *= x;\n\n        mat4[4] *= y;\n        mat4[5] *= y;\n        mat4[6] *= y;\n        mat4[7] *= y;\n\n        if (z !== undefined)\n        {\n            mat4[8] *= z;\n            mat4[9] *= z;\n            mat4[10] *= z;\n            mat4[11] *= z;\n        }\n\n        return this;\n    }\n\n    scaleAndTranslate(scaleX: number, scaleY: number, scaleZ: number, tx: number, ty: number, tz: number): void\n    {\n        const mat4 = this.mat4;\n\n        mat4[0] = scaleX * mat4[0] + tx * mat4[3];\n        mat4[1] = scaleY * mat4[1] + ty * mat4[3];\n        mat4[2] = scaleZ * mat4[2] + tz * mat4[3];\n\n        mat4[4] = scaleX * mat4[4] + tx * mat4[7];\n        mat4[5] = scaleY * mat4[5] + ty * mat4[7];\n        mat4[6] = scaleZ * mat4[6] + tz * mat4[7];\n\n        mat4[8] = scaleX * mat4[8] + tx * mat4[11];\n        mat4[9] = scaleY * mat4[9] + ty * mat4[11];\n        mat4[10] = scaleZ * mat4[10] + tz * mat4[11];\n\n        mat4[12] = scaleX * mat4[12] + tx * mat4[15];\n        mat4[13] = scaleY * mat4[13] + ty * mat4[15];\n        mat4[14] = scaleZ * mat4[14] + tz * mat4[15];\n    }\n\n    // TODO: remove props\n    applyInverse<P extends IPointData = Point>(pos: IPointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point3d()) as any;\n        if (!this._mat4inv)\n        {\n            this._mat4inv = new Float64Array(16);\n        }\n\n        const mat4 = this._mat4inv;\n        const a = this.mat4;\n        const x = pos.x;\n        const y = pos.y;\n        // TODO: pixi 6.1.0 global mixin\n        let z = (pos as any).z || 0;\n\n        if (!this.cacheInverse || this._updateId !== this._dirtyId)\n        {\n            this._updateId = this._dirtyId;\n            Matrix3d.glMatrixMat4Invert(mat4, a);\n        }\n\n        const w1 = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\n        const x1 = w1 * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\n        const y1 = w1 * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\n        const z1 = w1 * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\n\n        z += 1.0;\n\n        const w2 = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\n        const x2 = w2 * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\n        const y2 = w2 * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\n        const z2 = w2 * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\n\n        if (Math.abs(z1 - z2) < 1e-10)\n        {\n            (newPos as any).set(NaN, NaN, 0);\n        }\n\n        const alpha = (0 - z1) / (z2 - z1);\n\n        (newPos as any).set((x2 - x1) * alpha + x1, (y2 - y1) * alpha + y1, 0.0);\n\n        return newPos;\n    }\n\n    invert(): Matrix3d\n    {\n        Matrix3d.glMatrixMat4Invert(this.mat4, this.mat4);\n\n        return this;\n    }\n\n    invertCopyTo(matrix: Matrix3d): void\n    {\n        if (!this._mat4inv)\n        {\n            this._mat4inv = new Float64Array(16);\n        }\n\n        const mat4 = this._mat4inv;\n        const a = this.mat4;\n\n        if (!this.cacheInverse || this._updateId !== this._dirtyId)\n        {\n            this._updateId = this._dirtyId;\n            Matrix3d.glMatrixMat4Invert(mat4, a);\n        }\n\n        matrix.mat4.set(mat4);\n    }\n\n    identity(): Matrix3d\n    {\n        const mat3 = this.mat4;\n\n        mat3[0] = 1;\n        mat3[1] = 0;\n        mat3[2] = 0;\n        mat3[3] = 0;\n\n        mat3[4] = 0;\n        mat3[5] = 1;\n        mat3[6] = 0;\n        mat3[7] = 0;\n\n        mat3[8] = 0;\n        mat3[9] = 0;\n        mat3[10] = 1;\n        mat3[11] = 0;\n\n        mat3[12] = 0;\n        mat3[13] = 0;\n        mat3[14] = 0;\n        mat3[15] = 1;\n\n        return this;\n    }\n\n    clone(): Matrix3d\n    {\n        return new Matrix3d(this.mat4);\n    }\n\n    copyTo3d(matrix: Matrix3d): Matrix3d\n    {\n        const mat3 = this.mat4;\n        const ar2 = matrix.mat4;\n\n        ar2[0] = mat3[0];\n        ar2[1] = mat3[1];\n        ar2[2] = mat3[2];\n        ar2[3] = mat3[3];\n        ar2[4] = mat3[4];\n        ar2[5] = mat3[5];\n        ar2[6] = mat3[6];\n        ar2[7] = mat3[7];\n        ar2[8] = mat3[8];\n\n        return matrix;\n    }\n\n    copyTo2d(matrix: Matrix2d): Matrix2d\n    {\n        const mat3 = this.mat4;\n        const ar2 = matrix.mat3;\n\n        ar2[0] = mat3[0];\n        ar2[1] = mat3[1];\n        ar2[2] = mat3[3];\n        ar2[3] = mat3[4];\n        ar2[4] = mat3[5];\n        ar2[5] = mat3[7];\n        ar2[6] = mat3[12];\n        ar2[7] = mat3[13];\n        ar2[8] = mat3[15];\n\n        return matrix;\n    }\n\n    copyTo2dOr3d<P extends Matrix2d | Matrix3d>(matrix: P): P\n    {\n        if (matrix instanceof Matrix2d)\n        {\n            return this.copyTo2d(matrix) as any;\n        }\n\n        return this.copyTo3d(matrix as any) as any;\n    }\n\n    /**\n     * legacy method, change the values of given pixi matrix\n     * @param matrix\n     * @param affine\n     * @param preserveOrientation\n     * @return matrix\n     */\n    copyTo(matrix: Matrix, affine?: AFFINE, preserveOrientation?: boolean): Matrix\n    {\n        const mat3 = this.mat4;\n        const d = 1.0 / mat3[15];\n        const tx = mat3[12] * d; const\n            ty = mat3[13] * d;\n\n        matrix.a = (mat3[0] - mat3[3] * tx) * d;\n        matrix.b = (mat3[1] - mat3[3] * ty) * d;\n        matrix.c = (mat3[4] - mat3[7] * tx) * d;\n        matrix.d = (mat3[5] - mat3[7] * ty) * d;\n        matrix.tx = tx;\n        matrix.ty = ty;\n\n        if (affine >= 2)\n        {\n            let D = matrix.a * matrix.d - matrix.b * matrix.c;\n\n            if (!preserveOrientation)\n            {\n                D = Math.abs(D);\n            }\n            if (affine === AFFINE.POINT)\n            {\n                if (D > 0)\n                {\n                    D = 1;\n                }\n                else D = -1;\n                matrix.a = D;\n                matrix.b = 0;\n                matrix.c = 0;\n                matrix.d = D;\n            }\n            else if (affine === AFFINE.AXIS_X)\n            {\n                D /= Math.sqrt(matrix.b * matrix.b + matrix.d * matrix.d);\n                matrix.c = 0;\n                matrix.d = D;\n            }\n            else if (affine === AFFINE.AXIS_Y)\n            {\n                D /= Math.sqrt(matrix.a * matrix.a + matrix.c * matrix.c);\n                matrix.a = D;\n                matrix.c = 0;\n            }\n        }\n\n        return matrix;\n    }\n\n    /**\n     * legacy method, change the values of given pixi matrix\n     * @param matrix\n     * @return\n     */\n    copyFrom(matrix: Matrix): this\n    {\n        const mat3 = this.mat4;\n\n        mat3[0] = matrix.a;\n        mat3[1] = matrix.b;\n        mat3[2] = 0;\n        mat3[3] = 0;\n\n        mat3[4] = matrix.c;\n        mat3[5] = matrix.d;\n        mat3[6] = 0;\n        mat3[7] = 0;\n\n        mat3[8] = 0;\n        mat3[9] = 0;\n        mat3[10] = 1;\n        mat3[11] = 0;\n\n        mat3[12] = matrix.tx;\n        mat3[13] = matrix.ty;\n        mat3[14] = 0;\n        mat3[15] = 1;\n\n        this._dirtyId++;\n\n        return this;\n    }\n\n    setToMultLegacy(pt: Matrix, lt: Matrix3d): this\n    {\n        const out = this.mat4;\n        const b = lt.mat4;\n\n        const a00 = pt.a; const a01 = pt.b;\n        const a10 = pt.c; const a11 = pt.d;\n        const a30 = pt.tx; const\n            a31 = pt.ty;\n\n        let b0 = b[0]; let b1 = b[1]; let b2 = b[2]; let\n            b3 = b[3];\n\n        out[0] = b0 * a00 + b1 * a10 + b3 * a30;\n        out[1] = b0 * a01 + b1 * a11 + b3 * a31;\n        out[2] = b2;\n        out[3] = b3;\n\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        b3 = b[7];\n        out[4] = b0 * a00 + b1 * a10 + b3 * a30;\n        out[5] = b0 * a01 + b1 * a11 + b3 * a31;\n        out[6] = b2;\n        out[7] = b3;\n\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        b3 = b[11];\n        out[8] = b0 * a00 + b1 * a10 + b3 * a30;\n        out[9] = b0 * a01 + b1 * a11 + b3 * a31;\n        out[10] = b2;\n        out[11] = b3;\n\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        b3 = b[15];\n        out[12] = b0 * a00 + b1 * a10 + b3 * a30;\n        out[13] = b0 * a01 + b1 * a11 + b3 * a31;\n        out[14] = b2;\n        out[15] = b3;\n\n        this._dirtyId++;\n\n        return this;\n    }\n\n    setToMultLegacy2(pt: Matrix3d, lt: Matrix): this\n    {\n        const out = this.mat4;\n        const a = pt.mat4;\n\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\n            a03 = a[3];\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\n            a13 = a[7];\n\n        const b00 = lt.a; const b01 = lt.b;\n        const b10 = lt.c; const b11 = lt.d;\n        const b30 = lt.tx; const\n            b31 = lt.ty;\n\n        out[0] = b00 * a00 + b01 * a10;\n        out[1] = b00 * a01 + b01 * a11;\n        out[2] = b00 * a02 + b01 * a12;\n        out[3] = b00 * a03 + b01 * a13;\n\n        out[4] = b10 * a00 + b11 * a10;\n        out[5] = b10 * a01 + b11 * a11;\n        out[6] = b10 * a02 + b11 * a12;\n        out[7] = b10 * a03 + b11 * a13;\n\n        out[8] = a[8];\n        out[9] = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n\n        out[12] = b30 * a00 + b31 * a10 + a[12];\n        out[13] = b30 * a01 + b31 * a11 + a[13];\n        out[14] = b30 * a02 + b31 * a12 + a[14];\n        out[15] = b30 * a03 + b31 * a13 + a[15];\n\n        this._dirtyId++;\n\n        return this;\n    }\n\n    // that's transform multiplication we use\n    setToMult(pt: Matrix3d, lt: Matrix3d): this\n    {\n        Matrix3d.glMatrixMat4Multiply(this.mat4, pt.mat4, lt.mat4);\n\n        this._dirtyId++;\n\n        return this;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    prepend(lt: any): void\n    {\n        if (lt.mat4)\n        {\n            this.setToMult(lt, this);\n        }\n        else\n        {\n            this.setToMultLegacy(lt, this);\n        }\n    }\n\n    static glMatrixMat4Invert(out: Float64Array, a: Float64Array): Float64Array\n    {\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\n            a03 = a[3];\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\n            a13 = a[7];\n        const a20 = a[8]; const a21 = a[9]; const a22 = a[10]; const\n            a23 = a[11];\n        const a30 = a[12]; const a31 = a[13]; const a32 = a[14]; const\n            a33 = a[15];\n\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant\n        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n        if (!det)\n        {\n            return null;\n        }\n        det = 1.0 / det;\n\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n        return out;\n    }\n\n    static glMatrixMat4Multiply(out: Float64Array, a: Float64Array, b: Float64Array): Float64Array\n    {\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\n            a03 = a[3];\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\n            a13 = a[7];\n        const a20 = a[8]; const a21 = a[9]; const a22 = a[10]; const\n            a23 = a[11];\n        const a30 = a[12]; const a31 = a[13]; const a32 = a[14]; const\n            a33 = a[15];\n\n        // Cache only the current line of the second matrix\n        let b0 = b[0]; let b1 = b[1]; let b2 = b[2]; let\n            b3 = b[3];\n\n        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        b3 = b[7];\n        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        b3 = b[11];\n        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        b3 = b[15];\n        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        return out;\n    }\n}\n","import { LinearProjection } from '../base';\nimport { ObservablePoint3d } from './Point3d';\nimport { Matrix, Transform } from '@pixi/math';\nimport { Matrix3d } from './Matrix3d';\nimport { ObservableEuler } from './ObservableEuler';\n\nconst tempMat = new Matrix3d();\n\nexport class Projection3d extends LinearProjection<Matrix3d>\n{\n    constructor(legacy: Transform, enable?: boolean)\n    {\n        super(legacy, enable);\n        this.local = new Matrix3d();\n        this.world = new Matrix3d();\n\n        this.local.cacheInverse = true;\n        this.world.cacheInverse = true;\n\n        this.position._z = 0;\n        this.scale._z = 1;\n        this.pivot._z = 0;\n    }\n\n    cameraMatrix: Matrix3d = null;\n\n    _cameraMode = false;\n\n    get cameraMode(): boolean\n    {\n        return this._cameraMode;\n    }\n\n    set cameraMode(value: boolean)\n    {\n        if (this._cameraMode === value)\n        {\n            return;\n        }\n        this._cameraMode = value;\n\n        this.euler._sign = this._cameraMode ? -1 : 1;\n        this.euler._quatDirtyId++;\n\n        if (value)\n        {\n            this.cameraMatrix = new Matrix3d();\n        }\n    }\n\n    position = new ObservablePoint3d(this.onChange, this, 0, 0);\n    scale = new ObservablePoint3d(this.onChange, this, 1, 1);\n    euler = new ObservableEuler(this.onChange, this, 0, 0, 0);\n    pivot = new ObservablePoint3d(this.onChange, this, 0, 0);\n\n    onChange(): void\n    {\n        this._projID++;\n    }\n\n    clear(): void\n    {\n        if (this.cameraMatrix)\n        {\n            this.cameraMatrix.identity();\n        }\n        this.position.set(0, 0, 0);\n        this.scale.set(1, 1, 1);\n        this.euler.set(0, 0, 0);\n        this.pivot.set(0, 0, 0);\n        super.clear();\n    }\n\n    updateLocalTransform(lt: Matrix): void\n    {\n        if (this._projID === 0)\n        {\n            this.local.copyFrom(lt);\n\n            return;\n        }\n        const matrix = this.local;\n        const euler = this.euler;\n        const pos = this.position;\n        const scale = this.scale;\n        const pivot = this.pivot;\n\n        euler.update();\n\n        if (!this.cameraMode)\n        {\n            matrix.setToRotationTranslationScale(euler.quaternion, pos._x, pos._y, pos._z, scale._x, scale._y, scale._z);\n            matrix.translate(-pivot._x, -pivot._y, -pivot._z);\n            matrix.setToMultLegacy(lt, matrix);\n\n            return;\n        }\n\n        matrix.setToMultLegacy(lt, this.cameraMatrix);\n        matrix.translate(pivot._x, pivot._y, pivot._z);\n        matrix.scale(1.0 / scale._x, 1.0 / scale._y, 1.0 / scale._z);\n        tempMat.setToRotationTranslationScale(euler.quaternion, 0, 0, 0, 1, 1, 1);\n        matrix.setToMult(matrix, tempMat);\n        matrix.translate(-pos._x, -pos._y, -pos._z);\n\n        this.local._dirtyId++;\n    }\n}\n","/* eslint-disable no-mixed-operators */\nimport { Projection3d } from './Projection3d';\nimport { Container, DisplayObject } from '@pixi/display';\nimport { IPointData, Matrix, Point } from '@pixi/math';\nimport { TRANSFORM_STEP } from '../base';\nimport { IEuler } from './ObservableEuler';\n\nexport function container3dWorldTransform(): Matrix\n{\n    return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n}\n\nexport interface IDisplayObject3d {\n    isFrontFace(forceUpdate?: boolean): boolean;\n    getDepth(forceUpdate?: boolean): number;\n    // eslint-disable-next-line max-len\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean, step?: TRANSFORM_STEP): P;\n    position3d: IPointData;\n    scale3d: IPointData;\n    euler: IEuler;\n    pivot3d: IPointData;\n}\n\nexport class Container3d extends Container implements IDisplayObject3d\n{\n    constructor()\n    {\n        super();\n        this.proj = new Projection3d(this.transform);\n    }\n\n    proj: Projection3d;\n\n    isFrontFace(forceUpdate = false): boolean\n    {\n        if (forceUpdate)\n        {\n            this._recursivePostUpdateTransform();\n            this.displayObjectUpdateTransform();\n        }\n\n        const mat = this.proj.world.mat4;\n        const dx1 = mat[0] * mat[15] - mat[3] * mat[12];\n        const dy1 = mat[1] * mat[15] - mat[3] * mat[13];\n        const dx2 = mat[4] * mat[15] - mat[7] * mat[12];\n        const dy2 = mat[5] * mat[15] - mat[7] * mat[13];\n\n        return dx1 * dy2 - dx2 * dy1 > 0;\n    }\n\n    /**\n     * returns depth from 0 to 1\n     *\n     * @param {boolean} forceUpdate whether to force matrix updates\n     * @returns {number} depth\n     */\n    getDepth(forceUpdate = false): number\n    {\n        if (forceUpdate)\n        {\n            this._recursivePostUpdateTransform();\n            this.displayObjectUpdateTransform();\n        }\n\n        const mat4 = this.proj.world.mat4;\n\n        return mat4[14] / mat4[15];\n    }\n\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n        }\n\n        if (step === TRANSFORM_STEP.ALL)\n        {\n            if (!skipUpdate)\n            {\n                this.displayObjectUpdateTransform();\n            }\n            if (this.proj.affine)\n            {\n                return this.transform.worldTransform.applyInverse(position, point) as any;\n            }\n\n            return this.proj.world.applyInverse(position, point) as any;\n        }\n\n        if (this.parent)\n        {\n            point = this.parent.worldTransform.applyInverse(position, point) as any;\n        }\n        else\n        {\n            point.x = position.x;\n            point.y = position.y;\n            // TODO: pixi 6.1.0 global mixin\n            (point as any).z = (position as any).z;\n        }\n        if (step === TRANSFORM_STEP.NONE)\n        {\n            return point;\n        }\n\n        point = this.transform.localTransform.applyInverse(point, point) as any;\n        if (step === TRANSFORM_STEP.PROJ && this.proj.cameraMode)\n        {\n            point = this.proj.cameraMatrix.applyInverse(point, point) as any;\n        }\n\n        return point;\n    }\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n\n    get position3d(): IPointData\n    {\n        return this.proj.position;\n    }\n    set position3d(value: IPointData)\n    {\n        this.proj.position.copyFrom(value);\n    }\n    get scale3d(): IPointData\n    {\n        return this.proj.scale;\n    }\n    set scale3d(value: IPointData)\n    {\n        this.proj.scale.copyFrom(value);\n    }\n    get euler(): IEuler\n    {\n        return this.proj.euler;\n    }\n    set euler(value: IEuler)\n    {\n        this.proj.euler.copyFrom(value);\n    }\n    get pivot3d(): IPointData\n    {\n        return this.proj.pivot;\n    }\n    set pivot3d(value: IPointData)\n    {\n        this.proj.pivot.copyFrom(value);\n    }\n}\n\nexport const container3dToLocal = Container3d.prototype.toLocal;\nexport const container3dGetDepth = Container3d.prototype.getDepth;\nexport const container3dIsFrontFace = Container3d.prototype.isFrontFace;\n","import { Container3d } from './Container3d';\n\nexport class Camera3d extends Container3d\n{\n    constructor()\n    {\n        super();\n        this.proj.cameraMode = true;\n        this.setPlanes(400, 10, 10000, false);\n    }\n\n    _far = 0;\n    _near = 0;\n    _focus = 0;\n    _orthographic = false;\n\n    get far(): number\n    {\n        return this._far;\n    }\n\n    get near(): number\n    {\n        return this._near;\n    }\n\n    get focus(): number\n    {\n        return this._focus;\n    }\n\n    get ortographic(): boolean\n    {\n        return this._orthographic;\n    }\n\n    setPlanes(focus: number, near = 10, far = 10000, orthographic = false): void\n    {\n        this._focus = focus;\n        this._near = near;\n        this._far = far;\n        this._orthographic = orthographic;\n\n        const proj = this.proj;\n        const mat4 = proj.cameraMatrix.mat4;\n\n        proj._projID++;\n\n        mat4[10] = 1.0 / (far - near);\n        mat4[14] = (focus - near) / (far - near);\n        if (this._orthographic)\n        {\n            mat4[11] = 0;\n        }\n        else\n        {\n            mat4[11] = 1.0 / focus;\n        }\n    }\n}\n","import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { Geometry, Program, Renderer, State, Texture } from '@pixi/core';\nimport { Projection3d } from '../Projection3d';\nimport { IPointData, Matrix } from '@pixi/math';\nimport { DisplayObject } from '@pixi/display';\nimport { TRANSFORM_STEP } from '../../base';\nimport { container3dGetDepth, container3dIsFrontFace, container3dToLocal } from '../Container3d';\nimport { Euler } from '../Euler';\nimport { Mesh2d } from '../../proj2d';\n\nexport class Mesh3d2d extends Mesh\n{\n    constructor(geometry: Geometry, shader: MeshMaterial, state: State, drawMode?: number)\n    {\n        super(geometry, shader, state, drawMode);\n        this.proj = new Projection3d(this.transform);\n    }\n\n    vertexData2d: Float32Array = null;\n    proj: Projection3d;\n\n    calculateVertices(): void\n    {\n        if (this.proj._affine)\n        {\n            this.vertexData2d = null;\n            super.calculateVertices();\n\n            return;\n        }\n\n        const geometry = this.geometry as any;\n        const vertices = geometry.buffers[0].data;\n        const thisAny = this as any;\n\n        if (geometry.vertexDirtyId === thisAny.vertexDirty && thisAny._transformID === thisAny.transform._worldID)\n        {\n            return;\n        }\n\n        thisAny._transformID = thisAny.transform._worldID;\n\n        if (thisAny.vertexData.length !== vertices.length)\n        {\n            thisAny.vertexData = new Float32Array(vertices.length);\n        }\n        if (!this.vertexData2d || this.vertexData2d.length !== vertices.length * 3 / 2)\n        {\n            this.vertexData2d = new Float32Array(vertices.length * 3);\n        }\n\n        const wt = this.proj.world.mat4;\n\n        const vertexData2d = this.vertexData2d;\n        const vertexData = thisAny.vertexData;\n\n        for (let i = 0; i < vertexData.length / 2; i++)\n        {\n            const x = vertices[(i * 2)];\n            const y = vertices[(i * 2) + 1];\n\n            const xx = (wt[0] * x) + (wt[4] * y) + wt[12];\n            const yy = (wt[1] * x) + (wt[5] * y) + wt[13];\n            const ww = (wt[3] * x) + (wt[7] * y) + wt[15];\n\n            vertexData2d[i * 3] = xx;\n            vertexData2d[(i * 3) + 1] = yy;\n            vertexData2d[(i * 3) + 2] = ww;\n\n            vertexData[(i * 2)] = xx / ww;\n            vertexData[(i * 2) + 1] = yy / ww;\n        }\n\n        thisAny.vertexDirty = geometry.vertexDirtyId;\n    }\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\n        point?: T, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): T\n    {\n        return container3dToLocal.call(this, position, from, point, skipUpdate, step);\n    }\n\n    isFrontFace(forceUpdate?: boolean): boolean\n    {\n        return container3dIsFrontFace.call(this, forceUpdate);\n    }\n\n    getDepth(forceUpdate?: boolean): boolean\n    {\n        return container3dGetDepth.call(this, forceUpdate);\n    }\n\n    get position3d(): IPointData\n    {\n        return this.proj.position;\n    }\n    set position3d(value: IPointData)\n    {\n        this.proj.position.copyFrom(value);\n    }\n    get scale3d(): IPointData\n    {\n        return this.proj.scale;\n    }\n    set scale3d(value: IPointData)\n    {\n        this.proj.scale.copyFrom(value);\n    }\n    get euler(): Euler\n    {\n        return this.proj.euler;\n    }\n    set euler(value: Euler)\n    {\n        this.proj.euler.copyFrom(value);\n    }\n    get pivot3d(): IPointData\n    {\n        return this.proj.pivot;\n    }\n    set pivot3d(value: IPointData)\n    {\n        this.proj.pivot.copyFrom(value);\n    }\n}\n\n(Mesh3d2d.prototype as any)._renderDefault = Mesh2d.prototype._renderDefault;\n\nexport class SimpleMesh3d2d extends Mesh3d2d\n{\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array,\n        indices?: Uint16Array, drawMode?: number)\n    {\n        super(new MeshGeometry(vertices, uvs, indices),\n            new MeshMaterial(texture, {\n                program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\n                pluginName: 'batch2d'\n            }),\n            null,\n            drawMode);\n\n        (this.geometry.getBuffer('aVertexPosition') as any).static = false;\n    }\n\n    autoUpdate = true;\n\n    get vertices(): Float32Array\n    {\n        return this.geometry.getBuffer('aVertexPosition').data as Float32Array;\n    }\n    set vertices(value: Float32Array)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    protected _render(renderer?: Renderer): void\n    {\n        if (this.autoUpdate)\n        {\n            this.geometry.getBuffer('aVertexPosition').update();\n        }\n\n        (super._render as any)(renderer);\n    }\n}\n","import { Sprite } from '@pixi/sprite';\nimport { Renderer, Texture } from '@pixi/core';\nimport { Projection3d } from '../Projection3d';\nimport { IPointData, Matrix } from '@pixi/math';\nimport { DisplayObject } from '@pixi/display';\nimport { TRANSFORM_STEP } from '../../base';\nimport { container3dGetDepth, container3dIsFrontFace, container3dToLocal } from '../Container3d';\nimport { Euler } from '../Euler';\n/**\n * Same as Sprite2d, but\n * 1. uses Matrix3d in proj\n * 2. does not render if at least one vertex is behind camera\n */\nexport class Sprite3d extends Sprite\n{\n    constructor(texture: Texture)\n    {\n        super(texture);\n        this.proj = new Projection3d(this.transform);\n        this.pluginName = 'batch2d';\n    }\n\n    vertexData2d: Float32Array = null;\n    proj: Projection3d;\n    culledByFrustrum = false;\n    trimmedCulledByFrustrum = false;\n\n    calculateVertices(): void\n    {\n        const texture = this._texture;\n\n        if (this.proj._affine)\n        {\n            this.vertexData2d = null;\n            super.calculateVertices();\n\n            return;\n        }\n        if (!this.vertexData2d)\n        {\n            this.vertexData2d = new Float32Array(12);\n        }\n\n        const wid = (this.transform as any)._worldID;\n        const tuid = (texture as any)._updateID;\n        const thisAny = this as any;\n\n        if (thisAny._transformID === wid && this._textureID === tuid)\n        {\n            return;\n        }\n        // update texture UV here, because base texture can be changed without calling `_onTextureUpdate`\n        if (this._textureID !== tuid)\n        {\n            (this as any).uvs = (texture as any)._uvs.uvsFloat32;\n        }\n\n        thisAny._transformID = wid;\n        this._textureID = tuid;\n\n        const wt = this.proj.world.mat4;\n        const vertexData2d = this.vertexData2d;\n        const vertexData = this.vertexData;\n        const trim = texture.trim;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        let w0: number;\n        let w1: number;\n        let h0: number;\n        let h1: number;\n\n        if (trim)\n        {\n            w1 = trim.x - (anchor._x * orig.width);\n            w0 = w1 + trim.width;\n\n            h1 = trim.y - (anchor._y * orig.height);\n            h0 = h1 + trim.height;\n        }\n        else\n        {\n            w1 = -anchor._x * orig.width;\n            w0 = w1 + orig.width;\n\n            h1 = -anchor._y * orig.height;\n            h0 = h1 + orig.height;\n        }\n\n        let culled = false;\n\n        let z;\n\n        vertexData2d[0] = (wt[0] * w1) + (wt[4] * h1) + wt[12];\n        vertexData2d[1] = (wt[1] * w1) + (wt[5] * h1) + wt[13];\n        z = (wt[2] * w1) + (wt[6] * h1) + wt[14];\n        vertexData2d[2] = (wt[3] * w1) + (wt[7] * h1) + wt[15];\n        culled = culled || z < 0;\n\n        vertexData2d[3] = (wt[0] * w0) + (wt[4] * h1) + wt[12];\n        vertexData2d[4] = (wt[1] * w0) + (wt[5] * h1) + wt[13];\n        z = (wt[2] * w0) + (wt[6] * h1) + wt[14];\n        vertexData2d[5] = (wt[3] * w0) + (wt[7] * h1) + wt[15];\n        culled = culled || z < 0;\n\n        vertexData2d[6] = (wt[0] * w0) + (wt[4] * h0) + wt[12];\n        vertexData2d[7] = (wt[1] * w0) + (wt[5] * h0) + wt[13];\n        z = (wt[2] * w0) + (wt[6] * h0) + wt[14];\n        vertexData2d[8] = (wt[3] * w0) + (wt[7] * h0) + wt[15];\n        culled = culled || z < 0;\n\n        vertexData2d[9] = (wt[0] * w1) + (wt[4] * h0) + wt[12];\n        vertexData2d[10] = (wt[1] * w1) + (wt[5] * h0) + wt[13];\n        z = (wt[2] * w1) + (wt[6] * h0) + wt[14];\n        vertexData2d[11] = (wt[3] * w1) + (wt[7] * h0) + wt[15];\n        culled = culled || z < 0;\n\n        this.culledByFrustrum = culled;\n\n        vertexData[0] = vertexData2d[0] / vertexData2d[2];\n        vertexData[1] = vertexData2d[1] / vertexData2d[2];\n\n        vertexData[2] = vertexData2d[3] / vertexData2d[5];\n        vertexData[3] = vertexData2d[4] / vertexData2d[5];\n\n        vertexData[4] = vertexData2d[6] / vertexData2d[8];\n        vertexData[5] = vertexData2d[7] / vertexData2d[8];\n\n        vertexData[6] = vertexData2d[9] / vertexData2d[11];\n        vertexData[7] = vertexData2d[10] / vertexData2d[11];\n    }\n\n    calculateTrimmedVertices(): void\n    {\n        if (this.proj._affine)\n        {\n            super.calculateTrimmedVertices();\n\n            return;\n        }\n\n        const wid = (this.transform as any)._worldID;\n        const tuid = (this._texture as any)._updateID;\n        const thisAny = this as any;\n\n        if (!thisAny.vertexTrimmedData)\n        {\n            thisAny.vertexTrimmedData = new Float32Array(8);\n        }\n        else if (thisAny._transformTrimmedID === wid && this._textureTrimmedID === tuid)\n        {\n            return;\n        }\n\n        thisAny._transformTrimmedID = wid;\n        this._textureTrimmedID = tuid;\n\n        // lets do some special trim code!\n        const texture = this._texture;\n        const vertexData = thisAny.vertexTrimmedData;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        // lets calculate the new untrimmed bounds..\n        const wt = this.proj.world.mat4;\n\n        const w1 = -anchor._x * orig.width;\n        const w0 = w1 + orig.width;\n\n        const h1 = -anchor._y * orig.height;\n        const h0 = h1 + orig.height;\n\n        let culled = false;\n\n        let z;\n\n        let w = 1.0 / ((wt[3] * w1) + (wt[7] * h1) + wt[15]);\n\n        vertexData[0] = w * ((wt[0] * w1) + (wt[4] * h1) + wt[12]);\n        vertexData[1] = w * ((wt[1] * w1) + (wt[5] * h1) + wt[13]);\n        z = (wt[2] * w1) + (wt[6] * h1) + wt[14];\n        culled = culled || z < 0;\n\n        w = 1.0 / ((wt[3] * w0) + (wt[7] * h1) + wt[15]);\n        vertexData[2] = w * ((wt[0] * w0) + (wt[4] * h1) + wt[12]);\n        vertexData[3] = w * ((wt[1] * w0) + (wt[5] * h1) + wt[13]);\n        z = (wt[2] * w0) + (wt[6] * h1) + wt[14];\n        culled = culled || z < 0;\n\n        w = 1.0 / ((wt[3] * w0) + (wt[7] * h0) + wt[15]);\n        vertexData[4] = w * ((wt[0] * w0) + (wt[4] * h0) + wt[12]);\n        vertexData[5] = w * ((wt[1] * w0) + (wt[5] * h0) + wt[13]);\n        z = (wt[2] * w0) + (wt[6] * h0) + wt[14];\n        culled = culled || z < 0;\n\n        w = 1.0 / ((wt[3] * w1) + (wt[7] * h0) + wt[15]);\n        vertexData[6] = w * ((wt[0] * w1) + (wt[4] * h0) + wt[12]);\n        vertexData[7] = w * ((wt[1] * w1) + (wt[5] * h0) + wt[13]);\n        z = (wt[2] * w1) + (wt[6] * h0) + wt[14];\n        culled = culled || z < 0;\n\n        this.culledByFrustrum = culled;\n    }\n\n    _calculateBounds(): void\n    {\n        this.calculateVertices();\n        if (this.culledByFrustrum)\n        {\n            return;\n        }\n\n        const trim = this._texture.trim;\n        const orig = this._texture.orig;\n\n        if (!trim || (trim.width === orig.width && trim.height === orig.height))\n        {\n            // no trim! lets use the usual calculations..\n            this._bounds.addQuad(this.vertexData);\n\n            return;\n        }\n\n        this.calculateTrimmedVertices();\n        if (!this.trimmedCulledByFrustrum)\n        {\n            this._bounds.addQuad((this as any).vertexTrimmedData as any);\n        }\n    }\n\n    _render(renderer: Renderer): void\n    {\n        this.calculateVertices();\n\n        if (this.culledByFrustrum)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer((renderer as any).plugins[this.pluginName]);\n        (renderer as any).plugins[this.pluginName].render(this);\n    }\n\n    containsPoint(point: IPointData): boolean\n    {\n        if (this.culledByFrustrum)\n        {\n            return false;\n        }\n\n        return super.containsPoint(point as any);\n    }\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\n        point?: T, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): T\n    {\n        return container3dToLocal.call(this, position, from, point, skipUpdate, step);\n    }\n\n    isFrontFace(forceUpdate?: boolean): boolean\n    {\n        return container3dIsFrontFace.call(this, forceUpdate);\n    }\n\n    getDepth(forceUpdate?: boolean): boolean\n    {\n        return container3dGetDepth.call(this, forceUpdate);\n    }\n\n    get position3d(): IPointData\n    {\n        return this.proj.position;\n    }\n    set position3d(value: IPointData)\n    {\n        this.proj.position.copyFrom(value);\n    }\n    get scale3d(): IPointData\n    {\n        return this.proj.scale;\n    }\n    set scale3d(value: IPointData)\n    {\n        this.proj.scale.copyFrom(value);\n    }\n    get euler(): Euler\n    {\n        return this.proj.euler;\n    }\n    set euler(value: Euler)\n    {\n        this.proj.euler.copyFrom(value);\n    }\n    get pivot3d(): IPointData\n    {\n        return this.proj.pivot;\n    }\n    set pivot3d(value: IPointData)\n    {\n        this.proj.pivot.copyFrom(value);\n    }\n}\n","import { Container3d, container3dWorldTransform } from '../Container3d';\nimport { Projection3d } from '../Projection3d';\nimport { Mesh3d2d } from '../mesh/Mesh3d2d';\nimport { MeshMaterial } from '@pixi/mesh';\nimport { Mesh2d } from '../../proj2d';\nimport { Program } from '@pixi/core';\nimport { SimpleMesh, SimpleRope } from '@pixi/mesh-extras';\nimport { Container } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { Sprite3d } from './Sprite3d';\n\nconst containerProps: any = {\n    worldTransform: {\n        get: container3dWorldTransform,\n        enumerable: true,\n        configurable: true\n    },\n    position3d: {\n        get() { return this.proj.position; },\n        set(value: any) { this.proj.position.copy(value); }\n    },\n    scale3d: {\n        get() { return this.proj.scale; },\n        set(value: any) { this.proj.scale.copy(value); }\n    },\n    pivot3d: {\n        get() { return this.proj.pivot; },\n        set(value: any) { this.proj.pivot.copy(value); }\n    },\n    euler: {\n        get() { return this.proj.euler; },\n        set(value: any) { this.proj.euler.copy(value); }\n    }\n};\n\nfunction convertTo3d()\n{\n    if (this.proj) return;\n    this.proj = new Projection3d(this.transform);\n    this.toLocal = Container3d.prototype.toLocal;\n    this.isFrontFace = Container3d.prototype.isFrontFace;\n    this.getDepth = Container3d.prototype.getDepth;\n    Object.defineProperties(this, containerProps);\n}\n\nContainer.prototype.convertTo3d = convertTo3d;\n\nSprite.prototype.convertTo3d = function spriteConvertTo3d()\n{\n    if (this.proj) return;\n    this.calculateVertices = Sprite3d.prototype.calculateVertices;\n    this.calculateTrimmedVertices = Sprite3d.prototype.calculateTrimmedVertices;\n    this._calculateBounds = Sprite3d.prototype._calculateBounds;\n    this.containsPoint = Sprite3d.prototype.containsPoint;\n    this.pluginName = 'batch2d';\n    convertTo3d.call(this);\n};\n\nContainer.prototype.convertSubtreeTo3d = function convertSubtreeTo3d()\n{\n    this.convertTo3d();\n    for (let i = 0; i < this.children.length; i++)\n    {\n        this.children[i].convertSubtreeTo3d();\n    }\n};\n\nSimpleMesh.prototype.convertTo3d\n    = SimpleRope.prototype.convertTo3d\n    = function meshConvert3d()\n        {\n            if (this.proj) return;\n            this.calculateVertices = Mesh3d2d.prototype.calculateVertices;\n            this._renderDefault = (Mesh3d2d.prototype as any)._renderDefault;\n            if (this.material.pluginName !== 'batch2d')\n            {\n                this.material = new MeshMaterial(this.material.texture, {\n                    program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\n                    pluginName: 'batch2d'\n                });\n            }\n            convertTo3d.call(this);\n        };\n","import { Text, TextStyle } from '@pixi/text';\nimport { Projection3d } from '../Projection3d';\nimport { IPointData, Matrix } from '@pixi/math';\nimport { container3dGetDepth, container3dIsFrontFace, container3dToLocal } from '../Container3d';\nimport { DisplayObject } from '@pixi/display';\nimport { TRANSFORM_STEP } from '../../base';\nimport { Sprite3d } from './Sprite3d';\nimport { Euler } from '../Euler';\n\nexport class Text3d extends Text\n{\n    constructor(text?: string, style?: TextStyle, canvas?: HTMLCanvasElement)\n    {\n        super(text, style, canvas);\n        this.proj = new Projection3d(this.transform);\n        this.pluginName = 'batch2d';\n    }\n\n    proj: Projection3d;\n    vertexData2d: Float32Array = null;\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\n        point?: T, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): T\n    {\n        return container3dToLocal.call(this, position, from, point, skipUpdate, step);\n    }\n\n    isFrontFace(forceUpdate?: boolean): boolean\n    {\n        return container3dIsFrontFace.call(this, forceUpdate);\n    }\n\n    getDepth(forceUpdate?: boolean): boolean\n    {\n        return container3dGetDepth.call(this, forceUpdate);\n    }\n\n    get position3d(): IPointData\n    {\n        return this.proj.position;\n    }\n    set position3d(value: IPointData)\n    {\n        this.proj.position.copyFrom(value);\n    }\n    get scale3d(): IPointData\n    {\n        return this.proj.scale;\n    }\n    set scale3d(value: IPointData)\n    {\n        this.proj.scale.copyFrom(value);\n    }\n    get euler(): Euler\n    {\n        return this.proj.euler;\n    }\n    set euler(value: Euler)\n    {\n        this.proj.euler.copyFrom(value);\n    }\n    get pivot3d(): IPointData\n    {\n        return this.proj.pivot;\n    }\n    set pivot3d(value: IPointData)\n    {\n        this.proj.pivot.copyFrom(value);\n    }\n}\n\nText3d.prototype.calculateVertices = Sprite3d.prototype.calculateVertices;\n(Text3d.prototype as any).calculateTrimmedVertices = Sprite3d.prototype.calculateTrimmedVertices;\n(Text3d.prototype as any)._calculateBounds = Sprite3d.prototype._calculateBounds;\nText3d.prototype.containsPoint = Sprite3d.prototype.containsPoint;\n(Text3d.prototype as any)._render = Sprite3d.prototype._render;\n","import { BatchShaderGenerator, Buffer, Geometry, Renderer, ViewableBuffer } from '@pixi/core';\nimport { TYPES } from '@pixi/constants';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Sprite } from '@pixi/sprite';\nimport { Sprite2s } from './sprites/Sprite2s';\nimport { Matrix } from '@pixi/math';\nimport { UniformBatchRenderer } from '../base';\n\nconst shaderVert = `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec3 aTrans1;\nattribute vec3 aTrans2;\nattribute vec2 aSamplerSize;\nattribute vec4 aFrame;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\n\nvarying vec2 vertexPosition;\nvarying vec3 vTrans1;\nvarying vec3 vTrans2;\nvarying vec2 vSamplerSize;\nvarying vec4 vFrame;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\ngl_Position.z = 0.0;\n\nvertexPosition = aVertexPosition;\nvTrans1 = aTrans1;\nvTrans2 = aTrans2;\nvTextureId = aTextureId;\nvColor = aColor;\nvSamplerSize = aSamplerSize;\nvFrame = aFrame;\n}\n`;\n\nconst shaderFrag = `precision highp float;\nvarying vec2 vertexPosition;\nvarying vec3 vTrans1;\nvarying vec3 vTrans2;\nvarying vec2 vSamplerSize;\nvarying vec4 vFrame;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nuniform sampler2D uSamplers[%count%];\nuniform vec4 distortion;\n\nvoid main(void){\nvec2 surface;\nvec2 surface2;\n\nfloat vx = vertexPosition.x;\nfloat vy = vertexPosition.y;\nfloat dx = distortion.x;\nfloat dy = distortion.y;\nfloat revx = distortion.z;\nfloat revy = distortion.w;\n\nif (distortion.x == 0.0) {\nsurface.x = vx;\nsurface.y = vy / (1.0 + dy * vx);\nsurface2 = surface;\n} else\nif (distortion.y == 0.0) {\nsurface.y = vy;\nsurface.x = vx / (1.0 + dx * vy);\nsurface2 = surface;\n} else {\nfloat c = vy * dx - vx * dy;\nfloat b = (c + 1.0) * 0.5;\nfloat b2 = (-c + 1.0) * 0.5;\nfloat d = b * b + vx * dy;\nif (d < -0.00001) {\n    discard;\n}\nd = sqrt(max(d, 0.0));\nsurface.x = (- b + d) * revy;\nsurface2.x = (- b - d) * revy;\nsurface.y = (- b2 + d) * revx;\nsurface2.y = (- b2 - d) * revx;\n}\n\nvec2 uv;\nuv.x = vTrans1.x * surface.x + vTrans1.y * surface.y + vTrans1.z;\nuv.y = vTrans2.x * surface.x + vTrans2.y * surface.y + vTrans2.z;\n\nvec2 pixels = uv * vSamplerSize;\n\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\npixels.y < vFrame.y || pixels.y > vFrame.w) {\nuv.x = vTrans1.x * surface2.x + vTrans1.y * surface2.y + vTrans1.z;\nuv.y = vTrans2.x * surface2.x + vTrans2.y * surface2.y + vTrans2.z;\npixels = uv * vSamplerSize;\n\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\n   pixels.y < vFrame.y || pixels.y > vFrame.w) {\n   discard;\n}\n}\n\nvec4 edge;\nedge.xy = clamp(pixels - vFrame.xy + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\nedge.zw = clamp(vFrame.zw - pixels + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\n\nfloat alpha = 1.0; //edge.x * edge.y * edge.z * edge.w;\nvec4 rColor = vColor * alpha;\n\nfloat textureId = floor(vTextureId+0.5);\nvec2 vTextureCoord = uv;\nvec4 color;\n%forloop%\ngl_FragColor = color * rColor;\n}`;\n\nexport class BatchBilineardGeometry extends Geometry\n{\n    _buffer: Buffer;\n    _indexBuffer : Buffer;\n\n    constructor(_static = false)\n    {\n        super();\n\n        this._buffer = new Buffer(null, _static, false);\n\n        this._indexBuffer = new Buffer(null, _static, true);\n\n        this.addAttribute('aVertexPosition', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aTrans1', this._buffer, 3, false, TYPES.FLOAT)\n            .addAttribute('aTrans2', this._buffer, 3, false, TYPES.FLOAT)\n            .addAttribute('aSamplerSize', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aFrame', this._buffer, 4, false, TYPES.FLOAT)\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\n            .addAttribute('aTextureId', this._buffer, 1, true, TYPES.FLOAT)\n            .addIndex(this._indexBuffer);\n    }\n}\n\nexport class BatchBilinearPluginFactory\n{\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    static create(options: any): any\n    {\n        const { vertex, fragment, vertexSize, geometryClass } = (Object as any).assign({\n            vertex: shaderVert,\n            fragment: shaderFrag,\n            geometryClass: BatchBilineardGeometry,\n            vertexSize: 16,\n        }, options);\n\n        return class BatchPlugin extends UniformBatchRenderer\n        {\n            constructor(renderer: Renderer)\n            {\n                super(renderer);\n\n                this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n                this.geometryClass = geometryClass;\n                this.vertexSize = vertexSize;\n            }\n\n            defUniforms = {\n                translationMatrix: new Matrix(),\n                distortion: new Float32Array([0, 0, Infinity, Infinity])\n            };\n            size = 1000;\n            forceMaxTextures = 1;\n\n            getUniforms(sprite: Sprite)\n            {\n                const { proj } = sprite as Sprite2s;\n\n                if (proj.surface !== null)\n                {\n                    return proj.uniforms;\n                }\n                if (proj._activeProjection !== null)\n                {\n                    return proj._activeProjection.uniforms;\n                }\n\n                return this.defUniforms;\n            }\n\n            // eslint-disable-next-line max-len\n            packInterleavedGeometry(element: any, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array, aIndex: number, iIndex: number)\n            {\n                const {\n                    uint32View,\n                    float32View,\n                } = attributeBuffer;\n                const p = aIndex / this.vertexSize;\n                const indices = element.indices;\n                const vertexData = element.vertexData;\n                const tex = element._texture;\n                const frame = tex._frame;\n                const aTrans = element.aTrans;\n                const { _batchLocation, realWidth, realHeight, resolution } = element._texture.baseTexture;\n\n                const alpha = Math.min(element.worldAlpha, 1.0);\n\n                const argb = alpha < 1.0 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha)\n                    : element._tintRGB + (alpha * 255 << 24);\n\n                for (let i = 0; i < vertexData.length; i += 2)\n                {\n                    float32View[aIndex] = vertexData[i];\n                    float32View[aIndex + 1] = vertexData[i + 1];\n\n                    float32View[aIndex + 2] = aTrans.a;\n                    float32View[aIndex + 3] = aTrans.c;\n                    float32View[aIndex + 4] = aTrans.tx;\n                    float32View[aIndex + 5] = aTrans.b;\n                    float32View[aIndex + 6] = aTrans.d;\n                    float32View[aIndex + 7] = aTrans.ty;\n\n                    float32View[aIndex + 8] = realWidth;\n                    float32View[aIndex + 9] = realHeight;\n                    float32View[aIndex + 10] = frame.x * resolution;\n                    float32View[aIndex + 11] = frame.y * resolution;\n                    float32View[aIndex + 12] = (frame.x + frame.width) * resolution;\n                    float32View[aIndex + 13] = (frame.y + frame.height) * resolution;\n\n                    uint32View[aIndex + 14] = argb;\n                    float32View[aIndex + 15] = _batchLocation;\n                    aIndex += 16;\n                }\n\n                for (let i = 0; i < indices.length; i++)\n                {\n                    indexBuffer[iIndex++] = p + indices[i];\n                }\n            }\n        };\n    }\n}\n","import { IPointData, Matrix, Point } from '@pixi/math';\nimport { IWorldTransform } from './ProjectionSurface';\nimport { Dict } from '@pixi/utils';\n\nconst p = [new Point(), new Point(), new Point(), new Point()];\nconst a = [0, 0, 0, 0];\n\nexport abstract class Surface implements IWorldTransform\n{\n    surfaceID = 'default';\n\n    _updateID = 0;\n\n    vertexSrc = '';\n    fragmentSrc = '';\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fillUniforms(uniforms: Dict<any>): void\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    {\n\n    }\n\n    clear(): void\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    {\n\n    }\n\n    /**\n     * made for bilinear, other things will need adjustments, like test if (0) is inside\n     * @param {ArrayLike<number>} v\n     * @param out\n     * @param {Matrix} after\n     */\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    boundsQuad(v: ArrayLike<number>, out: any, after?: Matrix): void\n    {\n        let minX = out[0]; let\n            minY = out[1];\n        let maxX = out[0]; let\n            maxY = out[1];\n\n        for (let i = 2; i < 8; i += 2)\n        {\n            if (minX > out[i]) minX = out[i];\n            if (maxX < out[i]) maxX = out[i];\n            if (minY > out[i + 1]) minY = out[i + 1];\n            if (maxY < out[i + 1]) maxY = out[i + 1];\n        }\n\n        p[0].set(minX, minY);\n        this.apply(p[0], p[0]);\n        p[1].set(maxX, minY);\n        this.apply(p[1], p[1]);\n        p[2].set(maxX, maxY);\n        this.apply(p[2], p[2]);\n        p[3].set(minX, maxY);\n        this.apply(p[3], p[3]);\n\n        if (after)\n        {\n            after.apply(p[0], p[0]);\n            after.apply(p[1], p[1]);\n            after.apply(p[2], p[2]);\n            after.apply(p[3], p[3]);\n            out[0] = p[0].x;\n            out[1] = p[0].y;\n            out[2] = p[1].x;\n            out[3] = p[1].y;\n            out[4] = p[2].x;\n            out[5] = p[2].y;\n            out[6] = p[3].x;\n            out[7] = p[3].y;\n        }\n        else\n        {\n            for (let i = 1; i <= 3; i++)\n            {\n                if (p[i].y < p[0].y || (p[i].y === p[0].y && p[i].x < p[0].x))\n                {\n                    const t = p[0];\n\n                    p[0] = p[i];\n                    p[i] = t;\n                }\n            }\n\n            for (let i = 1; i <= 3; i++)\n            {\n                a[i] = Math.atan2(p[i].y - p[0].y, p[i].x - p[0].x);\n            }\n            for (let i = 1; i <= 3; i++)\n            {\n                for (let j = i + 1; j <= 3; j++)\n                {\n                    if (a[i] > a[j])\n                    {\n                        const t = p[i];\n\n                        p[i] = p[j];\n                        p[j] = t;\n                        const t2 = a[i];\n\n                        a[i] = a[j];\n                        a[j] = t2;\n                    }\n                }\n            }\n\n            out[0] = p[0].x;\n            out[1] = p[0].y;\n            out[2] = p[1].x;\n            out[3] = p[1].y;\n            out[4] = p[2].x;\n            out[5] = p[2].y;\n            out[6] = p[3].x;\n            out[7] = p[3].y;\n\n            if (((p[3].x - p[2].x) * (p[1].y - p[2].y)) - ((p[1].x - p[2].x) * (p[3].y - p[2].y)) < 0)\n            {\n                // triangle!!!\n                out[4] = p[3].x;\n                out[5] = p[3].y;\n\n                return;\n            }\n        }\n    }\n\n    abstract apply(pos: IPointData, newPos: IPointData): IPointData;\n\n    // TODO: remove props\n    abstract applyInverse(pos: IPointData, newPos: IPointData): IPointData;\n}\n","/* eslint-disable no-mixed-operators */\nimport { IPoint, IPointData, Matrix, Point, Rectangle, Transform } from '@pixi/math';\nimport { Sprite } from '@pixi/sprite';\nimport { Surface } from './BaseSurface';\nimport { Dict } from '@pixi/utils';\n\nconst tempMat = new Matrix();\nconst tempRect = new Rectangle();\nconst tempPoint = new Point();\n\nexport class BilinearSurface extends Surface\n{\n    distortion = new Point();\n\n    clear(): void\n    {\n        this.distortion.set(0, 0);\n    }\n\n    apply(pos: IPointData, newPos?: IPointData): IPointData\n    {\n        newPos = newPos || new Point();\n        const d = this.distortion;\n        const m = pos.x * pos.y;\n\n        newPos.x = pos.x + d.x * m;\n        newPos.y = pos.y + d.y * m;\n\n        return newPos;\n    }\n\n    applyInverse(pos: IPointData, newPos: IPoint): IPointData\n    {\n        newPos = newPos || new Point();\n        const vx = pos.x; const\n            vy = pos.y;\n        const dx = this.distortion.x; const\n            dy = this.distortion.y;\n\n        if (dx === 0.0)\n        {\n            newPos.x = vx;\n            newPos.y = vy / (1.0 + dy * vx);\n        }\n        else\n        if (dy === 0.0)\n        {\n            newPos.y = vy;\n            newPos.x = vx / (1.0 + dx * vy);\n        }\n        else\n        {\n            const b = (vy * dx - vx * dy + 1.0) * 0.5 / dy;\n            const d = b * b + vx / dy;\n\n            if (d <= 0.00001)\n            {\n                newPos.set(NaN, NaN);\n\n                return newPos;\n            }\n            if (dy > 0.0)\n            {\n                newPos.x = -b + Math.sqrt(d);\n            }\n            else\n            {\n                newPos.x = -b - Math.sqrt(d);\n            }\n            newPos.y = (vx / newPos.x - 1.0) / dx;\n        }\n\n        return newPos;\n    }\n\n    mapSprite(sprite: Sprite, quad: Array<IPointData>, outTransform?: Transform): this\n    {\n        const tex = sprite.texture;\n\n        tempRect.x = -sprite.anchor.x * tex.orig.width;\n        tempRect.y = -sprite.anchor.y * tex.orig.height;\n        tempRect.width = tex.orig.width;\n        tempRect.height = tex.orig.height;\n\n        return this.mapQuad(tempRect, quad, outTransform || sprite.transform as Transform);\n    }\n\n    mapQuad(rect: Rectangle, quad: Array<IPointData>, outTransform: Transform): this\n    {\n        const ax = -rect.x / rect.width;\n        const ay = -rect.y / rect.height;\n\n        const ax2 = (1.0 - rect.x) / rect.width;\n        const ay2 = (1.0 - rect.y) / rect.height;\n\n        const up1x = (quad[0].x * (1.0 - ax) + quad[1].x * ax);\n        const up1y = (quad[0].y * (1.0 - ax) + quad[1].y * ax);\n        const up2x = (quad[0].x * (1.0 - ax2) + quad[1].x * ax2);\n        const up2y = (quad[0].y * (1.0 - ax2) + quad[1].y * ax2);\n\n        const down1x = (quad[3].x * (1.0 - ax) + quad[2].x * ax);\n        const down1y = (quad[3].y * (1.0 - ax) + quad[2].y * ax);\n        const down2x = (quad[3].x * (1.0 - ax2) + quad[2].x * ax2);\n        const down2y = (quad[3].y * (1.0 - ax2) + quad[2].y * ax2);\n\n        const x00 = up1x * (1.0 - ay) + down1x * ay;\n        const y00 = up1y * (1.0 - ay) + down1y * ay;\n\n        const x10 = up2x * (1.0 - ay) + down2x * ay;\n        const y10 = up2y * (1.0 - ay) + down2y * ay;\n\n        const x01 = up1x * (1.0 - ay2) + down1x * ay2;\n        const y01 = up1y * (1.0 - ay2) + down1y * ay2;\n\n        const x11 = up2x * (1.0 - ay2) + down2x * ay2;\n        const y11 = up2y * (1.0 - ay2) + down2y * ay2;\n\n        const mat = tempMat;\n\n        mat.tx = x00;\n        mat.ty = y00;\n        mat.a = x10 - x00;\n        mat.b = y10 - y00;\n        mat.c = x01 - x00;\n        mat.d = y01 - y00;\n        tempPoint.set(x11, y11);\n        mat.applyInverse(tempPoint, tempPoint);\n        this.distortion.set(tempPoint.x - 1, tempPoint.y - 1);\n\n        outTransform.setFromMatrix(mat);\n\n        return this;\n    }\n\n    fillUniforms(uniforms: Dict<any>): void\n    {\n        uniforms.distortion = uniforms.distortion || new Float32Array([0, 0, 0, 0]);\n        const ax = Math.abs(this.distortion.x);\n        const ay = Math.abs(this.distortion.y);\n\n        uniforms.distortion[0] = ax * 10000 <= ay ? 0 : this.distortion.x;\n        uniforms.distortion[1] = ay * 10000 <= ax ? 0 : this.distortion.y;\n        uniforms.distortion[2] = 1.0 / uniforms.distortion[0];\n        uniforms.distortion[3] = 1.0 / uniforms.distortion[1];\n    }\n}\n","import { IPointData, Transform } from '@pixi/math';\nimport { AbstractProjection } from '../base';\nimport { Surface } from './BaseSurface';\nimport { BilinearSurface } from './BilinearSurface';\nimport { Sprite } from '@pixi/sprite';\n\nconst fun = Transform.prototype.updateTransform;\n\nexport interface IWorldTransform {\n    apply(pos: IPointData, newPos: IPointData): IPointData;\n\n    // TODO: remove props\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData;\n}\n\nfunction transformHack(this: Transform, parentTransform: Transform): IWorldTransform\n{\n    // TODO: pixi 6.1.0 global mixin\n    const proj = (this as any).proj as ProjectionSurface;\n\n    const pp = (parentTransform as any).proj as ProjectionSurface;\n    const ta = this as any;\n\n    if (!pp)\n    {\n        fun.call(this, parentTransform);\n        proj._activeProjection = null;\n\n        return;\n    }\n\n    if (pp._surface)\n    {\n        proj._activeProjection = pp;\n        this.updateLocalTransform();\n        this.localTransform.copyTo(this.worldTransform);\n        if (ta._parentID < 0)\n        {\n            ++ta._worldID;\n        }\n\n        return;\n    }\n\n    fun.call(this, parentTransform);\n    proj._activeProjection = pp._activeProjection;\n}\n\nexport class ProjectionSurface extends AbstractProjection\n{\n    _surface: Surface = null;\n    _activeProjection: ProjectionSurface = null;\n\n    // eslint-disable-next-line accessor-pairs\n    set enabled(value: boolean)\n    {\n        if (value === this._enabled)\n        {\n            return;\n        }\n        this._enabled = value;\n        if (value)\n        {\n            this.legacy.updateTransform = transformHack;\n            (this.legacy as any)._parentID = -1;\n        }\n        else\n        {\n            this.legacy.updateTransform = Transform.prototype.updateTransform;\n            (this.legacy as any)._parentID = -1;\n        }\n    }\n\n    get surface(): Surface\n    {\n        return this._surface;\n    }\n\n    set surface(value: Surface)\n    {\n        if (this._surface === value)\n        {\n            return;\n        }\n        this._surface = value || null;\n        (this.legacy as any)._parentID = -1;\n    }\n\n    applyPartial(pos: IPointData, newPos?: IPointData): IPointData\n    {\n        if (this._activeProjection !== null)\n        {\n            newPos = this.legacy.worldTransform.apply(pos, newPos);\n\n            return this._activeProjection.surface.apply(newPos, newPos);\n        }\n        if (this._surface !== null)\n        {\n            return this.surface.apply(pos, newPos);\n        }\n\n        return this.legacy.worldTransform.apply(pos, newPos);\n    }\n\n    apply(pos: IPointData, newPos?: IPointData): IPointData\n    {\n        if (this._activeProjection !== null)\n        {\n            newPos = this.legacy.worldTransform.apply(pos, newPos);\n            this._activeProjection.surface.apply(newPos, newPos);\n\n            return this._activeProjection.legacy.worldTransform.apply(newPos, newPos);\n        }\n        if (this._surface !== null)\n        {\n            newPos = this.surface.apply(pos, newPos);\n\n            return this.legacy.worldTransform.apply(newPos, newPos);\n        }\n\n        return this.legacy.worldTransform.apply(pos, newPos);\n    }\n\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData\n    {\n        if (this._activeProjection !== null)\n        {\n            newPos = this._activeProjection.legacy.worldTransform.applyInverse(pos, newPos);\n            this._activeProjection._surface.applyInverse(newPos, newPos);\n\n            return this.legacy.worldTransform.applyInverse(newPos, newPos);\n        }\n        if (this._surface !== null)\n        {\n            newPos = this.legacy.worldTransform.applyInverse(pos, newPos);\n\n            return this._surface.applyInverse(newPos, newPos);\n        }\n\n        return this.legacy.worldTransform.applyInverse(pos, newPos);\n    }\n\n    mapBilinearSprite(sprite: Sprite, quad: Array<IPointData>): void\n    {\n        if (!(this._surface instanceof BilinearSurface))\n        {\n            this.surface = new BilinearSurface();\n        }\n        (this.surface as BilinearSurface).mapSprite(sprite, quad, this.legacy);\n    }\n\n    _currentSurfaceID = -1;\n    _currentLegacyID = -1;\n    _lastUniforms : any = null;\n\n    clear(): void\n    {\n        if (this.surface)\n        {\n            this.surface.clear();\n        }\n    }\n\n    get uniforms(): any\n    {\n        if (this._currentLegacyID === (this.legacy as any)._worldID\n            && this._currentSurfaceID === this.surface._updateID)\n        {\n            return this._lastUniforms;\n        }\n\n        this._lastUniforms = this._lastUniforms || {};\n        this._lastUniforms.translationMatrix = this.legacy.worldTransform;\n        this._surface.fillUniforms(this._lastUniforms);\n\n        return this._lastUniforms;\n    }\n}\n","import { Matrix } from '@pixi/math';\nimport { Texture, TextureMatrix } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { ProjectionSurface } from '../ProjectionSurface';\n\nexport class Sprite2s extends Sprite\n{\n    constructor(texture: Texture)\n    {\n        super(texture);\n        this.proj = new ProjectionSurface(this.transform);\n        this.pluginName = 'batch_bilinear';\n    }\n\n    proj: ProjectionSurface;\n    aTrans = new Matrix();\n\n    _calculateBounds(): void\n    {\n        this.calculateTrimmedVertices();\n        this._bounds.addQuad((this as any).vertexTrimmedData as any);\n    }\n\n    calculateVertices(): void\n    {\n        const wid = (this.transform as any)._worldID;\n        const tuid = (this._texture as any)._updateID;\n        const thisAny = this as any;\n\n        if (thisAny._transformID === wid && this._textureID === tuid)\n        {\n            return;\n        }\n\n        thisAny._transformID = wid;\n        this._textureID = tuid;\n\n        const texture = this._texture;\n        const vertexData = this.vertexData;\n        const trim = texture.trim;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        let w0: number;\n        let w1: number;\n        let h0: number;\n        let h1: number;\n\n        if (trim)\n        {\n            w1 = trim.x - (anchor._x * orig.width);\n            w0 = w1 + trim.width;\n\n            h1 = trim.y - (anchor._y * orig.height);\n            h0 = h1 + trim.height;\n        }\n        else\n        {\n            w1 = -anchor._x * orig.width;\n            w0 = w1 + orig.width;\n\n            h1 = -anchor._y * orig.height;\n            h0 = h1 + orig.height;\n        }\n\n        if (this.proj._surface)\n        {\n            vertexData[0] = w1;\n            vertexData[1] = h1;\n            vertexData[2] = w0;\n            vertexData[3] = h1;\n            vertexData[4] = w0;\n            vertexData[5] = h0;\n            vertexData[6] = w1;\n            vertexData[7] = h0;\n            this.proj._surface.boundsQuad(vertexData, vertexData);\n        }\n        else\n        {\n            const wt = this.transform.worldTransform;\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n\n            vertexData[0] = (a * w1) + (c * h1) + tx;\n            vertexData[1] = (d * h1) + (b * w1) + ty;\n            vertexData[2] = (a * w0) + (c * h1) + tx;\n            vertexData[3] = (d * h1) + (b * w0) + ty;\n            vertexData[4] = (a * w0) + (c * h0) + tx;\n            vertexData[5] = (d * h0) + (b * w0) + ty;\n            vertexData[6] = (a * w1) + (c * h0) + tx;\n            vertexData[7] = (d * h0) + (b * w1) + ty;\n            if (this.proj._activeProjection)\n            {\n                this.proj._activeProjection.surface.boundsQuad(vertexData, vertexData);\n            }\n        }\n\n        if (!texture.uvMatrix)\n        {\n            texture.uvMatrix = new TextureMatrix(texture);\n        }\n        texture.uvMatrix.update();\n\n        const aTrans = this.aTrans;\n\n        aTrans.set(orig.width, 0, 0, orig.height, w1, h1);\n        if (this.proj._surface === null)\n        {\n            aTrans.prepend(this.transform.worldTransform);\n        }\n        aTrans.invert();\n        aTrans.prepend((texture.uvMatrix as any).mapCoord);\n    }\n\n    calculateTrimmedVertices(): void\n    {\n        const wid = (this.transform as any)._worldID;\n        const tuid = (this._texture as any)._updateID;\n        const thisAny = this as any;\n\n        if (!thisAny.vertexTrimmedData)\n        {\n            thisAny.vertexTrimmedData = new Float32Array(8);\n        }\n        else if (thisAny._transformTrimmedID === wid && this._textureTrimmedID === tuid)\n        {\n            return;\n        }\n\n        thisAny._transformTrimmedID = wid;\n        this._textureTrimmedID = tuid;\n\n        // lets do some special trim code!\n        const texture = this._texture;\n        const vertexData = thisAny.vertexTrimmedData;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        // lets calculate the new untrimmed bounds..\n\n        const w1 = -anchor._x * orig.width;\n        const w0 = w1 + orig.width;\n\n        const h1 = -anchor._y * orig.height;\n        const h0 = h1 + orig.height;\n\n        // TODO: take rotations into account! form temporary bounds\n\n        if (this.proj._surface)\n        {\n            vertexData[0] = w1;\n            vertexData[1] = h1;\n            vertexData[2] = w0;\n            vertexData[3] = h1;\n            vertexData[4] = w0;\n            vertexData[5] = h0;\n            vertexData[6] = w1;\n            vertexData[7] = h0;\n            this.proj._surface.boundsQuad(vertexData, vertexData, this.transform.worldTransform);\n        }\n        else\n        {\n            const wt = this.transform.worldTransform;\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n\n            vertexData[0] = (a * w1) + (c * h1) + tx;\n            vertexData[1] = (d * h1) + (b * w1) + ty;\n            vertexData[2] = (a * w0) + (c * h1) + tx;\n            vertexData[3] = (d * h1) + (b * w0) + ty;\n            vertexData[4] = (a * w0) + (c * h0) + tx;\n            vertexData[5] = (d * h0) + (b * w0) + ty;\n            vertexData[6] = (a * w1) + (c * h0) + tx;\n            vertexData[7] = (d * h0) + (b * w1) + ty;\n            if (this.proj._activeProjection)\n            {\n                this.proj._activeProjection.surface.boundsQuad(vertexData, vertexData,\n                    this.proj._activeProjection.legacy.worldTransform);\n            }\n        }\n    }\n\n    get worldTransform(): Matrix\n    {\n        return this.proj as any;\n    }\n}\n","import { Sprite } from '@pixi/sprite';\nimport { Container } from '@pixi/display';\nimport { Matrix } from '@pixi/math';\nimport { Sprite2s } from './Sprite2s';\nimport { ProjectionSurface } from '../ProjectionSurface';\n\nSprite.prototype.convertTo2s = function spriteConvertTo2s()\n{\n    if (this.proj) return;\n    // container\n    this.pluginName = 'sprite_bilinear';\n    this.aTrans = new Matrix();\n    this.calculateVertices = Sprite2s.prototype.calculateVertices;\n    this.calculateTrimmedVertices = Sprite2s.prototype.calculateTrimmedVertices;\n    this._calculateBounds = Sprite2s.prototype._calculateBounds;\n    Container.prototype.convertTo2s.call(this);\n};\n\nContainer.prototype.convertTo2s = function convertTo2s()\n{\n    if (this.proj) return;\n    this.proj = new ProjectionSurface(this.transform);\n    Object.defineProperty(this, 'worldTransform', {\n        get()\n        {\n            return this.proj;\n        },\n        enumerable: true,\n        configurable: true\n    });\n};\n\nContainer.prototype.convertSubtreeTo2s = function convertSubtreeTo2s()\n{\n    this.convertTo2s();\n    for (let i = 0; i < this.children.length; i++)\n    {\n        this.children[i].convertSubtreeTo2s();\n    }\n};\n","import { Text, TextStyle } from '@pixi/text';\nimport { ProjectionSurface } from '../ProjectionSurface';\nimport { Matrix } from '@pixi/math';\nimport { Sprite2s } from './Sprite2s';\n\nexport class Text2s extends Text\n{\n    constructor(text?: string, style?: TextStyle, canvas?: HTMLCanvasElement)\n    {\n        super(text, style, canvas);\n        this.proj = new ProjectionSurface(this.transform);\n        this.pluginName = 'batch_bilinear';\n    }\n\n    proj: ProjectionSurface;\n\n    aTrans = new Matrix();\n\n    get worldTransform(): Matrix\n    {\n        return this.proj as any;\n    }\n}\n\n(Text2s.prototype as any).calculateVertices = Sprite2s.prototype.calculateVertices;\n(Text2s.prototype as any).calculateTrimmedVertices = Sprite2s.prototype.calculateTrimmedVertices;\n(Text2s.prototype as any)._calculateBounds = Sprite2s.prototype._calculateBounds;\n","import { Renderer } from '@pixi/core';\nimport { BatchBilinearPluginFactory } from './SpriteBilinearRenderer';\n\nexport * from './BaseSurface';\nexport * from './BilinearSurface';\nexport * from './ProjectionSurface';\nexport * from './SpriteBilinearRenderer';\n\nexport * from './sprites/convert';\nexport * from './sprites/Sprite2s';\nexport * from './sprites/Text2s';\n\nRenderer.registerPlugin('batch_bilinear', BatchBilinearPluginFactory.create({}));\n","import { ISpineClass } from './base';\nimport { Graphics } from '@pixi/graphics';\nimport { Sprite2d, Container2d, SimpleMesh2d } from '../proj2d';\nimport { Texture } from '@pixi/core';\n\nexport function applySpine2dMixin(spineClassPrototype: ISpineClass): void\n{\n    spineClassPrototype.newMesh = function newMesh(texture: Texture, vertices?: Float32Array,\n        uvs?: Float32Array, indices?: Uint16Array, drawMode?: number)\n    {\n        return new SimpleMesh2d(texture, vertices, uvs, indices, drawMode) as any;\n    };\n    spineClassPrototype.newContainer = function newMesh()\n    {\n        if (!this.proj)\n        {\n            this.convertTo2d();\n        }\n\n        return new Container2d() as any;\n    };\n    spineClassPrototype.newSprite = function newSprite(texture: Texture)\n    {\n        return new Sprite2d(texture);\n    };\n    spineClassPrototype.newGraphics = function newMesh()\n    {\n        const graphics = new Graphics();\n        // TODO: make Graphics2d\n\n        graphics.convertTo2d();\n\n        return graphics;\n    };\n    spineClassPrototype.transformHack = function transformHack()\n    {\n        return 2;\n    };\n}\n","import { ISpineClass } from './base';\nimport { Graphics } from '@pixi/graphics';\nimport { Sprite3d, Container3d, SimpleMesh3d2d } from '../proj3d';\nimport { Texture } from '@pixi/core';\n\nexport function applySpine3dMixin(spineClassPrototype: ISpineClass): void\n{\n    spineClassPrototype.newMesh = function newMesh(texture: Texture, vertices?: Float32Array,\n        uvs?: Float32Array, indices?: Uint16Array, drawMode?: number)\n    {\n        return new SimpleMesh3d2d(texture, vertices, uvs, indices, drawMode) as any;\n    };\n    spineClassPrototype.newContainer = function newMesh()\n    {\n        if (!this.proj)\n        {\n            this.convertTo3d();\n        }\n\n        return new Container3d() as any;\n    };\n    spineClassPrototype.newSprite = function newSprite(texture: Texture)\n    {\n        return new Sprite3d(texture);\n    };\n    spineClassPrototype.newGraphics = function newMesh()\n    {\n        const graphics = new Graphics();\n        // TODO: make Graphics2d\n\n        graphics.convertTo3d();\n\n        return graphics;\n    };\n    spineClassPrototype.transformHack = function transformHack()\n    {\n        return 2;\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClJA;;ACRA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AAMA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2JACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5KA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;mgBC9DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AAQA;;AAEA;AACA;AACA;AACA,4DACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtEA;AACA;AACA;AACA,sEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6FACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxNA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChwBA;AACA;;AAEA;AACA;AACA;AACA,yRACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC5JA;AACA;AACA;AACA,uKACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChDA;AACA;AACA;AACA,sFACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wIACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxEA;AACA;AACA;AACA,sEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;WC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3KA;AACA;AACA;AACA,4DACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA,sEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}