{"version":3,"file":"pixi-projection.umd.min.js","sources":["../src/proj2d/Matrix2d.ts","../src/proj2d/tiling/TilingSprite2dRenderer.ts","../src/proj2d/Projection2d.ts","../src/proj2d/tiling/TilingSprite2d.ts","../src/proj2d/sprites/convert.ts","../src/proj2d/sprites/Text2d.ts","../src/proj2d/z_masks/SpriteMaskFilter.ts","../src/proj3d/Matrix3d.ts","../src/proj3d/Projection3d.ts","../src/proj3d/sprites/convert.ts","../src/proj3d/sprites/Text3d.ts","../src/curve/BaseSurface.ts","../src/curve/BilinearSurface.ts","../src/curve/ProjectionSurface.ts"],"sourcesContent":["/* eslint-disable no-mixed-operators,max-statements-per-line */\n// according to https://jsperf.com/obj-vs-array-view-access/1 , Float64Array is the best here\nimport { IPointData, Matrix, Point } from '@pixi/math';\nimport { AFFINE } from '../base';\n\nconst mat3id = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\nexport class Matrix2d\n{\n    /**\n     * A default (identity) matrix\n     *\n     * @static\n     * @const\n     */\n    static readonly IDENTITY = new Matrix2d();\n\n    /**\n     * A temp matrix\n     *\n     * @static\n     * @const\n     */\n    static readonly TEMP_MATRIX = new Matrix2d();\n\n    /**\n     * mat3 implementation through array of 9 elements\n     */\n    mat3: Float64Array;\n\n    floatArray: Float32Array = null;\n\n    constructor(backingArray?: ArrayLike<number>)\n    {\n        this.mat3 = new Float64Array(backingArray || mat3id);\n    }\n\n    get a(): number\n    {\n        return this.mat3[0] / this.mat3[8];\n    }\n\n    set a(value: number)\n    {\n        this.mat3[0] = value * this.mat3[8];\n    }\n\n    get b(): number\n    {\n        return this.mat3[1] / this.mat3[8];\n    }\n\n    set b(value: number)\n    {\n        this.mat3[1] = value * this.mat3[8];\n    }\n\n    get c(): number\n    {\n        return this.mat3[3] / this.mat3[8];\n    }\n\n    set c(value: number)\n    {\n        this.mat3[3] = value * this.mat3[8];\n    }\n\n    get d(): number\n    {\n        return this.mat3[4] / this.mat3[8];\n    }\n\n    set d(value: number)\n    {\n        this.mat3[4] = value * this.mat3[8];\n    }\n\n    get tx(): number\n    {\n        return this.mat3[6] / this.mat3[8];\n    }\n\n    set tx(value: number)\n    {\n        this.mat3[6] = value * this.mat3[8];\n    }\n\n    get ty(): number\n    {\n        return this.mat3[7] / this.mat3[8];\n    }\n\n    set ty(value: number)\n    {\n        this.mat3[7] = value * this.mat3[8];\n    }\n\n    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] = a;\n        mat3[1] = b;\n        mat3[2] = 0;\n        mat3[3] = c;\n        mat3[4] = d;\n        mat3[5] = 0;\n        mat3[6] = tx;\n        mat3[7] = ty;\n        mat3[8] = 1;\n\n        return this;\n    }\n\n    toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.floatArray)\n        {\n            this.floatArray = new Float32Array(9);\n        }\n\n        const array = out || this.floatArray;\n        const mat3 = this.mat3;\n\n        if (transpose)\n        {\n            array[0] = mat3[0];\n            array[1] = mat3[1];\n            array[2] = mat3[2];\n            array[3] = mat3[3];\n            array[4] = mat3[4];\n            array[5] = mat3[5];\n            array[6] = mat3[6];\n            array[7] = mat3[7];\n            array[8] = mat3[8];\n        }\n        else\n        {\n            // this branch is NEVER USED in pixi\n            array[0] = mat3[0];\n            array[1] = mat3[3];\n            array[2] = mat3[6];\n            array[3] = mat3[1];\n            array[4] = mat3[4];\n            array[5] = mat3[7];\n            array[6] = mat3[2];\n            array[7] = mat3[5];\n            array[8] = mat3[8];\n        }\n\n        return array;\n    }\n\n    // TODO: remove props\n    apply(pos: IPointData, newPos: IPointData): IPointData\n    {\n        newPos = newPos || new Point();\n\n        const mat3 = this.mat3;\n        const x = pos.x;\n        const y = pos.y;\n\n        const z = 1.0 / (mat3[2] * x + mat3[5] * y + mat3[8]);\n\n        newPos.x = z * (mat3[0] * x + mat3[3] * y + mat3[6]);\n        newPos.y = z * (mat3[1] * x + mat3[4] * y + mat3[7]);\n\n        return newPos;\n    }\n\n    translate(tx: number, ty: number): this\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] += tx * mat3[2];\n        mat3[1] += ty * mat3[2];\n        mat3[3] += tx * mat3[5];\n        mat3[4] += ty * mat3[5];\n        mat3[6] += tx * mat3[8];\n        mat3[7] += ty * mat3[8];\n\n        return this;\n    }\n\n    scale(x: number, y: number): this\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] *= x;\n        mat3[1] *= y;\n        mat3[3] *= x;\n        mat3[4] *= y;\n        mat3[6] *= x;\n        mat3[7] *= y;\n\n        return this;\n    }\n\n    scaleAndTranslate(scaleX: number, scaleY: number, tx: number, ty: number): void\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] = scaleX * mat3[0] + tx * mat3[2];\n        mat3[1] = scaleY * mat3[1] + ty * mat3[2];\n        mat3[3] = scaleX * mat3[3] + tx * mat3[5];\n        mat3[4] = scaleY * mat3[4] + ty * mat3[5];\n        mat3[6] = scaleX * mat3[6] + tx * mat3[8];\n        mat3[7] = scaleY * mat3[7] + ty * mat3[8];\n    }\n\n    // TODO: remove props\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData\n    {\n        newPos = newPos || new Point();\n\n        const a = this.mat3;\n        const x = pos.x;\n        const y = pos.y;\n\n        const a00 = a[0]; const a01 = a[3]; const a02 = a[6];\n        const a10 = a[1]; const a11 = a[4]; const a12 = a[7];\n        const a20 = a[2]; const a21 = a[5]; const\n            a22 = a[8];\n\n        const newX = (a22 * a11 - a12 * a21) * x + (-a22 * a01 + a02 * a21) * y + (a12 * a01 - a02 * a11);\n        const newY = (-a22 * a10 + a12 * a20) * x + (a22 * a00 - a02 * a20) * y + (-a12 * a00 + a02 * a10);\n        const newZ = (a21 * a10 - a11 * a20) * x + (-a21 * a00 + a01 * a20) * y + (a11 * a00 - a01 * a10);\n\n        newPos.x = newX / newZ;\n        newPos.y = newY / newZ;\n\n        return newPos;\n    }\n\n    invert(): Matrix2d\n    {\n        const a = this.mat3;\n\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\n\n        const b01 = a22 * a11 - a12 * a21;\n        const b11 = -a22 * a10 + a12 * a20;\n        const b21 = a21 * a10 - a11 * a20;\n\n        // Calculate the determinant\n        let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n        if (!det)\n        {\n            return this;\n        }\n        det = 1.0 / det;\n\n        a[0] = b01 * det;\n        a[1] = (-a22 * a01 + a02 * a21) * det;\n        a[2] = (a12 * a01 - a02 * a11) * det;\n        a[3] = b11 * det;\n        a[4] = (a22 * a00 - a02 * a20) * det;\n        a[5] = (-a12 * a00 + a02 * a10) * det;\n        a[6] = b21 * det;\n        a[7] = (-a21 * a00 + a01 * a20) * det;\n        a[8] = (a11 * a00 - a01 * a10) * det;\n\n        return this;\n    }\n\n    identity(): Matrix2d\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] = 1;\n        mat3[1] = 0;\n        mat3[2] = 0;\n        mat3[3] = 0;\n        mat3[4] = 1;\n        mat3[5] = 0;\n        mat3[6] = 0;\n        mat3[7] = 0;\n        mat3[8] = 1;\n\n        return this;\n    }\n\n    clone(): Matrix2d\n    {\n        return new Matrix2d(this.mat3);\n    }\n\n    copyTo2dOr3d(matrix: Matrix2d): Matrix2d\n    {\n        const mat3 = this.mat3;\n        const ar2 = matrix.mat3;\n\n        ar2[0] = mat3[0];\n        ar2[1] = mat3[1];\n        ar2[2] = mat3[2];\n        ar2[3] = mat3[3];\n        ar2[4] = mat3[4];\n        ar2[5] = mat3[5];\n        ar2[6] = mat3[6];\n        ar2[7] = mat3[7];\n        ar2[8] = mat3[8];\n\n        return matrix;\n    }\n\n    /**\n     * legacy method, change the values of given pixi matrix\n     * @param matrix\n     * @param affine\n     * @param preserveOrientation\n     * @return matrix\n     */\n    copyTo(matrix: Matrix, affine?: AFFINE, preserveOrientation?: boolean): Matrix\n    {\n        const mat3 = this.mat3;\n        const d = 1.0 / mat3[8];\n        const tx = mat3[6] * d; const\n            ty = mat3[7] * d;\n\n        matrix.a = (mat3[0] - mat3[2] * tx) * d;\n        matrix.b = (mat3[1] - mat3[2] * ty) * d;\n        matrix.c = (mat3[3] - mat3[5] * tx) * d;\n        matrix.d = (mat3[4] - mat3[5] * ty) * d;\n        matrix.tx = tx;\n        matrix.ty = ty;\n\n        if (affine >= 2)\n        {\n            let D = matrix.a * matrix.d - matrix.b * matrix.c;\n\n            if (!preserveOrientation)\n            {\n                D = Math.abs(D);\n            }\n            if (affine === AFFINE.POINT)\n            {\n                if (D > 0)\n                {\n                    D = 1;\n                }\n                else D = -1;\n                matrix.a = D;\n                matrix.b = 0;\n                matrix.c = 0;\n                matrix.d = D;\n            }\n            else if (affine === AFFINE.AXIS_X)\n            {\n                D /= Math.sqrt(matrix.b * matrix.b + matrix.d * matrix.d);\n                matrix.c = 0;\n                matrix.d = D;\n            }\n            else if (affine === AFFINE.AXIS_Y)\n            {\n                D /= Math.sqrt(matrix.a * matrix.a + matrix.c * matrix.c);\n                matrix.a = D;\n                matrix.c = 0;\n            }\n            else if (affine === AFFINE.AXIS_XR)\n            {\n                matrix.a = matrix.d * D;\n                matrix.c = -matrix.b * D;\n            }\n        }\n\n        return matrix;\n    }\n\n    /**\n     * legacy method, change the values of given pixi matrix\n     * @param matrix\n     * @return\n     */\n    copyFrom(matrix: Matrix): this\n    {\n        const mat3 = this.mat3;\n\n        mat3[0] = matrix.a;\n        mat3[1] = matrix.b;\n        mat3[2] = 0;\n        mat3[3] = matrix.c;\n        mat3[4] = matrix.d;\n        mat3[5] = 0;\n        mat3[6] = matrix.tx;\n        mat3[7] = matrix.ty;\n        mat3[8] = 1.0;\n\n        return this;\n    }\n\n    setToMultLegacy(pt: Matrix, lt: Matrix2d): this\n    {\n        const out = this.mat3;\n        const b = lt.mat3;\n\n        const a00 = pt.a; const a01 = pt.b;\n        const a10 = pt.c; const a11 = pt.d;\n        const a20 = pt.tx; const a21 = pt.ty;\n\n        const b00 = b[0]; const b01 = b[1]; const b02 = b[2];\n        const b10 = b[3]; const b11 = b[4]; const b12 = b[5];\n        const b20 = b[6]; const b21 = b[7]; const\n            b22 = b[8];\n\n        out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n        out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n        out[2] = b02;\n\n        out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n        out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n        out[5] = b12;\n\n        out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n        out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n        out[8] = b22;\n\n        return this;\n    }\n\n    setToMultLegacy2(pt: Matrix2d, lt: Matrix): this\n    {\n        const out = this.mat3;\n        const a = pt.mat3;\n\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\n\n        const b00 = lt.a; const b01 = lt.b;\n        const b10 = lt.c; const b11 = lt.d;\n        const b20 = lt.tx; const\n            b21 = lt.ty;\n\n        out[0] = b00 * a00 + b01 * a10;\n        out[1] = b00 * a01 + b01 * a11;\n        out[2] = b00 * a02 + b01 * a12;\n\n        out[3] = b10 * a00 + b11 * a10;\n        out[4] = b10 * a01 + b11 * a11;\n        out[5] = b10 * a02 + b11 * a12;\n\n        out[6] = b20 * a00 + b21 * a10 + a20;\n        out[7] = b20 * a01 + b21 * a11 + a21;\n        out[8] = b20 * a02 + b21 * a12 + a22;\n\n        return this;\n    }\n\n    // that's transform multiplication we use\n    setToMult(pt: Matrix2d, lt: Matrix2d): this\n    {\n        const out = this.mat3;\n        const a = pt.mat3; const\n            b = lt.mat3;\n\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\n\n        const b00 = b[0]; const b01 = b[1]; const b02 = b[2];\n        const b10 = b[3]; const b11 = b[4]; const b12 = b[5];\n        const b20 = b[6]; const b21 = b[7]; const\n            b22 = b[8];\n\n        out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n        out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n        out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n        out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n        out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n        out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n        out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n        out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n        out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n\n        return this;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    prepend(lt: any): this\n    {\n        if (lt.mat3)\n        {\n            return this.setToMult(lt, this);\n        }\n\n        return this.setToMultLegacy(lt, this);\n    }\n}\n","import { Matrix2d } from '../Matrix2d';\nimport { ObjectRenderer, QuadUv, Renderer, Shader } from '@pixi/core';\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\nimport { correctBlendMode, premultiplyTintToRgba } from '@pixi/utils';\n\nconst shaderVert\n    = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec3 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\n\nvTextureCoord = uTransform * vec3(aTextureCoord, 1.0);\n}\n`;\nconst shaderFrag = `\nvarying vec3 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\nvec2 coord = mod(vTextureCoord.xy / vTextureCoord.z - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\ncoord = (uMapCoord * vec3(coord, 1.0)).xy;\ncoord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\nvec4 sample = texture2D(uSampler, coord);\ngl_FragColor = sample * uColor;\n}\n`;\nconst shaderSimpleFrag = `\nvarying vec3 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\nvec4 sample = texture2D(uSampler, vTextureCoord.xy / vTextureCoord.z);\ngl_FragColor = sample * uColor;\n}\n`;\n\n// changed\nconst tempMat = new Matrix2d();\n\nexport class TilingSprite2dRenderer extends ObjectRenderer\n{\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        const uniforms = { globals: this.renderer.globalUniforms };\n\n        this.shader = Shader.from(shaderVert, shaderFrag, uniforms);\n\n        this.simpleShader = Shader.from(shaderVert, shaderSimpleFrag, uniforms);\n    }\n\n    shader: Shader;\n    simpleShader: Shader;\n    quad = new QuadUv();\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    render(ts: any): void\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        if (ts.uvRespectAnchor)\n        {\n            vertices = quad.uvs;\n\n            vertices[0] = vertices[6] = -ts.anchor.x;\n            vertices[1] = vertices[3] = -ts.anchor.y;\n\n            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n        }\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const lt = ts.tileProj.world;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[(renderer as any).CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        // changed\n        tempMat.identity();\n        tempMat.scale(tex.width, tex.height);\n        tempMat.prepend(lt);\n        tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha,\n            shader.uniforms.uColor, baseTex.premultiplyAlpha);\n        shader.uniforms.translationMatrix = ts.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader, false);\n        renderer.geometry.bind(quad as any, undefined);// , renderer.shader.getGLShader());\n\n        renderer.state.setBlendMode(correctBlendMode(ts.blendMode, baseTex.premultiplyAlpha));\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES, 6, 0);\n    }\n}\n","/* eslint-disable no-mixed-operators */\nimport { Matrix2d } from './Matrix2d';\nimport { IPointData, Matrix, ObservablePoint, Point, Rectangle, Transform } from '@pixi/math';\nimport { Sprite } from '@pixi/sprite';\nimport { LinearProjection } from '../base';\nimport { getIntersectionFactor } from '../utils';\n\nconst t0 = new Point();\nconst tt = [new Point(), new Point(), new Point(), new Point()];\nconst tempRect = new Rectangle();\nconst tempMat = new Matrix2d();\n\nexport class Projection2d extends LinearProjection<Matrix2d>\n{\n    constructor(legacy: Transform, enable?: boolean)\n    {\n        super(legacy, enable);\n        this.local = new Matrix2d();\n        this.world = new Matrix2d();\n    }\n\n    matrix = new Matrix2d();\n    pivot = new ObservablePoint(this.onChange, this, 0, 0);\n\n    reverseLocalOrder = false;\n\n    onChange(): void\n    {\n        const pivot = this.pivot;\n        const mat3 = this.matrix.mat3;\n\n        mat3[6] = -(pivot._x * mat3[0] + pivot._y * mat3[3]);\n        mat3[7] = -(pivot._x * mat3[1] + pivot._y * mat3[4]);\n\n        this._projID++;\n    }\n\n    setAxisX(p: IPointData, factor = 1): void\n    {\n        const x = p.x; const\n            y = p.y;\n        const d = Math.sqrt(x * x + y * y);\n        const mat3 = this.matrix.mat3;\n\n        mat3[0] = x / d;\n        mat3[1] = y / d;\n        mat3[2] = factor / d;\n\n        this.onChange();\n    }\n\n    setAxisY(p: IPointData, factor = 1): void\n    {\n        const x = p.x; const\n            y = p.y;\n        const d = Math.sqrt(x * x + y * y);\n        const mat3 = this.matrix.mat3;\n\n        mat3[3] = x / d;\n        mat3[4] = y / d;\n        mat3[5] = factor / d;\n        this.onChange();\n    }\n\n    mapSprite(sprite: Sprite, quad: Array<IPointData>): void\n    {\n        const tex = sprite.texture;\n\n        tempRect.x = -sprite.anchor.x * tex.orig.width;\n        tempRect.y = -sprite.anchor.y * tex.orig.height;\n        tempRect.width = tex.orig.width;\n        tempRect.height = tex.orig.height;\n\n        this.mapQuad(tempRect, quad);\n    }\n\n    mapQuad(rect: Rectangle, p: Array<IPointData>): void\n    {\n        // utils.getPositionFromQuad(p, anchor, t0);\n        tt[0].set(rect.x, rect.y);\n        tt[1].set(rect.x + rect.width, rect.y);\n        tt[2].set(rect.x + rect.width, rect.y + rect.height);\n        tt[3].set(rect.x, rect.y + rect.height);\n\n        let k1 = 1; let k2 = 2;\n        let k3 = 3;\n        const f = getIntersectionFactor(p[0], p[2], p[1], p[3], t0);\n\n        if (f !== 0)\n        {\n            k1 = 1;\n            k2 = 3;\n            k3 = 2;\n        }\n        else\n        {\n            return;\n            /* f = utils.getIntersectionFactor(p[0], p[1], p[2], p[3], t0);\n            if (f > 0) {\n                k1 = 2;\n                k2 = 3;\n                k3 = 1;\n            } else {\n                f = utils.getIntersectionFactor(p[0], p[3], p[1], p[2], t0);\n                if (f > 0) {\n                    // cant find it :(\n                    k1 = 1;\n                    k2 = 2;\n                    k3 = 3;\n                } else {\n                    return;\n                }\n            }*/\n        }\n        const d0 = Math.sqrt((p[0].x - t0.x) * (p[0].x - t0.x) + (p[0].y - t0.y) * (p[0].y - t0.y));\n        const d1 = Math.sqrt((p[k1].x - t0.x) * (p[k1].x - t0.x) + (p[k1].y - t0.y) * (p[k1].y - t0.y));\n        const d2 = Math.sqrt((p[k2].x - t0.x) * (p[k2].x - t0.x) + (p[k2].y - t0.y) * (p[k2].y - t0.y));\n        const d3 = Math.sqrt((p[k3].x - t0.x) * (p[k3].x - t0.x) + (p[k3].y - t0.y) * (p[k3].y - t0.y));\n\n        const q0 = (d0 + d3) / d3;\n        const q1 = (d1 + d2) / d2;\n        const q2 = (d1 + d2) / d1;\n\n        let mat3 = this.matrix.mat3;\n\n        mat3[0] = tt[0].x * q0;\n        mat3[1] = tt[0].y * q0;\n        mat3[2] = q0;\n        mat3[3] = tt[k1].x * q1;\n        mat3[4] = tt[k1].y * q1;\n        mat3[5] = q1;\n        mat3[6] = tt[k2].x * q2;\n        mat3[7] = tt[k2].y * q2;\n        mat3[8] = q2;\n        this.matrix.invert();\n\n        mat3 = tempMat.mat3;\n        mat3[0] = p[0].x;\n        mat3[1] = p[0].y;\n        mat3[2] = 1;\n        mat3[3] = p[k1].x;\n        mat3[4] = p[k1].y;\n        mat3[5] = 1;\n        mat3[6] = p[k2].x;\n        mat3[7] = p[k2].y;\n        mat3[8] = 1;\n\n        this.matrix.setToMult(tempMat, this.matrix);\n        this._projID++;\n    }\n\n    updateLocalTransform(lt: Matrix): void\n    {\n        if (this._projID !== 0)\n        {\n            if (this.reverseLocalOrder)\n            {\n                // tilingSprite inside order\n                this.local.setToMultLegacy2(this.matrix, lt);\n            }\n            else\n            {\n                // good order\n                this.local.setToMultLegacy(lt, this.matrix);\n            }\n        }\n        else\n        {\n            this.local.copyFrom(lt);\n        }\n    }\n\n    clear(): void\n    {\n        super.clear();\n        this.matrix.identity();\n        this.pivot.set(0, 0);\n    }\n}\n","import { Renderer, Texture } from '@pixi/core';\nimport { IPointData, Matrix, Point, Transform } from '@pixi/math';\nimport { Projection2d } from '../Projection2d';\nimport { DisplayObject } from '@pixi/display';\nimport { TRANSFORM_STEP } from '../../base';\nimport { container2dToLocal } from '../Container2d';\nimport { TilingSprite } from '@pixi/sprite-tiling';\n\nconst tempTransform = new Transform();\n\nexport class TilingSprite2d extends TilingSprite\n{\n    constructor(texture: Texture, width: number, height: number)\n    {\n        super(texture, width, height);\n\n        this.tileProj = new Projection2d(this.tileTransform);\n        this.tileProj.reverseLocalOrder = true;\n        this.proj = new Projection2d(this.transform);\n\n        this.pluginName = 'tilingSprite2d';\n        this.uvRespectAnchor = true;\n    }\n\n    tileProj: Projection2d;\n    proj: Projection2d;\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): P\n    {\n        return container2dToLocal.call(this, position, from, point, skipUpdate, step);\n    }\n\n    _render(renderer: Renderer): void\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        // changed\n        this.tileTransform.updateTransform(tempTransform);\n        this.uvMatrix.update();\n\n        renderer.batch.setObjectRenderer((renderer.plugins as any)[this.pluginName]);\n        (renderer.plugins as any)[this.pluginName].render(this);\n    }\n}\n","import { Projection2d } from '../Projection2d';\nimport { Container2d, container2dWorldTransform } from '../Container2d';\nimport { TilingSprite } from '@pixi/sprite-tiling';\nimport { Program } from '@pixi/core';\nimport { MeshMaterial } from '@pixi/mesh';\nimport { Mesh2d } from '../mesh/Mesh2d';\nimport { SimpleMesh, SimpleRope } from '@pixi/mesh-extras';\nimport { Container } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { Sprite2d } from './Sprite2d';\nimport { TilingSprite2d } from '../tiling/TilingSprite2d';\n\nfunction convertTo2d()\n{\n    if (this.proj) return;\n    this.proj = new Projection2d(this.transform);\n    this.toLocal = Container2d.prototype.toLocal;\n    Object.defineProperty(this, 'worldTransform', {\n        get: container2dWorldTransform,\n        enumerable: true,\n        configurable: true\n    });\n}\n\nContainer.prototype.convertTo2d = convertTo2d;\n\nSprite.prototype.convertTo2d = function spriteConvertTo2d()\n{\n    if (this.proj) return;\n    this.calculateVertices = Sprite2d.prototype.calculateVertices;\n    this.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\n    this._calculateBounds = Sprite2d.prototype._calculateBounds;\n    this.pluginName = 'batch2d';\n    convertTo2d.call(this);\n};\n\nContainer.prototype.convertSubtreeTo2d = function convertSubtreeTo2d()\n{\n    this.convertTo2d();\n    for (let i = 0; i < this.children.length; i++)\n    {\n        this.children[i].convertSubtreeTo2d();\n    }\n};\n\nSimpleMesh.prototype.convertTo2d\n    = SimpleRope.prototype.convertTo2d\n        = function meshConvertTo2d()\n        {\n            if (this.proj) return;\n            this.calculateVertices = Mesh2d.prototype.calculateVertices;\n            this._renderDefault = Mesh2d.prototype._renderDefault;\n            if (this.material.pluginName !== 'batch2d')\n            {\n                this.material = new MeshMaterial(this.material.texture, {\n                    program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\n                    pluginName: 'batch2d'\n                });\n            }\n            convertTo2d.call(this);\n        };\n\nTilingSprite.prototype.convertTo2d = function tilingConvertTo2d()\n{\n    if (this.proj) return;\n\n    this.tileProj = new Projection2d(this.tileTransform);\n    this.tileProj.reverseLocalOrder = true;\n    this.uvRespectAnchor = true;\n\n    this.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\n    this._calculateBounds = Sprite2d.prototype._calculateBounds;\n    this._render = TilingSprite2d.prototype._render;\n\n    this.pluginName = 'tilingSprite2d';\n    convertTo2d.call(this);\n};\n","import { Text, TextStyle } from '@pixi/text';\nimport { Projection2d } from '../Projection2d';\nimport { Sprite2d } from './Sprite2d';\nimport { Matrix } from '@pixi/math';\n\nexport class Text2d extends Text\n{\n    constructor(text?: string, style?: TextStyle, canvas?: HTMLCanvasElement)\n    {\n        super(text, style, canvas);\n        this.proj = new Projection2d(this.transform);\n        this.pluginName = 'batch2d';\n    }\n\n    proj: Projection2d;\n    vertexData2d: Float32Array = null;\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n}\n\nText2d.prototype.calculateVertices = Sprite2d.prototype.calculateVertices;\nText2d.prototype.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\n(Text2d.prototype as any)._calculateBounds = Sprite2d.prototype._calculateBounds;\n","import { Sprite } from '@pixi/sprite';\nimport { Matrix2d } from '../Matrix2d';\nimport { Filter, FilterSystem, RenderTexture, TextureMatrix } from '@pixi/core';\nimport { Projection2d } from '../Projection2d';\n\nconst spriteMaskVert = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec3 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\nvTextureCoord = aTextureCoord;\nvMaskCoord = otherMatrix * vec3( aTextureCoord, 1.0);\n}\n`;\nconst spriteMaskFrag = `\nvarying vec3 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\nvec2 uv = vMaskCoord.xy / vMaskCoord.z;\n\nfloat clip = step(3.5,\n    step(maskClamp.x, uv.x) +\n    step(maskClamp.y, uv.y) +\n    step(uv.x, maskClamp.z) +\n    step(uv.y, maskClamp.w));\n\nvec4 original = texture2D(uSampler, vTextureCoord);\nvec4 masky = texture2D(mask, uv);\n\noriginal *= (masky.r * masky.a * alpha * clip);\n\ngl_FragColor = original;\n}\n`;\n\nconst tempMat = new Matrix2d();\n\nexport class SpriteMaskFilter2d extends Filter\n{\n    constructor(sprite: Sprite)\n    {\n        super(spriteMaskVert, spriteMaskFrag);\n\n        sprite.renderable = false;\n\n        this.maskSprite = sprite;\n    }\n\n    maskSprite: Sprite;\n    maskMatrix = new Matrix2d();\n\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture,\n        clearMode?: number): void\n    {\n        const maskSprite = this.maskSprite;\n        const tex = this.maskSprite.texture;\n\n        if (!tex.valid)\n        {\n            return;\n        }\n        if (!tex.uvMatrix)\n        {\n            // margin = 0.0, let it bleed a bit, shader code becomes easier\n            // assuming that atlas textures were made with 1-pixel padding\n            tex.uvMatrix = new TextureMatrix(tex, 0.0);\n        }\n        tex.uvMatrix.update();\n\n        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0.0 : 1.0;\n        this.uniforms.mask = maskSprite.texture;\n        this.uniforms.otherMatrix = SpriteMaskFilter2d.calculateSpriteMatrix(input, this.maskMatrix, maskSprite)\n            .prepend(tex.uvMatrix.mapCoord);\n        this.uniforms.alpha = maskSprite.worldAlpha;\n        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    static calculateSpriteMatrix(input: RenderTexture, mappedMatrix: Matrix2d, sprite: Sprite): Matrix2d\n    {\n        const proj = (sprite as any).proj as Projection2d;\n\n        const filterArea = (input as any).filterFrame;\n\n        // eslint-disable-next-line max-len\n        const worldTransform = proj && !proj._affine ? proj.world.copyTo2dOr3d(tempMat) : tempMat.copyFrom(sprite.transform.worldTransform);\n        const texture = sprite.texture.orig;\n\n        mappedMatrix.set(input.width, 0, 0, input.height, filterArea.x, filterArea.y);\n        worldTransform.invert();\n        mappedMatrix.setToMult(worldTransform, mappedMatrix);\n        mappedMatrix.scaleAndTranslate(1.0 / texture.width, 1.0 / texture.height,\n            sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n}\n","/* eslint-disable no-mixed-operators,max-statements-per-line */\n// according to https://jsperf.com/obj-vs-array-view-access/1 , Float64Array is the best here\n\nimport { IPointData, Matrix, Point } from '@pixi/math';\nimport { Matrix2d } from '../proj2d';\nimport { Point3d } from './Point3d';\nimport { AFFINE } from '../base';\n\nconst mat4id = [1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1];\n\nexport class Matrix3d\n{\n    /**\n     * A default (identity) matrix\n     *\n     * @static\n     * @const\n     */\n    static readonly IDENTITY = new Matrix3d();\n\n    /**\n     * A temp matrix\n     *\n     * @static\n     * @const\n     */\n    static readonly TEMP_MATRIX = new Matrix3d();\n\n    /**\n     * mat4 implementation through array of 16 elements\n     */\n    mat4: Float64Array;\n\n    floatArray: Float32Array = null;\n\n    _dirtyId = 0;\n    _updateId = -1;\n    _mat4inv: Float64Array = null;\n    cacheInverse = false;\n\n    constructor(backingArray?: ArrayLike<number>)\n    {\n        this.mat4 = new Float64Array(backingArray || mat4id);\n    }\n\n    get a(): number\n    {\n        return this.mat4[0] / this.mat4[15];\n    }\n\n    set a(value: number)\n    {\n        this.mat4[0] = value * this.mat4[15];\n    }\n\n    get b(): number\n    {\n        return this.mat4[1] / this.mat4[15];\n    }\n\n    set b(value: number)\n    {\n        this.mat4[1] = value * this.mat4[15];\n    }\n\n    get c(): number\n    {\n        return this.mat4[4] / this.mat4[15];\n    }\n\n    set c(value: number)\n    {\n        this.mat4[4] = value * this.mat4[15];\n    }\n\n    get d(): number\n    {\n        return this.mat4[5] / this.mat4[15];\n    }\n\n    set d(value: number)\n    {\n        this.mat4[5] = value * this.mat4[15];\n    }\n\n    get tx(): number\n    {\n        return this.mat4[12] / this.mat4[15];\n    }\n\n    set tx(value: number)\n    {\n        this.mat4[12] = value * this.mat4[15];\n    }\n\n    get ty(): number\n    {\n        return this.mat4[13] / this.mat4[15];\n    }\n\n    set ty(value: number)\n    {\n        this.mat4[13] = value * this.mat4[15];\n    }\n\n    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        const mat4 = this.mat4;\n\n        mat4[0] = a;\n        mat4[1] = b;\n        mat4[2] = 0;\n        mat4[3] = 0;\n        mat4[4] = c;\n        mat4[5] = d;\n        mat4[6] = 0;\n        mat4[7] = 0;\n        mat4[8] = 0;\n        mat4[9] = 0;\n        mat4[10] = 1;\n        mat4[11] = 0;\n        mat4[12] = tx;\n        mat4[13] = ty;\n        mat4[14] = 0;\n        mat4[15] = 1;\n\n        return this;\n    }\n\n    toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.floatArray)\n        {\n            this.floatArray = new Float32Array(9);\n        }\n\n        const array = out || this.floatArray;\n        const mat3 = this.mat4;\n\n        if (transpose)\n        {\n            array[0] = mat3[0];\n            array[1] = mat3[1];\n            array[2] = mat3[3];\n            array[3] = mat3[4];\n            array[4] = mat3[5];\n            array[5] = mat3[7];\n            array[6] = mat3[12];\n            array[7] = mat3[13];\n            array[8] = mat3[15];\n        }\n        else\n        {\n            // this branch is NEVER USED in pixi\n            array[0] = mat3[0];\n            array[1] = mat3[4];\n            array[2] = mat3[12];\n            array[3] = mat3[2];\n            array[4] = mat3[6];\n            array[5] = mat3[13];\n            array[6] = mat3[3];\n            array[7] = mat3[7];\n            array[8] = mat3[15];\n        }\n\n        return array;\n    }\n\n    setToTranslation(tx: number, ty: number, tz: number): void\n    {\n        const mat4 = this.mat4;\n\n        mat4[0] = 1;\n        mat4[1] = 0;\n        mat4[2] = 0;\n        mat4[3] = 0;\n\n        mat4[4] = 0;\n        mat4[5] = 1;\n        mat4[6] = 0;\n        mat4[7] = 0;\n\n        mat4[8] = 0;\n        mat4[9] = 0;\n        mat4[10] = 1;\n        mat4[11] = 0;\n\n        mat4[12] = tx;\n        mat4[13] = ty;\n        mat4[14] = tz;\n        mat4[15] = 1;\n    }\n\n    // eslint-disable-next-line max-len\n    setToRotationTranslationScale(quat: Float64Array, tx: number, ty: number, tz: number, sx: number, sy: number, sz: number): Float64Array\n    {\n        const out = this.mat4;\n\n        const x = quat[0]; const y = quat[1]; const z = quat[2]; const\n            w = quat[3];\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        out[0] = (1 - (yy + zz)) * sx;\n        out[1] = (xy + wz) * sx;\n        out[2] = (xz - wy) * sx;\n        out[3] = 0;\n        out[4] = (xy - wz) * sy;\n        out[5] = (1 - (xx + zz)) * sy;\n        out[6] = (yz + wx) * sy;\n        out[7] = 0;\n        out[8] = (xz + wy) * sz;\n        out[9] = (yz - wx) * sz;\n        out[10] = (1 - (xx + yy)) * sz;\n        out[11] = 0;\n        out[12] = tx;\n        out[13] = ty;\n        out[14] = tz;\n        out[15] = 1;\n\n        return out;\n    }\n\n    apply(pos: IPointData, newPos: IPointData): IPointData\n    {\n        newPos = newPos || new Point3d();\n\n        const mat4 = this.mat4;\n        const x = pos.x;\n        const y = pos.y;\n        // TODO: pixi 6.1.0 global mixin\n        const z = (pos as any).z || 0;\n\n        // TODO: apply for 2d point\n\n        const w = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\n\n        newPos.x = w * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\n        newPos.y = w * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\n        // TODO: pixi 6.1.0 global mixin\n        (newPos as any).z = w * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\n\n        return newPos;\n    }\n\n    translate(tx: number, ty: number, tz: number): this\n    {\n        const a = this.mat4;\n\n        a[12] = a[0] * tx + a[4] * ty + a[8] * tz + a[12];\n        a[13] = a[1] * tx + a[5] * ty + a[9] * tz + a[13];\n        a[14] = a[2] * tx + a[6] * ty + a[10] * tz + a[14];\n        a[15] = a[3] * tx + a[7] * ty + a[11] * tz + a[15];\n\n        return this;\n    }\n\n    scale(x: number, y: number, z?: number): this\n    {\n        const mat4 = this.mat4;\n\n        mat4[0] *= x;\n        mat4[1] *= x;\n        mat4[2] *= x;\n        mat4[3] *= x;\n\n        mat4[4] *= y;\n        mat4[5] *= y;\n        mat4[6] *= y;\n        mat4[7] *= y;\n\n        if (z !== undefined)\n        {\n            mat4[8] *= z;\n            mat4[9] *= z;\n            mat4[10] *= z;\n            mat4[11] *= z;\n        }\n\n        return this;\n    }\n\n    scaleAndTranslate(scaleX: number, scaleY: number, scaleZ: number, tx: number, ty: number, tz: number): void\n    {\n        const mat4 = this.mat4;\n\n        mat4[0] = scaleX * mat4[0] + tx * mat4[3];\n        mat4[1] = scaleY * mat4[1] + ty * mat4[3];\n        mat4[2] = scaleZ * mat4[2] + tz * mat4[3];\n\n        mat4[4] = scaleX * mat4[4] + tx * mat4[7];\n        mat4[5] = scaleY * mat4[5] + ty * mat4[7];\n        mat4[6] = scaleZ * mat4[6] + tz * mat4[7];\n\n        mat4[8] = scaleX * mat4[8] + tx * mat4[11];\n        mat4[9] = scaleY * mat4[9] + ty * mat4[11];\n        mat4[10] = scaleZ * mat4[10] + tz * mat4[11];\n\n        mat4[12] = scaleX * mat4[12] + tx * mat4[15];\n        mat4[13] = scaleY * mat4[13] + ty * mat4[15];\n        mat4[14] = scaleZ * mat4[14] + tz * mat4[15];\n    }\n\n    // TODO: remove props\n    applyInverse<P extends IPointData = Point>(pos: IPointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point3d()) as any;\n        if (!this._mat4inv)\n        {\n            this._mat4inv = new Float64Array(16);\n        }\n\n        const mat4 = this._mat4inv;\n        const a = this.mat4;\n        const x = pos.x;\n        const y = pos.y;\n        // TODO: pixi 6.1.0 global mixin\n        let z = (pos as any).z || 0;\n\n        if (!this.cacheInverse || this._updateId !== this._dirtyId)\n        {\n            this._updateId = this._dirtyId;\n            Matrix3d.glMatrixMat4Invert(mat4, a);\n        }\n\n        const w1 = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\n        const x1 = w1 * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\n        const y1 = w1 * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\n        const z1 = w1 * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\n\n        z += 1.0;\n\n        const w2 = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\n        const x2 = w2 * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\n        const y2 = w2 * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\n        const z2 = w2 * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\n\n        if (Math.abs(z1 - z2) < 1e-10)\n        {\n            (newPos as any).set(NaN, NaN, 0);\n        }\n\n        const alpha = (0 - z1) / (z2 - z1);\n\n        (newPos as any).set((x2 - x1) * alpha + x1, (y2 - y1) * alpha + y1, 0.0);\n\n        return newPos;\n    }\n\n    invert(): Matrix3d\n    {\n        Matrix3d.glMatrixMat4Invert(this.mat4, this.mat4);\n\n        return this;\n    }\n\n    invertCopyTo(matrix: Matrix3d): void\n    {\n        if (!this._mat4inv)\n        {\n            this._mat4inv = new Float64Array(16);\n        }\n\n        const mat4 = this._mat4inv;\n        const a = this.mat4;\n\n        if (!this.cacheInverse || this._updateId !== this._dirtyId)\n        {\n            this._updateId = this._dirtyId;\n            Matrix3d.glMatrixMat4Invert(mat4, a);\n        }\n\n        matrix.mat4.set(mat4);\n    }\n\n    identity(): Matrix3d\n    {\n        const mat3 = this.mat4;\n\n        mat3[0] = 1;\n        mat3[1] = 0;\n        mat3[2] = 0;\n        mat3[3] = 0;\n\n        mat3[4] = 0;\n        mat3[5] = 1;\n        mat3[6] = 0;\n        mat3[7] = 0;\n\n        mat3[8] = 0;\n        mat3[9] = 0;\n        mat3[10] = 1;\n        mat3[11] = 0;\n\n        mat3[12] = 0;\n        mat3[13] = 0;\n        mat3[14] = 0;\n        mat3[15] = 1;\n\n        return this;\n    }\n\n    clone(): Matrix3d\n    {\n        return new Matrix3d(this.mat4);\n    }\n\n    copyTo3d(matrix: Matrix3d): Matrix3d\n    {\n        const mat3 = this.mat4;\n        const ar2 = matrix.mat4;\n\n        ar2[0] = mat3[0];\n        ar2[1] = mat3[1];\n        ar2[2] = mat3[2];\n        ar2[3] = mat3[3];\n        ar2[4] = mat3[4];\n        ar2[5] = mat3[5];\n        ar2[6] = mat3[6];\n        ar2[7] = mat3[7];\n        ar2[8] = mat3[8];\n\n        return matrix;\n    }\n\n    copyTo2d(matrix: Matrix2d): Matrix2d\n    {\n        const mat3 = this.mat4;\n        const ar2 = matrix.mat3;\n\n        ar2[0] = mat3[0];\n        ar2[1] = mat3[1];\n        ar2[2] = mat3[3];\n        ar2[3] = mat3[4];\n        ar2[4] = mat3[5];\n        ar2[5] = mat3[7];\n        ar2[6] = mat3[12];\n        ar2[7] = mat3[13];\n        ar2[8] = mat3[15];\n\n        return matrix;\n    }\n\n    copyTo2dOr3d<P extends Matrix2d | Matrix3d>(matrix: P): P\n    {\n        if (matrix instanceof Matrix2d)\n        {\n            return this.copyTo2d(matrix) as any;\n        }\n\n        return this.copyTo3d(matrix as any) as any;\n    }\n\n    /**\n     * legacy method, change the values of given pixi matrix\n     * @param matrix\n     * @param affine\n     * @param preserveOrientation\n     * @return matrix\n     */\n    copyTo(matrix: Matrix, affine?: AFFINE, preserveOrientation?: boolean): Matrix\n    {\n        const mat3 = this.mat4;\n        const d = 1.0 / mat3[15];\n        const tx = mat3[12] * d; const\n            ty = mat3[13] * d;\n\n        matrix.a = (mat3[0] - mat3[3] * tx) * d;\n        matrix.b = (mat3[1] - mat3[3] * ty) * d;\n        matrix.c = (mat3[4] - mat3[7] * tx) * d;\n        matrix.d = (mat3[5] - mat3[7] * ty) * d;\n        matrix.tx = tx;\n        matrix.ty = ty;\n\n        if (affine >= 2)\n        {\n            let D = matrix.a * matrix.d - matrix.b * matrix.c;\n\n            if (!preserveOrientation)\n            {\n                D = Math.abs(D);\n            }\n            if (affine === AFFINE.POINT)\n            {\n                if (D > 0)\n                {\n                    D = 1;\n                }\n                else D = -1;\n                matrix.a = D;\n                matrix.b = 0;\n                matrix.c = 0;\n                matrix.d = D;\n            }\n            else if (affine === AFFINE.AXIS_X)\n            {\n                D /= Math.sqrt(matrix.b * matrix.b + matrix.d * matrix.d);\n                matrix.c = 0;\n                matrix.d = D;\n            }\n            else if (affine === AFFINE.AXIS_Y)\n            {\n                D /= Math.sqrt(matrix.a * matrix.a + matrix.c * matrix.c);\n                matrix.a = D;\n                matrix.c = 0;\n            }\n        }\n\n        return matrix;\n    }\n\n    /**\n     * legacy method, change the values of given pixi matrix\n     * @param matrix\n     * @return\n     */\n    copyFrom(matrix: Matrix): this\n    {\n        const mat3 = this.mat4;\n\n        mat3[0] = matrix.a;\n        mat3[1] = matrix.b;\n        mat3[2] = 0;\n        mat3[3] = 0;\n\n        mat3[4] = matrix.c;\n        mat3[5] = matrix.d;\n        mat3[6] = 0;\n        mat3[7] = 0;\n\n        mat3[8] = 0;\n        mat3[9] = 0;\n        mat3[10] = 1;\n        mat3[11] = 0;\n\n        mat3[12] = matrix.tx;\n        mat3[13] = matrix.ty;\n        mat3[14] = 0;\n        mat3[15] = 1;\n\n        this._dirtyId++;\n\n        return this;\n    }\n\n    setToMultLegacy(pt: Matrix, lt: Matrix3d): this\n    {\n        const out = this.mat4;\n        const b = lt.mat4;\n\n        const a00 = pt.a; const a01 = pt.b;\n        const a10 = pt.c; const a11 = pt.d;\n        const a30 = pt.tx; const\n            a31 = pt.ty;\n\n        let b0 = b[0]; let b1 = b[1]; let b2 = b[2]; let\n            b3 = b[3];\n\n        out[0] = b0 * a00 + b1 * a10 + b3 * a30;\n        out[1] = b0 * a01 + b1 * a11 + b3 * a31;\n        out[2] = b2;\n        out[3] = b3;\n\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        b3 = b[7];\n        out[4] = b0 * a00 + b1 * a10 + b3 * a30;\n        out[5] = b0 * a01 + b1 * a11 + b3 * a31;\n        out[6] = b2;\n        out[7] = b3;\n\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        b3 = b[11];\n        out[8] = b0 * a00 + b1 * a10 + b3 * a30;\n        out[9] = b0 * a01 + b1 * a11 + b3 * a31;\n        out[10] = b2;\n        out[11] = b3;\n\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        b3 = b[15];\n        out[12] = b0 * a00 + b1 * a10 + b3 * a30;\n        out[13] = b0 * a01 + b1 * a11 + b3 * a31;\n        out[14] = b2;\n        out[15] = b3;\n\n        this._dirtyId++;\n\n        return this;\n    }\n\n    setToMultLegacy2(pt: Matrix3d, lt: Matrix): this\n    {\n        const out = this.mat4;\n        const a = pt.mat4;\n\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\n            a03 = a[3];\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\n            a13 = a[7];\n\n        const b00 = lt.a; const b01 = lt.b;\n        const b10 = lt.c; const b11 = lt.d;\n        const b30 = lt.tx; const\n            b31 = lt.ty;\n\n        out[0] = b00 * a00 + b01 * a10;\n        out[1] = b00 * a01 + b01 * a11;\n        out[2] = b00 * a02 + b01 * a12;\n        out[3] = b00 * a03 + b01 * a13;\n\n        out[4] = b10 * a00 + b11 * a10;\n        out[5] = b10 * a01 + b11 * a11;\n        out[6] = b10 * a02 + b11 * a12;\n        out[7] = b10 * a03 + b11 * a13;\n\n        out[8] = a[8];\n        out[9] = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n\n        out[12] = b30 * a00 + b31 * a10 + a[12];\n        out[13] = b30 * a01 + b31 * a11 + a[13];\n        out[14] = b30 * a02 + b31 * a12 + a[14];\n        out[15] = b30 * a03 + b31 * a13 + a[15];\n\n        this._dirtyId++;\n\n        return this;\n    }\n\n    // that's transform multiplication we use\n    setToMult(pt: Matrix3d, lt: Matrix3d): this\n    {\n        Matrix3d.glMatrixMat4Multiply(this.mat4, pt.mat4, lt.mat4);\n\n        this._dirtyId++;\n\n        return this;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    prepend(lt: any): void\n    {\n        if (lt.mat4)\n        {\n            this.setToMult(lt, this);\n        }\n        else\n        {\n            this.setToMultLegacy(lt, this);\n        }\n    }\n\n    static glMatrixMat4Invert(out: Float64Array, a: Float64Array): Float64Array\n    {\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\n            a03 = a[3];\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\n            a13 = a[7];\n        const a20 = a[8]; const a21 = a[9]; const a22 = a[10]; const\n            a23 = a[11];\n        const a30 = a[12]; const a31 = a[13]; const a32 = a[14]; const\n            a33 = a[15];\n\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant\n        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n        if (!det)\n        {\n            return null;\n        }\n        det = 1.0 / det;\n\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n        return out;\n    }\n\n    static glMatrixMat4Multiply(out: Float64Array, a: Float64Array, b: Float64Array): Float64Array\n    {\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\n            a03 = a[3];\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\n            a13 = a[7];\n        const a20 = a[8]; const a21 = a[9]; const a22 = a[10]; const\n            a23 = a[11];\n        const a30 = a[12]; const a31 = a[13]; const a32 = a[14]; const\n            a33 = a[15];\n\n        // Cache only the current line of the second matrix\n        let b0 = b[0]; let b1 = b[1]; let b2 = b[2]; let\n            b3 = b[3];\n\n        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        b3 = b[7];\n        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        b3 = b[11];\n        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        b3 = b[15];\n        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        return out;\n    }\n}\n","import { LinearProjection } from '../base';\nimport { ObservablePoint3d } from './Point3d';\nimport { Matrix, Transform } from '@pixi/math';\nimport { Matrix3d } from './Matrix3d';\nimport { ObservableEuler } from './ObservableEuler';\n\nconst tempMat = new Matrix3d();\n\nexport class Projection3d extends LinearProjection<Matrix3d>\n{\n    constructor(legacy: Transform, enable?: boolean)\n    {\n        super(legacy, enable);\n        this.local = new Matrix3d();\n        this.world = new Matrix3d();\n\n        this.local.cacheInverse = true;\n        this.world.cacheInverse = true;\n\n        this.position._z = 0;\n        this.scale._z = 1;\n        this.pivot._z = 0;\n    }\n\n    cameraMatrix: Matrix3d = null;\n\n    _cameraMode = false;\n\n    get cameraMode(): boolean\n    {\n        return this._cameraMode;\n    }\n\n    set cameraMode(value: boolean)\n    {\n        if (this._cameraMode === value)\n        {\n            return;\n        }\n        this._cameraMode = value;\n\n        this.euler._sign = this._cameraMode ? -1 : 1;\n        this.euler._quatDirtyId++;\n\n        if (value)\n        {\n            this.cameraMatrix = new Matrix3d();\n        }\n    }\n\n    position = new ObservablePoint3d(this.onChange, this, 0, 0);\n    scale = new ObservablePoint3d(this.onChange, this, 1, 1);\n    euler = new ObservableEuler(this.onChange, this, 0, 0, 0);\n    pivot = new ObservablePoint3d(this.onChange, this, 0, 0);\n\n    onChange(): void\n    {\n        this._projID++;\n    }\n\n    clear(): void\n    {\n        if (this.cameraMatrix)\n        {\n            this.cameraMatrix.identity();\n        }\n        this.position.set(0, 0, 0);\n        this.scale.set(1, 1, 1);\n        this.euler.set(0, 0, 0);\n        this.pivot.set(0, 0, 0);\n        super.clear();\n    }\n\n    updateLocalTransform(lt: Matrix): void\n    {\n        if (this._projID === 0)\n        {\n            this.local.copyFrom(lt);\n\n            return;\n        }\n        const matrix = this.local;\n        const euler = this.euler;\n        const pos = this.position;\n        const scale = this.scale;\n        const pivot = this.pivot;\n\n        euler.update();\n\n        if (!this.cameraMode)\n        {\n            matrix.setToRotationTranslationScale(euler.quaternion, pos._x, pos._y, pos._z, scale._x, scale._y, scale._z);\n            matrix.translate(-pivot._x, -pivot._y, -pivot._z);\n            matrix.setToMultLegacy(lt, matrix);\n\n            return;\n        }\n\n        matrix.setToMultLegacy(lt, this.cameraMatrix);\n        matrix.translate(pivot._x, pivot._y, pivot._z);\n        matrix.scale(1.0 / scale._x, 1.0 / scale._y, 1.0 / scale._z);\n        tempMat.setToRotationTranslationScale(euler.quaternion, 0, 0, 0, 1, 1, 1);\n        matrix.setToMult(matrix, tempMat);\n        matrix.translate(-pos._x, -pos._y, -pos._z);\n\n        this.local._dirtyId++;\n    }\n}\n","import { Container3d, container3dWorldTransform } from '../Container3d';\nimport { Projection3d } from '../Projection3d';\nimport { Mesh3d2d } from '../mesh/Mesh3d2d';\nimport { MeshMaterial } from '@pixi/mesh';\nimport { Mesh2d } from '../../proj2d';\nimport { Program } from '@pixi/core';\nimport { SimpleMesh, SimpleRope } from '@pixi/mesh-extras';\nimport { Container } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { Sprite3d } from './Sprite3d';\n\nconst containerProps: any = {\n    worldTransform: {\n        get: container3dWorldTransform,\n        enumerable: true,\n        configurable: true\n    },\n    position3d: {\n        get() { return this.proj.position; },\n        set(value: any) { this.proj.position.copy(value); }\n    },\n    scale3d: {\n        get() { return this.proj.scale; },\n        set(value: any) { this.proj.scale.copy(value); }\n    },\n    pivot3d: {\n        get() { return this.proj.pivot; },\n        set(value: any) { this.proj.pivot.copy(value); }\n    },\n    euler: {\n        get() { return this.proj.euler; },\n        set(value: any) { this.proj.euler.copy(value); }\n    }\n};\n\nfunction convertTo3d()\n{\n    if (this.proj) return;\n    this.proj = new Projection3d(this.transform);\n    this.toLocal = Container3d.prototype.toLocal;\n    this.isFrontFace = Container3d.prototype.isFrontFace;\n    this.getDepth = Container3d.prototype.getDepth;\n    Object.defineProperties(this, containerProps);\n}\n\nContainer.prototype.convertTo3d = convertTo3d;\n\nSprite.prototype.convertTo3d = function spriteConvertTo3d()\n{\n    if (this.proj) return;\n    this.calculateVertices = Sprite3d.prototype.calculateVertices;\n    this.calculateTrimmedVertices = Sprite3d.prototype.calculateTrimmedVertices;\n    this._calculateBounds = Sprite3d.prototype._calculateBounds;\n    this.containsPoint = Sprite3d.prototype.containsPoint;\n    this.pluginName = 'batch2d';\n    convertTo3d.call(this);\n};\n\nContainer.prototype.convertSubtreeTo3d = function convertSubtreeTo3d()\n{\n    this.convertTo3d();\n    for (let i = 0; i < this.children.length; i++)\n    {\n        this.children[i].convertSubtreeTo3d();\n    }\n};\n\nSimpleMesh.prototype.convertTo3d\n    = SimpleRope.prototype.convertTo3d\n    = function meshConvert3d()\n        {\n            if (this.proj) return;\n            this.calculateVertices = Mesh3d2d.prototype.calculateVertices;\n            this._renderDefault = (Mesh3d2d.prototype as any)._renderDefault;\n            if (this.material.pluginName !== 'batch2d')\n            {\n                this.material = new MeshMaterial(this.material.texture, {\n                    program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\n                    pluginName: 'batch2d'\n                });\n            }\n            convertTo3d.call(this);\n        };\n","import { Text, TextStyle } from '@pixi/text';\nimport { Projection3d } from '../Projection3d';\nimport { IPointData, Matrix } from '@pixi/math';\nimport { container3dGetDepth, container3dIsFrontFace, container3dToLocal } from '../Container3d';\nimport { DisplayObject } from '@pixi/display';\nimport { TRANSFORM_STEP } from '../../base';\nimport { Sprite3d } from './Sprite3d';\nimport { Euler } from '../Euler';\n\nexport class Text3d extends Text\n{\n    constructor(text?: string, style?: TextStyle, canvas?: HTMLCanvasElement)\n    {\n        super(text, style, canvas);\n        this.proj = new Projection3d(this.transform);\n        this.pluginName = 'batch2d';\n    }\n\n    proj: Projection3d;\n    vertexData2d: Float32Array = null;\n\n    get worldTransform(): Matrix\n    {\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\n    }\n\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\n        point?: T, skipUpdate?: boolean,\n        step = TRANSFORM_STEP.ALL): T\n    {\n        return container3dToLocal.call(this, position, from, point, skipUpdate, step);\n    }\n\n    isFrontFace(forceUpdate?: boolean): boolean\n    {\n        return container3dIsFrontFace.call(this, forceUpdate);\n    }\n\n    getDepth(forceUpdate?: boolean): boolean\n    {\n        return container3dGetDepth.call(this, forceUpdate);\n    }\n\n    get position3d(): IPointData\n    {\n        return this.proj.position;\n    }\n    set position3d(value: IPointData)\n    {\n        this.proj.position.copyFrom(value);\n    }\n    get scale3d(): IPointData\n    {\n        return this.proj.scale;\n    }\n    set scale3d(value: IPointData)\n    {\n        this.proj.scale.copyFrom(value);\n    }\n    get euler(): Euler\n    {\n        return this.proj.euler;\n    }\n    set euler(value: Euler)\n    {\n        this.proj.euler.copyFrom(value);\n    }\n    get pivot3d(): IPointData\n    {\n        return this.proj.pivot;\n    }\n    set pivot3d(value: IPointData)\n    {\n        this.proj.pivot.copyFrom(value);\n    }\n}\n\nText3d.prototype.calculateVertices = Sprite3d.prototype.calculateVertices;\n(Text3d.prototype as any).calculateTrimmedVertices = Sprite3d.prototype.calculateTrimmedVertices;\n(Text3d.prototype as any)._calculateBounds = Sprite3d.prototype._calculateBounds;\nText3d.prototype.containsPoint = Sprite3d.prototype.containsPoint;\n(Text3d.prototype as any)._render = Sprite3d.prototype._render;\n","import { IPointData, Matrix, Point } from '@pixi/math';\nimport { IWorldTransform } from './ProjectionSurface';\nimport { Dict } from '@pixi/utils';\n\nconst p = [new Point(), new Point(), new Point(), new Point()];\nconst a = [0, 0, 0, 0];\n\nexport abstract class Surface implements IWorldTransform\n{\n    surfaceID = 'default';\n\n    _updateID = 0;\n\n    vertexSrc = '';\n    fragmentSrc = '';\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fillUniforms(uniforms: Dict<any>): void\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    {\n\n    }\n\n    clear(): void\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    {\n\n    }\n\n    /**\n     * made for bilinear, other things will need adjustments, like test if (0) is inside\n     * @param {ArrayLike<number>} v\n     * @param out\n     * @param {Matrix} after\n     */\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    boundsQuad(v: ArrayLike<number>, out: any, after?: Matrix): void\n    {\n        let minX = out[0]; let\n            minY = out[1];\n        let maxX = out[0]; let\n            maxY = out[1];\n\n        for (let i = 2; i < 8; i += 2)\n        {\n            if (minX > out[i]) minX = out[i];\n            if (maxX < out[i]) maxX = out[i];\n            if (minY > out[i + 1]) minY = out[i + 1];\n            if (maxY < out[i + 1]) maxY = out[i + 1];\n        }\n\n        p[0].set(minX, minY);\n        this.apply(p[0], p[0]);\n        p[1].set(maxX, minY);\n        this.apply(p[1], p[1]);\n        p[2].set(maxX, maxY);\n        this.apply(p[2], p[2]);\n        p[3].set(minX, maxY);\n        this.apply(p[3], p[3]);\n\n        if (after)\n        {\n            after.apply(p[0], p[0]);\n            after.apply(p[1], p[1]);\n            after.apply(p[2], p[2]);\n            after.apply(p[3], p[3]);\n            out[0] = p[0].x;\n            out[1] = p[0].y;\n            out[2] = p[1].x;\n            out[3] = p[1].y;\n            out[4] = p[2].x;\n            out[5] = p[2].y;\n            out[6] = p[3].x;\n            out[7] = p[3].y;\n        }\n        else\n        {\n            for (let i = 1; i <= 3; i++)\n            {\n                if (p[i].y < p[0].y || (p[i].y === p[0].y && p[i].x < p[0].x))\n                {\n                    const t = p[0];\n\n                    p[0] = p[i];\n                    p[i] = t;\n                }\n            }\n\n            for (let i = 1; i <= 3; i++)\n            {\n                a[i] = Math.atan2(p[i].y - p[0].y, p[i].x - p[0].x);\n            }\n            for (let i = 1; i <= 3; i++)\n            {\n                for (let j = i + 1; j <= 3; j++)\n                {\n                    if (a[i] > a[j])\n                    {\n                        const t = p[i];\n\n                        p[i] = p[j];\n                        p[j] = t;\n                        const t2 = a[i];\n\n                        a[i] = a[j];\n                        a[j] = t2;\n                    }\n                }\n            }\n\n            out[0] = p[0].x;\n            out[1] = p[0].y;\n            out[2] = p[1].x;\n            out[3] = p[1].y;\n            out[4] = p[2].x;\n            out[5] = p[2].y;\n            out[6] = p[3].x;\n            out[7] = p[3].y;\n\n            if (((p[3].x - p[2].x) * (p[1].y - p[2].y)) - ((p[1].x - p[2].x) * (p[3].y - p[2].y)) < 0)\n            {\n                // triangle!!!\n                out[4] = p[3].x;\n                out[5] = p[3].y;\n\n                return;\n            }\n        }\n    }\n\n    abstract apply(pos: IPointData, newPos: IPointData): IPointData;\n\n    // TODO: remove props\n    abstract applyInverse(pos: IPointData, newPos: IPointData): IPointData;\n}\n","/* eslint-disable no-mixed-operators */\nimport { IPoint, IPointData, Matrix, Point, Rectangle, Transform } from '@pixi/math';\nimport { Sprite } from '@pixi/sprite';\nimport { Surface } from './BaseSurface';\nimport { Dict } from '@pixi/utils';\n\nconst tempMat = new Matrix();\nconst tempRect = new Rectangle();\nconst tempPoint = new Point();\n\nexport class BilinearSurface extends Surface\n{\n    distortion = new Point();\n\n    clear(): void\n    {\n        this.distortion.set(0, 0);\n    }\n\n    apply(pos: IPointData, newPos?: IPointData): IPointData\n    {\n        newPos = newPos || new Point();\n        const d = this.distortion;\n        const m = pos.x * pos.y;\n\n        newPos.x = pos.x + d.x * m;\n        newPos.y = pos.y + d.y * m;\n\n        return newPos;\n    }\n\n    applyInverse(pos: IPointData, newPos: IPoint): IPointData\n    {\n        newPos = newPos || new Point();\n        const vx = pos.x; const\n            vy = pos.y;\n        const dx = this.distortion.x; const\n            dy = this.distortion.y;\n\n        if (dx === 0.0)\n        {\n            newPos.x = vx;\n            newPos.y = vy / (1.0 + dy * vx);\n        }\n        else\n        if (dy === 0.0)\n        {\n            newPos.y = vy;\n            newPos.x = vx / (1.0 + dx * vy);\n        }\n        else\n        {\n            const b = (vy * dx - vx * dy + 1.0) * 0.5 / dy;\n            const d = b * b + vx / dy;\n\n            if (d <= 0.00001)\n            {\n                newPos.set(NaN, NaN);\n\n                return newPos;\n            }\n            if (dy > 0.0)\n            {\n                newPos.x = -b + Math.sqrt(d);\n            }\n            else\n            {\n                newPos.x = -b - Math.sqrt(d);\n            }\n            newPos.y = (vx / newPos.x - 1.0) / dx;\n        }\n\n        return newPos;\n    }\n\n    mapSprite(sprite: Sprite, quad: Array<IPointData>, outTransform?: Transform): this\n    {\n        const tex = sprite.texture;\n\n        tempRect.x = -sprite.anchor.x * tex.orig.width;\n        tempRect.y = -sprite.anchor.y * tex.orig.height;\n        tempRect.width = tex.orig.width;\n        tempRect.height = tex.orig.height;\n\n        return this.mapQuad(tempRect, quad, outTransform || sprite.transform as Transform);\n    }\n\n    mapQuad(rect: Rectangle, quad: Array<IPointData>, outTransform: Transform): this\n    {\n        const ax = -rect.x / rect.width;\n        const ay = -rect.y / rect.height;\n\n        const ax2 = (1.0 - rect.x) / rect.width;\n        const ay2 = (1.0 - rect.y) / rect.height;\n\n        const up1x = (quad[0].x * (1.0 - ax) + quad[1].x * ax);\n        const up1y = (quad[0].y * (1.0 - ax) + quad[1].y * ax);\n        const up2x = (quad[0].x * (1.0 - ax2) + quad[1].x * ax2);\n        const up2y = (quad[0].y * (1.0 - ax2) + quad[1].y * ax2);\n\n        const down1x = (quad[3].x * (1.0 - ax) + quad[2].x * ax);\n        const down1y = (quad[3].y * (1.0 - ax) + quad[2].y * ax);\n        const down2x = (quad[3].x * (1.0 - ax2) + quad[2].x * ax2);\n        const down2y = (quad[3].y * (1.0 - ax2) + quad[2].y * ax2);\n\n        const x00 = up1x * (1.0 - ay) + down1x * ay;\n        const y00 = up1y * (1.0 - ay) + down1y * ay;\n\n        const x10 = up2x * (1.0 - ay) + down2x * ay;\n        const y10 = up2y * (1.0 - ay) + down2y * ay;\n\n        const x01 = up1x * (1.0 - ay2) + down1x * ay2;\n        const y01 = up1y * (1.0 - ay2) + down1y * ay2;\n\n        const x11 = up2x * (1.0 - ay2) + down2x * ay2;\n        const y11 = up2y * (1.0 - ay2) + down2y * ay2;\n\n        const mat = tempMat;\n\n        mat.tx = x00;\n        mat.ty = y00;\n        mat.a = x10 - x00;\n        mat.b = y10 - y00;\n        mat.c = x01 - x00;\n        mat.d = y01 - y00;\n        tempPoint.set(x11, y11);\n        mat.applyInverse(tempPoint, tempPoint);\n        this.distortion.set(tempPoint.x - 1, tempPoint.y - 1);\n\n        outTransform.setFromMatrix(mat);\n\n        return this;\n    }\n\n    fillUniforms(uniforms: Dict<any>): void\n    {\n        uniforms.distortion = uniforms.distortion || new Float32Array([0, 0, 0, 0]);\n        const ax = Math.abs(this.distortion.x);\n        const ay = Math.abs(this.distortion.y);\n\n        uniforms.distortion[0] = ax * 10000 <= ay ? 0 : this.distortion.x;\n        uniforms.distortion[1] = ay * 10000 <= ax ? 0 : this.distortion.y;\n        uniforms.distortion[2] = 1.0 / uniforms.distortion[0];\n        uniforms.distortion[3] = 1.0 / uniforms.distortion[1];\n    }\n}\n","import { IPointData, Transform } from '@pixi/math';\nimport { AbstractProjection } from '../base';\nimport { Surface } from './BaseSurface';\nimport { BilinearSurface } from './BilinearSurface';\nimport { Sprite } from '@pixi/sprite';\n\nconst fun = Transform.prototype.updateTransform;\n\nexport interface IWorldTransform {\n    apply(pos: IPointData, newPos: IPointData): IPointData;\n\n    // TODO: remove props\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData;\n}\n\nfunction transformHack(this: Transform, parentTransform: Transform): IWorldTransform\n{\n    // TODO: pixi 6.1.0 global mixin\n    const proj = (this as any).proj as ProjectionSurface;\n\n    const pp = (parentTransform as any).proj as ProjectionSurface;\n    const ta = this as any;\n\n    if (!pp)\n    {\n        fun.call(this, parentTransform);\n        proj._activeProjection = null;\n\n        return;\n    }\n\n    if (pp._surface)\n    {\n        proj._activeProjection = pp;\n        this.updateLocalTransform();\n        this.localTransform.copyTo(this.worldTransform);\n        if (ta._parentID < 0)\n        {\n            ++ta._worldID;\n        }\n\n        return;\n    }\n\n    fun.call(this, parentTransform);\n    proj._activeProjection = pp._activeProjection;\n}\n\nexport class ProjectionSurface extends AbstractProjection\n{\n    _surface: Surface = null;\n    _activeProjection: ProjectionSurface = null;\n\n    // eslint-disable-next-line accessor-pairs\n    set enabled(value: boolean)\n    {\n        if (value === this._enabled)\n        {\n            return;\n        }\n        this._enabled = value;\n        if (value)\n        {\n            this.legacy.updateTransform = transformHack;\n            (this.legacy as any)._parentID = -1;\n        }\n        else\n        {\n            this.legacy.updateTransform = Transform.prototype.updateTransform;\n            (this.legacy as any)._parentID = -1;\n        }\n    }\n\n    get surface(): Surface\n    {\n        return this._surface;\n    }\n\n    set surface(value: Surface)\n    {\n        if (this._surface === value)\n        {\n            return;\n        }\n        this._surface = value || null;\n        (this.legacy as any)._parentID = -1;\n    }\n\n    applyPartial(pos: IPointData, newPos?: IPointData): IPointData\n    {\n        if (this._activeProjection !== null)\n        {\n            newPos = this.legacy.worldTransform.apply(pos, newPos);\n\n            return this._activeProjection.surface.apply(newPos, newPos);\n        }\n        if (this._surface !== null)\n        {\n            return this.surface.apply(pos, newPos);\n        }\n\n        return this.legacy.worldTransform.apply(pos, newPos);\n    }\n\n    apply(pos: IPointData, newPos?: IPointData): IPointData\n    {\n        if (this._activeProjection !== null)\n        {\n            newPos = this.legacy.worldTransform.apply(pos, newPos);\n            this._activeProjection.surface.apply(newPos, newPos);\n\n            return this._activeProjection.legacy.worldTransform.apply(newPos, newPos);\n        }\n        if (this._surface !== null)\n        {\n            newPos = this.surface.apply(pos, newPos);\n\n            return this.legacy.worldTransform.apply(newPos, newPos);\n        }\n\n        return this.legacy.worldTransform.apply(pos, newPos);\n    }\n\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData\n    {\n        if (this._activeProjection !== null)\n        {\n            newPos = this._activeProjection.legacy.worldTransform.applyInverse(pos, newPos);\n            this._activeProjection._surface.applyInverse(newPos, newPos);\n\n            return this.legacy.worldTransform.applyInverse(newPos, newPos);\n        }\n        if (this._surface !== null)\n        {\n            newPos = this.legacy.worldTransform.applyInverse(pos, newPos);\n\n            return this._surface.applyInverse(newPos, newPos);\n        }\n\n        return this.legacy.worldTransform.applyInverse(pos, newPos);\n    }\n\n    mapBilinearSprite(sprite: Sprite, quad: Array<IPointData>): void\n    {\n        if (!(this._surface instanceof BilinearSurface))\n        {\n            this.surface = new BilinearSurface();\n        }\n        (this.surface as BilinearSurface).mapSprite(sprite, quad, this.legacy);\n    }\n\n    _currentSurfaceID = -1;\n    _currentLegacyID = -1;\n    _lastUniforms : any = null;\n\n    clear(): void\n    {\n        if (this.surface)\n        {\n            this.surface.clear();\n        }\n    }\n\n    get uniforms(): any\n    {\n        if (this._currentLegacyID === (this.legacy as any)._worldID\n            && this._currentSurfaceID === this.surface._updateID)\n        {\n            return this._lastUniforms;\n        }\n\n        this._lastUniforms = this._lastUniforms || {};\n        this._lastUniforms.translationMatrix = this.legacy.worldTransform;\n        this._surface.fillUniforms(this._lastUniforms);\n\n        return this._lastUniforms;\n    }\n}\n"],"names":["Text2d","Text3d"],"mappings":";2gOAKA,09HCAA,+/ECEA,uwPCCA,umBCIA,+mDCWAA,4DACAA,oICnBA,4rMCGA,2gOCFA,svSCKA,uWAwBA,wzDC0CAC,sMAGAA,6nJC5EA,w3CCEA,ylDCAA,+CASA"}