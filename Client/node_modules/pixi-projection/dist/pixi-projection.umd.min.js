/* eslint-disable */
this.PIXI=this.PIXI||{},this.PIXI.projection=this.PIXI.projection||{},function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@pixi/core"),require("@pixi/constants"),require("@pixi/utils"),require("@pixi/math"),require("@pixi/display"),require("@pixi/sprite-tiling"),require("@pixi/mesh"),require("@pixi/mesh-extras"),require("@pixi/sprite"),require("@pixi/text"),require("@pixi/graphics")):"function"==typeof define&&define.amd?define(["exports","@pixi/core","@pixi/constants","@pixi/utils","@pixi/math","@pixi/display","@pixi/sprite-tiling","@pixi/mesh","@pixi/mesh-extras","@pixi/sprite","@pixi/text","@pixi/graphics"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).pixi_projection={},t.PIXI,t.PIXI,t.PIXI.utils,t.PIXI,t.PIXI,t.PIXI,t.PIXI,t.PIXI,t.PIXI,t.PIXI,t.PIXI)}(this,(function(t,e,r,i,s,a,o,n,h,l,c,u){"use strict";class p extends e.Geometry{constructor(t=!1){super(),this._buffer=new e.Buffer(null,t,!1),this._indexBuffer=new e.Buffer(null,t,!0),this.addAttribute("aVertexPosition",this._buffer,3,!1,r.TYPES.FLOAT).addAttribute("aTextureCoord",this._buffer,2,!1,r.TYPES.FLOAT).addAttribute("aColor",this._buffer,4,!0,r.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId",this._buffer,1,!0,r.TYPES.FLOAT).addIndex(this._indexBuffer)}}class d{static create(t){const{vertex:r,fragment:s,vertexSize:a,geometryClass:o}=Object.assign({vertex:"precision highp float;\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\ngl_Position.xyw = projectionMatrix * aVertexPosition;\ngl_Position.z = 0.0;\n\nvTextureCoord = aTextureCoord;\nvTextureId = aTextureId;\nvColor = aColor;\n}\n",fragment:"\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\nvec4 color;\n%forloop%\ngl_FragColor = color * vColor;\n}",geometryClass:p,vertexSize:7},t);return class extends e.AbstractBatchRenderer{constructor(t){super(t),this.shaderGenerator=new e.BatchShaderGenerator(r,s),this.geometryClass=o,this.vertexSize=a}packInterleavedGeometry(t,e,r,s,a){const{uint32View:o,float32View:n}=e,h=s/this.vertexSize,l=t.uvs,c=t.indices,u=t.vertexData,p=t.vertexData2d,d=t._texture.baseTexture._batchLocation,_=Math.min(t.worldAlpha,1),m=_<1&&t._texture.baseTexture.alphaMode?i.premultiplyTint(t._tintRGB,_):t._tintRGB+(255*_<<24);if(p){let t=0;for(let e=0;e<p.length;e+=3,t+=2)n[s++]=p[e],n[s++]=p[e+1],n[s++]=p[e+2],n[s++]=l[t],n[s++]=l[t+1],o[s++]=m,n[s++]=d}else for(let t=0;t<u.length;t+=2)n[s++]=u[t],n[s++]=u[t+1],n[s++]=1,n[s++]=l[t],n[s++]=l[t+1],o[s++]=m,n[s++]=d;for(let t=0;t<c.length;t++)r[a++]=h+c[t]}}}}class _{constructor(t,e=!0){_.prototype.__init.call(this),this.legacy=t,e&&(this.enabled=!0),this.legacy.proj=this}__init(){this._enabled=!1}get enabled(){return this._enabled}set enabled(t){this._enabled=t}clear(){}}function m(t){const e=this.proj,r=this,i=t._worldID,s=r.localTransform,a=e.scaleAfterAffine&&e.affine>=2;r._localID!==r._currentLocalID&&(a?(s.a=r._cx,s.b=r._sx,s.c=r._cy,s.d=r._sy,s.tx=r.position._x,s.ty=r.position._y):(s.a=r._cx*r.scale._x,s.b=r._sx*r.scale._x,s.c=r._cy*r.scale._y,s.d=r._sy*r.scale._y,s.tx=r.position._x-(r.pivot._x*s.a+r.pivot._y*s.c),s.ty=r.position._y-(r.pivot._x*s.b+r.pivot._y*s.d)),r._currentLocalID=r._localID,e._currentProjID=-1);const o=e._projID;if(e._currentProjID!==o&&(e._currentProjID=o,e.updateLocalTransform(s),r._parentID=-1),r._parentID!==i){const s=t.proj;s&&!s._affine?e.world.setToMult(s.world,e.local):e.world.setToMultLegacy(t.worldTransform,e.local);const o=r.worldTransform;e.world.copyTo(o,e._affine,e.affinePreserveOrientation),a&&(o.a*=r.scale._x,o.b*=r.scale._x,o.c*=r.scale._y,o.d*=r.scale._y,o.tx-=r.pivot._x*o.a+r.pivot._y*o.c,o.ty-=r.pivot._x*o.b+r.pivot._y*o.d),r._parentID=i,r._worldID++}}t.TRANSFORM_STEP=void 0,function(t){t[t.NONE=0]="NONE";t[t.BEFORE_PROJ=4]="BEFORE_PROJ";t[t.PROJ=5]="PROJ";t[t.ALL=9]="ALL"}(t.TRANSFORM_STEP||(t.TRANSFORM_STEP={})),t.AFFINE=void 0,function(t){t[t.NONE=0]="NONE";t[t.FREE=1]="FREE";t[t.AXIS_X=2]="AXIS_X";t[t.AXIS_Y=3]="AXIS_Y";t[t.POINT=4]="POINT";t[t.AXIS_XR=5]="AXIS_XR"}(t.AFFINE||(t.AFFINE={}));class y extends _{constructor(...t){super(...t),y.prototype.__init.call(this),y.prototype.__init2.call(this),y.prototype.__init3.call(this),y.prototype.__init4.call(this),y.prototype.__init5.call(this)}updateLocalTransform(t){}__init(){this._projID=0}__init2(){this._currentProjID=-1}__init3(){this._affine=t.AFFINE.NONE}__init4(){this.affinePreserveOrientation=!1}__init5(){this.scaleAfterAffine=!0}set affine(t){this._affine!==t&&(this._affine=t,this._currentProjID=-1,this.legacy._currentLocalID=-1)}get affine(){return this._affine}set enabled(t){t!==this._enabled&&(this._enabled=t,t?(this.legacy.updateTransform=m,this.legacy._parentID=-1):(this.legacy.updateTransform=s.Transform.prototype.updateTransform,this.legacy._parentID=-1))}clear(){this._currentProjID=-1,this._projID=0}}class x extends e.AbstractBatchRenderer{constructor(...t){super(...t),x.prototype.__init.call(this),x.prototype.__init2.call(this)}__init(){this.forceMaxTextures=0}getUniforms(t){return this.defUniforms}syncUniforms(t){if(!t)return;const e=this._shader;for(const r in t)e.uniforms[r]=t[r]}__init2(){this.defUniforms={}}buildDrawCalls(t,r,s){const a=this,{_bufferedElements:o,_attributeBuffer:n,_indexBuffer:h,vertexSize:l}=this,c=e.AbstractBatchRenderer._drawCallPool;let u=this._dcIndex,p=this._aIndex,d=this._iIndex,_=c[u];_.start=this._iIndex,_.texArray=t;for(let e=r;e<s;++e){const s=o[e],a=s._texture.baseTexture,m=i.premultiplyBlendMode[a.alphaMode?1:0][s.blendMode],y=this.getUniforms(s);o[e]=null,r<e&&(_.blend!==m||_.uniforms!==y)&&(_.size=d-_.start,r=e,_=c[++u],_.texArray=t,_.start=d),this.packInterleavedGeometry(s,n,h,p,d),p+=s.vertexData.length/2*l,d+=s.indices.length,_.blend=m,_.uniforms=y}r<s&&(_.size=d-_.start,++u),a._dcIndex=u,a._aIndex=p,a._iIndex=d}drawBatches(){const t=this._dcIndex,{gl:r,state:i,shader:s}=this.renderer,a=e.AbstractBatchRenderer._drawCallPool;let o=null,n=null;for(let e=0;e<t;e++){const{texArray:t,type:h,size:l,start:c,blend:u,uniforms:p}=a[e];n!==t&&(n=t,this.bindAndClearTexArray(t)),o!==p&&(o=p,this.syncUniforms(p),s.syncUniformGroup(this._shader.uniformGroup)),this.state.blendMode=u,i.set(this.state),r.drawElements(h,l,r.UNSIGNED_SHORT,2*c)}}contextChange(){if(!this.forceMaxTextures)return super.contextChange(),void this.syncUniforms(this.defUniforms);const t=this;t.MAX_TEXTURES=this.forceMaxTextures,this._shader=t.shaderGenerator.generateShader(this.MAX_TEXTURES),this.syncUniforms(this.defUniforms);for(let e=0;e<t._packedGeometryPoolSize;e++)t._packedGeometries[e]=new this.geometryClass;this.initFlushBuffers()}}function f(t,e,r,i,s){const a=e.x-t.x,o=r.x-i.x,n=r.x-t.x,h=e.y-t.y,l=r.y-i.y,c=r.y-t.y,u=a*l-h*o;if(Math.abs(u)<1e-7)return s.x=a,s.y=h,0;const p=(n*l-c*o)/u,d=(a*c-h*n)/u;return d<1e-6||d-1>-1e-6?-1:(s.x=t.x+p*(e.x-t.x),s.y=t.y+p*(e.y-t.y),1)}e.Renderer.registerPlugin("batch2d",d.create({}));const v=[1,0,0,0,1,0,0,0,1];class g{static __initStatic(){this.IDENTITY=new g}static __initStatic2(){this.TEMP_MATRIX=new g}__init(){this.floatArray=null}constructor(t){g.prototype.__init.call(this),this.mat3=new Float64Array(t||v)}get a(){return this.mat3[0]/this.mat3[8]}set a(t){this.mat3[0]=t*this.mat3[8]}get b(){return this.mat3[1]/this.mat3[8]}set b(t){this.mat3[1]=t*this.mat3[8]}get c(){return this.mat3[3]/this.mat3[8]}set c(t){this.mat3[3]=t*this.mat3[8]}get d(){return this.mat3[4]/this.mat3[8]}set d(t){this.mat3[4]=t*this.mat3[8]}get tx(){return this.mat3[6]/this.mat3[8]}set tx(t){this.mat3[6]=t*this.mat3[8]}get ty(){return this.mat3[7]/this.mat3[8]}set ty(t){this.mat3[7]=t*this.mat3[8]}set(t,e,r,i,s,a){const o=this.mat3;return o[0]=t,o[1]=e,o[2]=0,o[3]=r,o[4]=i,o[5]=0,o[6]=s,o[7]=a,o[8]=1,this}toArray(t,e){this.floatArray||(this.floatArray=new Float32Array(9));const r=e||this.floatArray,i=this.mat3;return t?(r[0]=i[0],r[1]=i[1],r[2]=i[2],r[3]=i[3],r[4]=i[4],r[5]=i[5],r[6]=i[6],r[7]=i[7],r[8]=i[8]):(r[0]=i[0],r[1]=i[3],r[2]=i[6],r[3]=i[1],r[4]=i[4],r[5]=i[7],r[6]=i[2],r[7]=i[5],r[8]=i[8]),r}apply(t,e){e=e||new s.Point;const r=this.mat3,i=t.x,a=t.y,o=1/(r[2]*i+r[5]*a+r[8]);return e.x=o*(r[0]*i+r[3]*a+r[6]),e.y=o*(r[1]*i+r[4]*a+r[7]),e}translate(t,e){const r=this.mat3;return r[0]+=t*r[2],r[1]+=e*r[2],r[3]+=t*r[5],r[4]+=e*r[5],r[6]+=t*r[8],r[7]+=e*r[8],this}scale(t,e){const r=this.mat3;return r[0]*=t,r[1]*=e,r[3]*=t,r[4]*=e,r[6]*=t,r[7]*=e,this}scaleAndTranslate(t,e,r,i){const s=this.mat3;s[0]=t*s[0]+r*s[2],s[1]=e*s[1]+i*s[2],s[3]=t*s[3]+r*s[5],s[4]=e*s[4]+i*s[5],s[6]=t*s[6]+r*s[8],s[7]=e*s[7]+i*s[8]}applyInverse(t,e){e=e||new s.Point;const r=this.mat3,i=t.x,a=t.y,o=r[0],n=r[3],h=r[6],l=r[1],c=r[4],u=r[7],p=r[2],d=r[5],_=r[8],m=(_*c-u*d)*i+(-_*n+h*d)*a+(u*n-h*c),y=(-_*l+u*p)*i+(_*o-h*p)*a+(-u*o+h*l),x=(d*l-c*p)*i+(-d*o+n*p)*a+(c*o-n*l);return e.x=m/x,e.y=y/x,e}invert(){const t=this.mat3,e=t[0],r=t[1],i=t[2],s=t[3],a=t[4],o=t[5],n=t[6],h=t[7],l=t[8],c=l*a-o*h,u=-l*s+o*n,p=h*s-a*n;let d=e*c+r*u+i*p;return d?(d=1/d,t[0]=c*d,t[1]=(-l*r+i*h)*d,t[2]=(o*r-i*a)*d,t[3]=u*d,t[4]=(l*e-i*n)*d,t[5]=(-o*e+i*s)*d,t[6]=p*d,t[7]=(-h*e+r*n)*d,t[8]=(a*e-r*s)*d,this):this}identity(){const t=this.mat3;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,this}clone(){return new g(this.mat3)}copyTo2dOr3d(t){const e=this.mat3,r=t.mat3;return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],t}copyTo(e,r,i){const s=this.mat3,a=1/s[8],o=s[6]*a,n=s[7]*a;if(e.a=(s[0]-s[2]*o)*a,e.b=(s[1]-s[2]*n)*a,e.c=(s[3]-s[5]*o)*a,e.d=(s[4]-s[5]*n)*a,e.tx=o,e.ty=n,r>=2){let s=e.a*e.d-e.b*e.c;i||(s=Math.abs(s)),r===t.AFFINE.POINT?(s=s>0?1:-1,e.a=s,e.b=0,e.c=0,e.d=s):r===t.AFFINE.AXIS_X?(s/=Math.sqrt(e.b*e.b+e.d*e.d),e.c=0,e.d=s):r===t.AFFINE.AXIS_Y?(s/=Math.sqrt(e.a*e.a+e.c*e.c),e.a=s,e.c=0):r===t.AFFINE.AXIS_XR&&(e.a=e.d*s,e.c=-e.b*s)}return e}copyFrom(t){const e=this.mat3;return e[0]=t.a,e[1]=t.b,e[2]=0,e[3]=t.c,e[4]=t.d,e[5]=0,e[6]=t.tx,e[7]=t.ty,e[8]=1,this}setToMultLegacy(t,e){const r=this.mat3,i=e.mat3,s=t.a,a=t.b,o=t.c,n=t.d,h=t.tx,l=t.ty,c=i[0],u=i[1],p=i[2],d=i[3],_=i[4],m=i[5],y=i[6],x=i[7],f=i[8];return r[0]=c*s+u*o+p*h,r[1]=c*a+u*n+p*l,r[2]=p,r[3]=d*s+_*o+m*h,r[4]=d*a+_*n+m*l,r[5]=m,r[6]=y*s+x*o+f*h,r[7]=y*a+x*n+f*l,r[8]=f,this}setToMultLegacy2(t,e){const r=this.mat3,i=t.mat3,s=i[0],a=i[1],o=i[2],n=i[3],h=i[4],l=i[5],c=i[6],u=i[7],p=i[8],d=e.a,_=e.b,m=e.c,y=e.d,x=e.tx,f=e.ty;return r[0]=d*s+_*n,r[1]=d*a+_*h,r[2]=d*o+_*l,r[3]=m*s+y*n,r[4]=m*a+y*h,r[5]=m*o+y*l,r[6]=x*s+f*n+c,r[7]=x*a+f*h+u,r[8]=x*o+f*l+p,this}setToMult(t,e){const r=this.mat3,i=t.mat3,s=e.mat3,a=i[0],o=i[1],n=i[2],h=i[3],l=i[4],c=i[5],u=i[6],p=i[7],d=i[8],_=s[0],m=s[1],y=s[2],x=s[3],f=s[4],v=s[5],g=s[6],T=s[7],w=s[8];return r[0]=_*a+m*h+y*u,r[1]=_*o+m*l+y*p,r[2]=_*n+m*c+y*d,r[3]=x*a+f*h+v*u,r[4]=x*o+f*l+v*p,r[5]=x*n+f*c+v*d,r[6]=g*a+T*h+w*u,r[7]=g*o+T*l+w*p,r[8]=g*n+T*c+w*d,this}prepend(t){return t.mat3?this.setToMult(t,this):this.setToMultLegacy(t,this)}}g.__initStatic(),g.__initStatic2();const T="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec3 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\n\nvTextureCoord = uTransform * vec3(aTextureCoord, 1.0);\n}\n",w=new g;class I extends e.ObjectRenderer{constructor(t){super(t),I.prototype.__init.call(this);const r={globals:this.renderer.globalUniforms};this.shader=e.Shader.from(T,"\nvarying vec3 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\nvec2 coord = mod(vTextureCoord.xy / vTextureCoord.z - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\ncoord = (uMapCoord * vec3(coord, 1.0)).xy;\ncoord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\nvec4 sample = texture2D(uSampler, coord);\ngl_FragColor = sample * uColor;\n}\n",r),this.simpleShader=e.Shader.from(T,"\nvarying vec3 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\nvec4 sample = texture2D(uSampler, vTextureCoord.xy / vTextureCoord.z);\ngl_FragColor = sample * uColor;\n}\n",r)}__init(){this.quad=new e.QuadUv}render(t){const e=this.renderer,s=this.quad;let a=s.vertices;a[0]=a[6]=t._width*-t.anchor.x,a[1]=a[3]=t._height*-t.anchor.y,a[2]=a[4]=t._width*(1-t.anchor.x),a[5]=a[7]=t._height*(1-t.anchor.y),t.uvRespectAnchor&&(a=s.uvs,a[0]=a[6]=-t.anchor.x,a[1]=a[3]=-t.anchor.y,a[2]=a[4]=1-t.anchor.x,a[5]=a[7]=1-t.anchor.y),s.invalidate();const o=t._texture,n=o.baseTexture,h=t.tileProj.world,l=t.uvMatrix;let c=n.isPowerOfTwo&&o.frame.width===n.width&&o.frame.height===n.height;c&&(n._glTextures[e.CONTEXT_UID]?c=n.wrapMode!==r.WRAP_MODES.CLAMP:n.wrapMode===r.WRAP_MODES.CLAMP&&(n.wrapMode=r.WRAP_MODES.REPEAT));const u=c?this.simpleShader:this.shader;w.identity(),w.scale(o.width,o.height),w.prepend(h),w.scale(1/t._width,1/t._height),w.invert(),c?w.prepend(l.mapCoord):(u.uniforms.uMapCoord=l.mapCoord.toArray(!0),u.uniforms.uClampFrame=l.uClampFrame,u.uniforms.uClampOffset=l.uClampOffset),u.uniforms.uTransform=w.toArray(!0),u.uniforms.uColor=i.premultiplyTintToRgba(t.tint,t.worldAlpha,u.uniforms.uColor,n.premultiplyAlpha),u.uniforms.translationMatrix=t.worldTransform.toArray(!0),u.uniforms.uSampler=o,e.shader.bind(u,!1),e.geometry.bind(s,void 0),e.state.setBlendMode(i.correctBlendMode(t.blendMode,n.premultiplyAlpha)),e.geometry.draw(r.DRAW_MODES.TRIANGLES,6,0)}}const M=new s.Point,b=[new s.Point,new s.Point,new s.Point,new s.Point],j=new s.Rectangle,D=new g;class P extends y{constructor(t,e){super(t,e),P.prototype.__init.call(this),P.prototype.__init2.call(this),P.prototype.__init3.call(this),this.local=new g,this.world=new g}__init(){this.matrix=new g}__init2(){this.pivot=new s.ObservablePoint(this.onChange,this,0,0)}__init3(){this.reverseLocalOrder=!1}onChange(){const t=this.pivot,e=this.matrix.mat3;e[6]=-(t._x*e[0]+t._y*e[3]),e[7]=-(t._x*e[1]+t._y*e[4]),this._projID++}setAxisX(t,e=1){const r=t.x,i=t.y,s=Math.sqrt(r*r+i*i),a=this.matrix.mat3;a[0]=r/s,a[1]=i/s,a[2]=e/s,this.onChange()}setAxisY(t,e=1){const r=t.x,i=t.y,s=Math.sqrt(r*r+i*i),a=this.matrix.mat3;a[3]=r/s,a[4]=i/s,a[5]=e/s,this.onChange()}mapSprite(t,e){const r=t.texture;j.x=-t.anchor.x*r.orig.width,j.y=-t.anchor.y*r.orig.height,j.width=r.orig.width,j.height=r.orig.height,this.mapQuad(j,e)}mapQuad(t,e){b[0].set(t.x,t.y),b[1].set(t.x+t.width,t.y),b[2].set(t.x+t.width,t.y+t.height),b[3].set(t.x,t.y+t.height);let r=1,i=2,s=3;if(0===f(e[0],e[2],e[1],e[3],M))return;r=1,i=3,s=2;const a=Math.sqrt((e[0].x-M.x)*(e[0].x-M.x)+(e[0].y-M.y)*(e[0].y-M.y)),o=Math.sqrt((e[r].x-M.x)*(e[r].x-M.x)+(e[r].y-M.y)*(e[r].y-M.y)),n=Math.sqrt((e[i].x-M.x)*(e[i].x-M.x)+(e[i].y-M.y)*(e[i].y-M.y)),h=Math.sqrt((e[s].x-M.x)*(e[s].x-M.x)+(e[s].y-M.y)*(e[s].y-M.y)),l=(a+h)/h,c=(o+n)/n,u=(o+n)/o;let p=this.matrix.mat3;p[0]=b[0].x*l,p[1]=b[0].y*l,p[2]=l,p[3]=b[r].x*c,p[4]=b[r].y*c,p[5]=c,p[6]=b[i].x*u,p[7]=b[i].y*u,p[8]=u,this.matrix.invert(),p=D.mat3,p[0]=e[0].x,p[1]=e[0].y,p[2]=1,p[3]=e[r].x,p[4]=e[r].y,p[5]=1,p[6]=e[i].x,p[7]=e[i].y,p[8]=1,this.matrix.setToMult(D,this.matrix),this._projID++}updateLocalTransform(t){0!==this._projID?this.reverseLocalOrder?this.local.setToMultLegacy2(this.matrix,t):this.local.setToMultLegacy(t,this.matrix):this.local.copyFrom(t)}clear(){super.clear(),this.matrix.identity(),this.pivot.set(0,0)}}function S(){return this.proj.affine?this.transform.worldTransform:this.proj.world}class F extends a.Container{constructor(){super(),this.proj=new P(this.transform)}toLocal(e,r,i,s,a=t.TRANSFORM_STEP.ALL){return r&&(e=r.toGlobal(e,i,s)),s||this._recursivePostUpdateTransform(),a>=t.TRANSFORM_STEP.PROJ?(s||this.displayObjectUpdateTransform(),this.proj.affine?this.transform.worldTransform.applyInverse(e,i):this.proj.world.applyInverse(e,i)):(this.parent?i=this.parent.worldTransform.applyInverse(e,i):(i.x=e.x,i.y=e.y),a===t.TRANSFORM_STEP.NONE?i:this.transform.localTransform.applyInverse(i,i))}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}}const A=F.prototype.toLocal;class C extends n.Mesh{static __initStatic(){this.defaultVertexShader="precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\ngl_Position.z = 0.0;\n\nvTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n"}static __initStatic2(){this.defaultFragmentShader="\nvarying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\ngl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}"}constructor(t,e,r,i){super(t,e,r,i),C.prototype.__init.call(this),this.proj=new P(this.transform)}__init(){this.vertexData2d=null}calculateVertices(){if(this.proj._affine)return this.vertexData2d=null,void super.calculateVertices();const t=this.geometry,e=t.buffers[0].data,r=this;if(t.vertexDirtyId===r.vertexDirty&&r._transformID===r.transform._worldID)return;r._transformID=r.transform._worldID,r.vertexData.length!==e.length&&(r.vertexData=new Float32Array(e.length)),this.vertexData2d&&this.vertexData2d.length===3*e.length/2||(this.vertexData2d=new Float32Array(3*e.length));const i=this.proj.world.mat3,s=this.vertexData2d,a=r.vertexData;for(let t=0;t<a.length/2;t++){const r=e[2*t],o=e[2*t+1],n=i[0]*r+i[3]*o+i[6],h=i[1]*r+i[4]*o+i[7],l=i[2]*r+i[5]*o+i[8];s[3*t]=n,s[3*t+1]=h,s[3*t+2]=l,a[2*t]=n/l,a[2*t+1]=h/l}r.vertexDirty=t.vertexDirtyId}_renderDefault(t){const e=this.shader;e.alpha=this.worldAlpha,e.update&&e.update(),t.batch.flush(),function(t){let e,r=t[0],i=1;for(;i<t.length;){const s=t[i],a=t[i+1];if(i+=2,("optionalAccess"===s||"optionalCall"===s)&&null==r)return;"access"===s||"optionalAccess"===s?(e=r,r=a(r)):"call"!==s&&"optionalCall"!==s||(r=a(((...t)=>r.call(e,...t))),e=void 0)}return r}([e,"access",t=>t.program,"access",t=>t.uniformData,"optionalAccess",t=>t.translationMatrix])&&(e.uniforms.translationMatrix=this.worldTransform.toArray(!0)),t.shader.bind(e,!1),t.state.set(this.state),t.geometry.bind(this.geometry,e),t.geometry.draw(this.drawMode,this.size,this.start,this.geometry.instanceCount)}toLocal(e,r,i,s,a=t.TRANSFORM_STEP.ALL){return A.call(this,e,r,i,s,a)}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}}C.__initStatic(),C.__initStatic2();class z extends C{constructor(t,r,i,s,a){super(new n.MeshGeometry(r,i,s),new n.MeshMaterial(t,{program:e.Program.from(C.defaultVertexShader,C.defaultFragmentShader),pluginName:"batch2d"}),null,a),z.prototype.__init2.call(this),this.geometry.getBuffer("aVertexPosition").static=!1}__init2(){this.autoUpdate=!0}get vertices(){return this.geometry.getBuffer("aVertexPosition").data}set vertices(t){this.geometry.getBuffer("aVertexPosition").data=t}_render(t){this.autoUpdate&&this.geometry.getBuffer("aVertexPosition").update(),super._render(t)}}class N extends l.Sprite{constructor(t){super(t),N.prototype.__init.call(this),this.proj=new P(this.transform),this.pluginName="batch2d"}__init(){this.vertexData2d=null}_calculateBounds(){this.calculateTrimmedVertices(),this._bounds.addQuad(this.vertexTrimmedData)}calculateVertices(){const t=this._texture;if(this.proj._affine)return this.vertexData2d=null,void super.calculateVertices();this.vertexData2d||(this.vertexData2d=new Float32Array(12));const e=this.transform._worldID,r=t._updateID;if(this._transformID===e&&this._textureID===r)return;this._textureID!==r&&(this.uvs=t._uvs.uvsFloat32),this._transformID=e,this._textureID=r;const i=this.proj.world.mat3,s=this.vertexData2d,a=this.vertexData,o=t.trim,n=t.orig,h=this._anchor;let l,c,u,p;o?(c=o.x-h._x*n.width,l=c+o.width,p=o.y-h._y*n.height,u=p+o.height):(c=-h._x*n.width,l=c+n.width,p=-h._y*n.height,u=p+n.height),s[0]=i[0]*c+i[3]*p+i[6],s[1]=i[1]*c+i[4]*p+i[7],s[2]=i[2]*c+i[5]*p+i[8],s[3]=i[0]*l+i[3]*p+i[6],s[4]=i[1]*l+i[4]*p+i[7],s[5]=i[2]*l+i[5]*p+i[8],s[6]=i[0]*l+i[3]*u+i[6],s[7]=i[1]*l+i[4]*u+i[7],s[8]=i[2]*l+i[5]*u+i[8],s[9]=i[0]*c+i[3]*u+i[6],s[10]=i[1]*c+i[4]*u+i[7],s[11]=i[2]*c+i[5]*u+i[8],a[0]=s[0]/s[2],a[1]=s[1]/s[2],a[2]=s[3]/s[5],a[3]=s[4]/s[5],a[4]=s[6]/s[8],a[5]=s[7]/s[8],a[6]=s[9]/s[11],a[7]=s[10]/s[11]}calculateTrimmedVertices(){if(this.proj._affine)return void super.calculateTrimmedVertices();const t=this.transform._worldID,e=this._texture._updateID,r=this;if(r.vertexTrimmedData){if(r._transformTrimmedID===t&&this._textureTrimmedID===e)return}else r.vertexTrimmedData=new Float32Array(8);r._transformTrimmedID=t,this._textureTrimmedID=e;const i=this._texture,s=r.vertexTrimmedData,a=i.orig,o=this.tileProj?this._width:a.width,n=this.tileProj?this._height:a.height,h=this._anchor,l=this.proj.world.mat3,c=-h._x*o,u=c+o,p=-h._y*n,d=p+n;let _=1/(l[2]*c+l[5]*p+l[8]);s[0]=_*(l[0]*c+l[3]*p+l[6]),s[1]=_*(l[1]*c+l[4]*p+l[7]),_=1/(l[2]*u+l[5]*p+l[8]),s[2]=_*(l[0]*u+l[3]*p+l[6]),s[3]=_*(l[1]*u+l[4]*p+l[7]),_=1/(l[2]*u+l[5]*d+l[8]),s[4]=_*(l[0]*u+l[3]*d+l[6]),s[5]=_*(l[1]*u+l[4]*d+l[7]),_=1/(l[2]*c+l[5]*d+l[8]),s[6]=_*(l[0]*c+l[3]*d+l[6]),s[7]=_*(l[1]*c+l[4]*d+l[7])}toLocal(e,r,i,s,a=t.TRANSFORM_STEP.ALL){return A.call(this,e,r,i,s,a)}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}}const O=new s.Transform;class R extends o.TilingSprite{constructor(t,e,r){super(t,e,r),this.tileProj=new P(this.tileTransform),this.tileProj.reverseLocalOrder=!0,this.proj=new P(this.transform),this.pluginName="tilingSprite2d",this.uvRespectAnchor=!0}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}toLocal(e,r,i,s,a=t.TRANSFORM_STEP.ALL){return A.call(this,e,r,i,s,a)}_render(t){const e=this._texture;e&&e.valid&&(this.tileTransform.updateTransform(O),this.uvMatrix.update(),t.batch.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this))}}function V(){this.proj||(this.proj=new P(this.transform),this.toLocal=F.prototype.toLocal,Object.defineProperty(this,"worldTransform",{get:S,enumerable:!0,configurable:!0}))}a.Container.prototype.convertTo2d=V,l.Sprite.prototype.convertTo2d=function(){this.proj||(this.calculateVertices=N.prototype.calculateVertices,this.calculateTrimmedVertices=N.prototype.calculateTrimmedVertices,this._calculateBounds=N.prototype._calculateBounds,this.pluginName="batch2d",V.call(this))},a.Container.prototype.convertSubtreeTo2d=function(){this.convertTo2d();for(let t=0;t<this.children.length;t++)this.children[t].convertSubtreeTo2d()},h.SimpleMesh.prototype.convertTo2d=h.SimpleRope.prototype.convertTo2d=function(){this.proj||(this.calculateVertices=C.prototype.calculateVertices,this._renderDefault=C.prototype._renderDefault,"batch2d"!==this.material.pluginName&&(this.material=new n.MeshMaterial(this.material.texture,{program:e.Program.from(C.defaultVertexShader,C.defaultFragmentShader),pluginName:"batch2d"})),V.call(this))},o.TilingSprite.prototype.convertTo2d=function(){this.proj||(this.tileProj=new P(this.tileTransform),this.tileProj.reverseLocalOrder=!0,this.uvRespectAnchor=!0,this.calculateTrimmedVertices=N.prototype.calculateTrimmedVertices,this._calculateBounds=N.prototype._calculateBounds,this._render=R.prototype._render,this.pluginName="tilingSprite2d",V.call(this))};class E extends c.Text{constructor(t,e,r){super(t,e,r),E.prototype.__init.call(this),this.proj=new P(this.transform),this.pluginName="batch2d"}__init(){this.vertexData2d=null}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}}E.prototype.calculateVertices=N.prototype.calculateVertices,E.prototype.calculateTrimmedVertices=N.prototype.calculateTrimmedVertices,E.prototype._calculateBounds=N.prototype._calculateBounds;const L=new g;class B extends e.Filter{constructor(t){super("\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec3 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\nvTextureCoord = aTextureCoord;\nvMaskCoord = otherMatrix * vec3( aTextureCoord, 1.0);\n}\n","\nvarying vec3 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\nvec2 uv = vMaskCoord.xy / vMaskCoord.z;\n\nfloat clip = step(3.5,\n    step(maskClamp.x, uv.x) +\n    step(maskClamp.y, uv.y) +\n    step(uv.x, maskClamp.z) +\n    step(uv.y, maskClamp.w));\n\nvec4 original = texture2D(uSampler, vTextureCoord);\nvec4 masky = texture2D(mask, uv);\n\noriginal *= (masky.r * masky.a * alpha * clip);\n\ngl_FragColor = original;\n}\n"),B.prototype.__init.call(this),t.renderable=!1,this.maskSprite=t}__init(){this.maskMatrix=new g}apply(t,r,i,s){const a=this.maskSprite,o=this.maskSprite.texture;o.valid&&(o.uvMatrix||(o.uvMatrix=new e.TextureMatrix(o,0)),o.uvMatrix.update(),this.uniforms.npmAlpha=o.baseTexture.alphaMode?0:1,this.uniforms.mask=a.texture,this.uniforms.otherMatrix=B.calculateSpriteMatrix(r,this.maskMatrix,a).prepend(o.uvMatrix.mapCoord),this.uniforms.alpha=a.worldAlpha,this.uniforms.maskClamp=o.uvMatrix.uClampFrame,t.applyFilter(this,r,i,s))}static calculateSpriteMatrix(t,e,r){const i=r.proj,s=t.filterFrame,a=i&&!i._affine?i.world.copyTo2dOr3d(L):L.copyFrom(r.transform.worldTransform),o=r.texture.orig;return e.set(t.width,0,0,t.height,s.x,s.y),a.invert(),e.setToMult(a,e),e.scaleAndTranslate(1/o.width,1/o.height,r.anchor.x,r.anchor.y),e}}e.MaskSystem.prototype.pushSpriteMask=function(t){const{maskObject:e}=t,r=t._target;let i=this.alphaMaskPool[this.alphaMaskIndex];i||(i=this.alphaMaskPool[this.alphaMaskIndex]=[new B(e)]),i[0].resolution=this.renderer.resolution,i[0].maskSprite=e;const s=r.filterArea;r.filterArea=e.getBounds(!0),this.renderer.filter.push(r,i),r.filterArea=s,this.alphaMaskIndex++},e.Renderer.registerPlugin("tilingSprite2d",I);class q extends s.Point{constructor(t,e,r){super(t,e),this.z=r}set(t,e,r){return this.x=t||0,this.y=void 0===e?this.x:e||0,this.z=void 0===e?this.x:r||0,this}copyFrom(t){return this.set(t.x,t.y,t.z||0),this}copyTo(t){return t.set(this.x,this.y,this.z),t}}class U extends s.ObservablePoint{constructor(...t){super(...t),U.prototype.__init.call(this)}__init(){this._z=0}get z(){return this._z}set z(t){this._z!==t&&(this._z=t,this.cb.call(this.scope))}set(t,e,r){const i=t||0,s=void 0===e?i:e||0,a=void 0===e?i:r||0;return this._x===i&&this._y===s&&this._z===a||(this._x=i,this._y=s,this._z=a,this.cb.call(this.scope)),this}copyFrom(t){return this.set(t.x,t.y,t.z||0),this}copyTo(t){return t.set(this._x,this._y,this._z),t}}class X{constructor(t,e,r){X.prototype.__init.call(this),X.prototype.__init2.call(this),X.prototype.__init3.call(this),this._x=t||0,this._y=e||0,this._z=r||0,this.quaternion=new Float64Array(4),this.quaternion[3]=1,this.update()}__init(){this._quatUpdateId=-1}__init2(){this._quatDirtyId=0}__init3(){this._sign=1}get x(){return this._x}set x(t){this._x!==t&&(this._x=t,this._quatDirtyId++)}get y(){return this._y}set y(t){this._y!==t&&(this._y=t,this._quatDirtyId++)}get z(){return this._z}set z(t){this._z!==t&&(this._z=t,this._quatDirtyId++)}get pitch(){return this._x}set pitch(t){this._x!==t&&(this._x=t,this._quatDirtyId++)}get yaw(){return this._y}set yaw(t){this._y!==t&&(this._y=t,this._quatDirtyId++)}get roll(){return this._z}set roll(t){this._z!==t&&(this._z=t,this._quatDirtyId++)}set(t,e,r){const i=t||0,s=e||0,a=r||0;this._x===i&&this._y===s&&this._z===a||(this._x=i,this._y=s,this._z=a,this._quatDirtyId++)}copyFrom(t){const e=t.x,r=t.y,i=t.z;return this._x===e&&this._y===r&&this._z===i||(this._x=e,this._y=r,this._z=i,this._quatDirtyId++),this}copyTo(t){return t.set(this._x,this._y,this._z),t}equals(t){return this._x===t.x&&this._y===t.y&&this._z===t.z}clone(){return new X(this._x,this._y,this._z)}update(){if(this._quatUpdateId===this._quatDirtyId)return!1;this._quatUpdateId=this._quatDirtyId;const t=Math.cos(this._x/2),e=Math.cos(this._y/2),r=Math.cos(this._z/2),i=this._sign,s=i*Math.sin(this._x/2),a=i*Math.sin(this._y/2),o=i*Math.sin(this._z/2),n=this.quaternion;return n[0]=s*e*r+t*a*o,n[1]=t*a*r-s*e*o,n[2]=t*e*o+s*a*r,n[3]=t*e*r-s*a*o,!0}}class k{constructor(t,e,r,i,s){this.cb=t,this.scope=e,k.prototype.__init.call(this),k.prototype.__init2.call(this),k.prototype.__init3.call(this),this._x=r||0,this._y=i||0,this._z=s||0,this.quaternion=new Float64Array(4),this.quaternion[3]=1,this.update()}__init(){this._quatUpdateId=-1}__init2(){this._quatDirtyId=0}__init3(){this._sign=1}get x(){return this._x}set x(t){this._x!==t&&(this._x=t,this._quatDirtyId++,this.cb.call(this.scope))}get y(){return this._y}set y(t){this._y!==t&&(this._y=t,this._quatDirtyId++,this.cb.call(this.scope))}get z(){return this._z}set z(t){this._z!==t&&(this._z=t,this._quatDirtyId++,this.cb.call(this.scope))}get pitch(){return this._x}set pitch(t){this._x!==t&&(this._x=t,this._quatDirtyId++,this.cb.call(this.scope))}get yaw(){return this._y}set yaw(t){this._y!==t&&(this._y=t,this._quatDirtyId++,this.cb.call(this.scope))}get roll(){return this._z}set roll(t){this._z!==t&&(this._z=t,this._quatDirtyId++,this.cb.call(this.scope))}set(t,e,r){const i=t||0,s=e||0,a=r||0;return this._x===i&&this._y===s&&this._z===a||(this._x=i,this._y=s,this._z=a,this._quatDirtyId++,this.cb.call(this.scope)),this}copyFrom(t){const e=t.x,r=t.y,i=t.z;return this._x===e&&this._y===r&&this._z===i||(this._x=e,this._y=r,this._z=i,this._quatDirtyId++,this.cb.call(this.scope)),this}copyTo(t){return t.set(this._x,this._y,this._z),t}equals(t){return this._x===t.x&&this._y===t.y&&this._z===t.z}clone(){return new X(this._x,this._y,this._z)}update(){if(this._quatUpdateId===this._quatDirtyId)return!1;this._quatUpdateId=this._quatDirtyId;const t=Math.cos(this._x/2),e=Math.cos(this._y/2),r=Math.cos(this._z/2),i=this._sign,s=i*Math.sin(this._x/2),a=i*Math.sin(this._y/2),o=i*Math.sin(this._z/2),n=this.quaternion;return n[0]=s*e*r+t*a*o,n[1]=t*a*r-s*e*o,n[2]=t*e*o+s*a*r,n[3]=t*e*r-s*a*o,!0}}const G=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];class Y{static __initStatic(){this.IDENTITY=new Y}static __initStatic2(){this.TEMP_MATRIX=new Y}__init(){this.floatArray=null}__init2(){this._dirtyId=0}__init3(){this._updateId=-1}__init4(){this._mat4inv=null}__init5(){this.cacheInverse=!1}constructor(t){Y.prototype.__init.call(this),Y.prototype.__init2.call(this),Y.prototype.__init3.call(this),Y.prototype.__init4.call(this),Y.prototype.__init5.call(this),this.mat4=new Float64Array(t||G)}get a(){return this.mat4[0]/this.mat4[15]}set a(t){this.mat4[0]=t*this.mat4[15]}get b(){return this.mat4[1]/this.mat4[15]}set b(t){this.mat4[1]=t*this.mat4[15]}get c(){return this.mat4[4]/this.mat4[15]}set c(t){this.mat4[4]=t*this.mat4[15]}get d(){return this.mat4[5]/this.mat4[15]}set d(t){this.mat4[5]=t*this.mat4[15]}get tx(){return this.mat4[12]/this.mat4[15]}set tx(t){this.mat4[12]=t*this.mat4[15]}get ty(){return this.mat4[13]/this.mat4[15]}set ty(t){this.mat4[13]=t*this.mat4[15]}set(t,e,r,i,s,a){const o=this.mat4;return o[0]=t,o[1]=e,o[2]=0,o[3]=0,o[4]=r,o[5]=i,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1,o[11]=0,o[12]=s,o[13]=a,o[14]=0,o[15]=1,this}toArray(t,e){this.floatArray||(this.floatArray=new Float32Array(9));const r=e||this.floatArray,i=this.mat4;return t?(r[0]=i[0],r[1]=i[1],r[2]=i[3],r[3]=i[4],r[4]=i[5],r[5]=i[7],r[6]=i[12],r[7]=i[13],r[8]=i[15]):(r[0]=i[0],r[1]=i[4],r[2]=i[12],r[3]=i[2],r[4]=i[6],r[5]=i[13],r[6]=i[3],r[7]=i[7],r[8]=i[15]),r}setToTranslation(t,e,r){const i=this.mat4;i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=t,i[13]=e,i[14]=r,i[15]=1}setToRotationTranslationScale(t,e,r,i,s,a,o){const n=this.mat4,h=t[0],l=t[1],c=t[2],u=t[3],p=h+h,d=l+l,_=c+c,m=h*p,y=h*d,x=h*_,f=l*d,v=l*_,g=c*_,T=u*p,w=u*d,I=u*_;return n[0]=(1-(f+g))*s,n[1]=(y+I)*s,n[2]=(x-w)*s,n[3]=0,n[4]=(y-I)*a,n[5]=(1-(m+g))*a,n[6]=(v+T)*a,n[7]=0,n[8]=(x+w)*o,n[9]=(v-T)*o,n[10]=(1-(m+f))*o,n[11]=0,n[12]=e,n[13]=r,n[14]=i,n[15]=1,n}apply(t,e){e=e||new q;const r=this.mat4,i=t.x,s=t.y,a=t.z||0,o=1/(r[3]*i+r[7]*s+r[11]*a+r[15]);return e.x=o*(r[0]*i+r[4]*s+r[8]*a+r[12]),e.y=o*(r[1]*i+r[5]*s+r[9]*a+r[13]),e.z=o*(r[2]*i+r[6]*s+r[10]*a+r[14]),e}translate(t,e,r){const i=this.mat4;return i[12]=i[0]*t+i[4]*e+i[8]*r+i[12],i[13]=i[1]*t+i[5]*e+i[9]*r+i[13],i[14]=i[2]*t+i[6]*e+i[10]*r+i[14],i[15]=i[3]*t+i[7]*e+i[11]*r+i[15],this}scale(t,e,r){const i=this.mat4;return i[0]*=t,i[1]*=t,i[2]*=t,i[3]*=t,i[4]*=e,i[5]*=e,i[6]*=e,i[7]*=e,void 0!==r&&(i[8]*=r,i[9]*=r,i[10]*=r,i[11]*=r),this}scaleAndTranslate(t,e,r,i,s,a){const o=this.mat4;o[0]=t*o[0]+i*o[3],o[1]=e*o[1]+s*o[3],o[2]=r*o[2]+a*o[3],o[4]=t*o[4]+i*o[7],o[5]=e*o[5]+s*o[7],o[6]=r*o[6]+a*o[7],o[8]=t*o[8]+i*o[11],o[9]=e*o[9]+s*o[11],o[10]=r*o[10]+a*o[11],o[12]=t*o[12]+i*o[15],o[13]=e*o[13]+s*o[15],o[14]=r*o[14]+a*o[15]}applyInverse(t,e){e=e||new q,this._mat4inv||(this._mat4inv=new Float64Array(16));const r=this._mat4inv,i=this.mat4,s=t.x,a=t.y;let o=t.z||0;this.cacheInverse&&this._updateId===this._dirtyId||(this._updateId=this._dirtyId,Y.glMatrixMat4Invert(r,i));const n=1/(r[3]*s+r[7]*a+r[11]*o+r[15]),h=n*(r[0]*s+r[4]*a+r[8]*o+r[12]),l=n*(r[1]*s+r[5]*a+r[9]*o+r[13]),c=n*(r[2]*s+r[6]*a+r[10]*o+r[14]);o+=1;const u=1/(r[3]*s+r[7]*a+r[11]*o+r[15]),p=u*(r[0]*s+r[4]*a+r[8]*o+r[12]),d=u*(r[1]*s+r[5]*a+r[9]*o+r[13]),_=u*(r[2]*s+r[6]*a+r[10]*o+r[14]);Math.abs(c-_)<1e-10&&e.set(NaN,NaN,0);const m=(0-c)/(_-c);return e.set((p-h)*m+h,(d-l)*m+l,0),e}invert(){return Y.glMatrixMat4Invert(this.mat4,this.mat4),this}invertCopyTo(t){this._mat4inv||(this._mat4inv=new Float64Array(16));const e=this._mat4inv,r=this.mat4;this.cacheInverse&&this._updateId===this._dirtyId||(this._updateId=this._dirtyId,Y.glMatrixMat4Invert(e,r)),t.mat4.set(e)}identity(){const t=this.mat4;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}clone(){return new Y(this.mat4)}copyTo3d(t){const e=this.mat4,r=t.mat4;return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],t}copyTo2d(t){const e=this.mat4,r=t.mat3;return r[0]=e[0],r[1]=e[1],r[2]=e[3],r[3]=e[4],r[4]=e[5],r[5]=e[7],r[6]=e[12],r[7]=e[13],r[8]=e[15],t}copyTo2dOr3d(t){return t instanceof g?this.copyTo2d(t):this.copyTo3d(t)}copyTo(e,r,i){const s=this.mat4,a=1/s[15],o=s[12]*a,n=s[13]*a;if(e.a=(s[0]-s[3]*o)*a,e.b=(s[1]-s[3]*n)*a,e.c=(s[4]-s[7]*o)*a,e.d=(s[5]-s[7]*n)*a,e.tx=o,e.ty=n,r>=2){let s=e.a*e.d-e.b*e.c;i||(s=Math.abs(s)),r===t.AFFINE.POINT?(s=s>0?1:-1,e.a=s,e.b=0,e.c=0,e.d=s):r===t.AFFINE.AXIS_X?(s/=Math.sqrt(e.b*e.b+e.d*e.d),e.c=0,e.d=s):r===t.AFFINE.AXIS_Y&&(s/=Math.sqrt(e.a*e.a+e.c*e.c),e.a=s,e.c=0)}return e}copyFrom(t){const e=this.mat4;return e[0]=t.a,e[1]=t.b,e[2]=0,e[3]=0,e[4]=t.c,e[5]=t.d,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t.tx,e[13]=t.ty,e[14]=0,e[15]=1,this._dirtyId++,this}setToMultLegacy(t,e){const r=this.mat4,i=e.mat4,s=t.a,a=t.b,o=t.c,n=t.d,h=t.tx,l=t.ty;let c=i[0],u=i[1],p=i[2],d=i[3];return r[0]=c*s+u*o+d*h,r[1]=c*a+u*n+d*l,r[2]=p,r[3]=d,c=i[4],u=i[5],p=i[6],d=i[7],r[4]=c*s+u*o+d*h,r[5]=c*a+u*n+d*l,r[6]=p,r[7]=d,c=i[8],u=i[9],p=i[10],d=i[11],r[8]=c*s+u*o+d*h,r[9]=c*a+u*n+d*l,r[10]=p,r[11]=d,c=i[12],u=i[13],p=i[14],d=i[15],r[12]=c*s+u*o+d*h,r[13]=c*a+u*n+d*l,r[14]=p,r[15]=d,this._dirtyId++,this}setToMultLegacy2(t,e){const r=this.mat4,i=t.mat4,s=i[0],a=i[1],o=i[2],n=i[3],h=i[4],l=i[5],c=i[6],u=i[7],p=e.a,d=e.b,_=e.c,m=e.d,y=e.tx,x=e.ty;return r[0]=p*s+d*h,r[1]=p*a+d*l,r[2]=p*o+d*c,r[3]=p*n+d*u,r[4]=_*s+m*h,r[5]=_*a+m*l,r[6]=_*o+m*c,r[7]=_*n+m*u,r[8]=i[8],r[9]=i[9],r[10]=i[10],r[11]=i[11],r[12]=y*s+x*h+i[12],r[13]=y*a+x*l+i[13],r[14]=y*o+x*c+i[14],r[15]=y*n+x*u+i[15],this._dirtyId++,this}setToMult(t,e){return Y.glMatrixMat4Multiply(this.mat4,t.mat4,e.mat4),this._dirtyId++,this}prepend(t){t.mat4?this.setToMult(t,this):this.setToMultLegacy(t,this)}static glMatrixMat4Invert(t,e){const r=e[0],i=e[1],s=e[2],a=e[3],o=e[4],n=e[5],h=e[6],l=e[7],c=e[8],u=e[9],p=e[10],d=e[11],_=e[12],m=e[13],y=e[14],x=e[15],f=r*n-i*o,v=r*h-s*o,g=r*l-a*o,T=i*h-s*n,w=i*l-a*n,I=s*l-a*h,M=c*m-u*_,b=c*y-p*_,j=c*x-d*_,D=u*y-p*m,P=u*x-d*m,S=p*x-d*y;let F=f*S-v*P+g*D+T*j-w*b+I*M;return F?(F=1/F,t[0]=(n*S-h*P+l*D)*F,t[1]=(s*P-i*S-a*D)*F,t[2]=(m*I-y*w+x*T)*F,t[3]=(p*w-u*I-d*T)*F,t[4]=(h*j-o*S-l*b)*F,t[5]=(r*S-s*j+a*b)*F,t[6]=(y*g-_*I-x*v)*F,t[7]=(c*I-p*g+d*v)*F,t[8]=(o*P-n*j+l*M)*F,t[9]=(i*j-r*P-a*M)*F,t[10]=(_*w-m*g+x*f)*F,t[11]=(u*g-c*w-d*f)*F,t[12]=(n*b-o*D-h*M)*F,t[13]=(r*D-i*b+s*M)*F,t[14]=(m*v-_*T-y*f)*F,t[15]=(c*T-u*v+p*f)*F,t):null}static glMatrixMat4Multiply(t,e,r){const i=e[0],s=e[1],a=e[2],o=e[3],n=e[4],h=e[5],l=e[6],c=e[7],u=e[8],p=e[9],d=e[10],_=e[11],m=e[12],y=e[13],x=e[14],f=e[15];let v=r[0],g=r[1],T=r[2],w=r[3];return t[0]=v*i+g*n+T*u+w*m,t[1]=v*s+g*h+T*p+w*y,t[2]=v*a+g*l+T*d+w*x,t[3]=v*o+g*c+T*_+w*f,v=r[4],g=r[5],T=r[6],w=r[7],t[4]=v*i+g*n+T*u+w*m,t[5]=v*s+g*h+T*p+w*y,t[6]=v*a+g*l+T*d+w*x,t[7]=v*o+g*c+T*_+w*f,v=r[8],g=r[9],T=r[10],w=r[11],t[8]=v*i+g*n+T*u+w*m,t[9]=v*s+g*h+T*p+w*y,t[10]=v*a+g*l+T*d+w*x,t[11]=v*o+g*c+T*_+w*f,v=r[12],g=r[13],T=r[14],w=r[15],t[12]=v*i+g*n+T*u+w*m,t[13]=v*s+g*h+T*p+w*y,t[14]=v*a+g*l+T*d+w*x,t[15]=v*o+g*c+T*_+w*f,t}}Y.__initStatic(),Y.__initStatic2();const Q=new Y;class W extends y{constructor(t,e){super(t,e),W.prototype.__init.call(this),W.prototype.__init2.call(this),W.prototype.__init3.call(this),W.prototype.__init4.call(this),W.prototype.__init5.call(this),W.prototype.__init6.call(this),this.local=new Y,this.world=new Y,this.local.cacheInverse=!0,this.world.cacheInverse=!0,this.position._z=0,this.scale._z=1,this.pivot._z=0}__init(){this.cameraMatrix=null}__init2(){this._cameraMode=!1}get cameraMode(){return this._cameraMode}set cameraMode(t){this._cameraMode!==t&&(this._cameraMode=t,this.euler._sign=this._cameraMode?-1:1,this.euler._quatDirtyId++,t&&(this.cameraMatrix=new Y))}__init3(){this.position=new U(this.onChange,this,0,0)}__init4(){this.scale=new U(this.onChange,this,1,1)}__init5(){this.euler=new k(this.onChange,this,0,0,0)}__init6(){this.pivot=new U(this.onChange,this,0,0)}onChange(){this._projID++}clear(){this.cameraMatrix&&this.cameraMatrix.identity(),this.position.set(0,0,0),this.scale.set(1,1,1),this.euler.set(0,0,0),this.pivot.set(0,0,0),super.clear()}updateLocalTransform(t){if(0===this._projID)return void this.local.copyFrom(t);const e=this.local,r=this.euler,i=this.position,s=this.scale,a=this.pivot;if(r.update(),!this.cameraMode)return e.setToRotationTranslationScale(r.quaternion,i._x,i._y,i._z,s._x,s._y,s._z),e.translate(-a._x,-a._y,-a._z),void e.setToMultLegacy(t,e);e.setToMultLegacy(t,this.cameraMatrix),e.translate(a._x,a._y,a._z),e.scale(1/s._x,1/s._y,1/s._z),Q.setToRotationTranslationScale(r.quaternion,0,0,0,1,1,1),e.setToMult(e,Q),e.translate(-i._x,-i._y,-i._z),this.local._dirtyId++}}function J(){return this.proj.affine?this.transform.worldTransform:this.proj.world}class H extends a.Container{constructor(){super(),this.proj=new W(this.transform)}isFrontFace(t=!1){t&&(this._recursivePostUpdateTransform(),this.displayObjectUpdateTransform());const e=this.proj.world.mat4,r=e[0]*e[15]-e[3]*e[12],i=e[1]*e[15]-e[3]*e[13],s=e[4]*e[15]-e[7]*e[12];return r*(e[5]*e[15]-e[7]*e[13])-s*i>0}getDepth(t=!1){t&&(this._recursivePostUpdateTransform(),this.displayObjectUpdateTransform());const e=this.proj.world.mat4;return e[14]/e[15]}toLocal(e,r,i,s,a=t.TRANSFORM_STEP.ALL){return r&&(e=r.toGlobal(e,i,s)),s||this._recursivePostUpdateTransform(),a===t.TRANSFORM_STEP.ALL?(s||this.displayObjectUpdateTransform(),this.proj.affine?this.transform.worldTransform.applyInverse(e,i):this.proj.world.applyInverse(e,i)):(this.parent?i=this.parent.worldTransform.applyInverse(e,i):(i.x=e.x,i.y=e.y,i.z=e.z),a===t.TRANSFORM_STEP.NONE||(i=this.transform.localTransform.applyInverse(i,i),a===t.TRANSFORM_STEP.PROJ&&this.proj.cameraMode&&(i=this.proj.cameraMatrix.applyInverse(i,i))),i)}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}get position3d(){return this.proj.position}set position3d(t){this.proj.position.copyFrom(t)}get scale3d(){return this.proj.scale}set scale3d(t){this.proj.scale.copyFrom(t)}get euler(){return this.proj.euler}set euler(t){this.proj.euler.copyFrom(t)}get pivot3d(){return this.proj.pivot}set pivot3d(t){this.proj.pivot.copyFrom(t)}}const K=H.prototype.toLocal,Z=H.prototype.getDepth,$=H.prototype.isFrontFace;class tt extends H{constructor(){super(),tt.prototype.__init.call(this),tt.prototype.__init2.call(this),tt.prototype.__init3.call(this),tt.prototype.__init4.call(this),this.proj.cameraMode=!0,this.setPlanes(400,10,1e4,!1)}__init(){this._far=0}__init2(){this._near=0}__init3(){this._focus=0}__init4(){this._orthographic=!1}get far(){return this._far}get near(){return this._near}get focus(){return this._focus}get ortographic(){return this._orthographic}setPlanes(t,e=10,r=1e4,i=!1){this._focus=t,this._near=e,this._far=r,this._orthographic=i;const s=this.proj,a=s.cameraMatrix.mat4;s._projID++,a[10]=1/(r-e),a[14]=(t-e)/(r-e),this._orthographic?a[11]=0:a[11]=1/t}}class et extends n.Mesh{constructor(t,e,r,i){super(t,e,r,i),et.prototype.__init.call(this),this.proj=new W(this.transform)}__init(){this.vertexData2d=null}calculateVertices(){if(this.proj._affine)return this.vertexData2d=null,void super.calculateVertices();const t=this.geometry,e=t.buffers[0].data,r=this;if(t.vertexDirtyId===r.vertexDirty&&r._transformID===r.transform._worldID)return;r._transformID=r.transform._worldID,r.vertexData.length!==e.length&&(r.vertexData=new Float32Array(e.length)),this.vertexData2d&&this.vertexData2d.length===3*e.length/2||(this.vertexData2d=new Float32Array(3*e.length));const i=this.proj.world.mat4,s=this.vertexData2d,a=r.vertexData;for(let t=0;t<a.length/2;t++){const r=e[2*t],o=e[2*t+1],n=i[0]*r+i[4]*o+i[12],h=i[1]*r+i[5]*o+i[13],l=i[3]*r+i[7]*o+i[15];s[3*t]=n,s[3*t+1]=h,s[3*t+2]=l,a[2*t]=n/l,a[2*t+1]=h/l}r.vertexDirty=t.vertexDirtyId}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}toLocal(e,r,i,s,a=t.TRANSFORM_STEP.ALL){return K.call(this,e,r,i,s,a)}isFrontFace(t){return $.call(this,t)}getDepth(t){return Z.call(this,t)}get position3d(){return this.proj.position}set position3d(t){this.proj.position.copyFrom(t)}get scale3d(){return this.proj.scale}set scale3d(t){this.proj.scale.copyFrom(t)}get euler(){return this.proj.euler}set euler(t){this.proj.euler.copyFrom(t)}get pivot3d(){return this.proj.pivot}set pivot3d(t){this.proj.pivot.copyFrom(t)}}et.prototype._renderDefault=C.prototype._renderDefault;class rt extends et{constructor(t,r,i,s,a){super(new n.MeshGeometry(r,i,s),new n.MeshMaterial(t,{program:e.Program.from(C.defaultVertexShader,C.defaultFragmentShader),pluginName:"batch2d"}),null,a),rt.prototype.__init2.call(this),this.geometry.getBuffer("aVertexPosition").static=!1}__init2(){this.autoUpdate=!0}get vertices(){return this.geometry.getBuffer("aVertexPosition").data}set vertices(t){this.geometry.getBuffer("aVertexPosition").data=t}_render(t){this.autoUpdate&&this.geometry.getBuffer("aVertexPosition").update(),super._render(t)}}class it extends l.Sprite{constructor(t){super(t),it.prototype.__init.call(this),it.prototype.__init2.call(this),it.prototype.__init3.call(this),this.proj=new W(this.transform),this.pluginName="batch2d"}__init(){this.vertexData2d=null}__init2(){this.culledByFrustrum=!1}__init3(){this.trimmedCulledByFrustrum=!1}calculateVertices(){const t=this._texture;if(this.proj._affine)return this.vertexData2d=null,void super.calculateVertices();this.vertexData2d||(this.vertexData2d=new Float32Array(12));const e=this.transform._worldID,r=t._updateID;if(this._transformID===e&&this._textureID===r)return;this._textureID!==r&&(this.uvs=t._uvs.uvsFloat32),this._transformID=e,this._textureID=r;const i=this.proj.world.mat4,s=this.vertexData2d,a=this.vertexData,o=t.trim,n=t.orig,h=this._anchor;let l,c,u,p;o?(c=o.x-h._x*n.width,l=c+o.width,p=o.y-h._y*n.height,u=p+o.height):(c=-h._x*n.width,l=c+n.width,p=-h._y*n.height,u=p+n.height);let d,_=!1;s[0]=i[0]*c+i[4]*p+i[12],s[1]=i[1]*c+i[5]*p+i[13],d=i[2]*c+i[6]*p+i[14],s[2]=i[3]*c+i[7]*p+i[15],_=_||d<0,s[3]=i[0]*l+i[4]*p+i[12],s[4]=i[1]*l+i[5]*p+i[13],d=i[2]*l+i[6]*p+i[14],s[5]=i[3]*l+i[7]*p+i[15],_=_||d<0,s[6]=i[0]*l+i[4]*u+i[12],s[7]=i[1]*l+i[5]*u+i[13],d=i[2]*l+i[6]*u+i[14],s[8]=i[3]*l+i[7]*u+i[15],_=_||d<0,s[9]=i[0]*c+i[4]*u+i[12],s[10]=i[1]*c+i[5]*u+i[13],d=i[2]*c+i[6]*u+i[14],s[11]=i[3]*c+i[7]*u+i[15],_=_||d<0,this.culledByFrustrum=_,a[0]=s[0]/s[2],a[1]=s[1]/s[2],a[2]=s[3]/s[5],a[3]=s[4]/s[5],a[4]=s[6]/s[8],a[5]=s[7]/s[8],a[6]=s[9]/s[11],a[7]=s[10]/s[11]}calculateTrimmedVertices(){if(this.proj._affine)return void super.calculateTrimmedVertices();const t=this.transform._worldID,e=this._texture._updateID,r=this;if(r.vertexTrimmedData){if(r._transformTrimmedID===t&&this._textureTrimmedID===e)return}else r.vertexTrimmedData=new Float32Array(8);r._transformTrimmedID=t,this._textureTrimmedID=e;const i=this._texture,s=r.vertexTrimmedData,a=i.orig,o=this._anchor,n=this.proj.world.mat4,h=-o._x*a.width,l=h+a.width,c=-o._y*a.height,u=c+a.height;let p,d=!1,_=1/(n[3]*h+n[7]*c+n[15]);s[0]=_*(n[0]*h+n[4]*c+n[12]),s[1]=_*(n[1]*h+n[5]*c+n[13]),p=n[2]*h+n[6]*c+n[14],d=d||p<0,_=1/(n[3]*l+n[7]*c+n[15]),s[2]=_*(n[0]*l+n[4]*c+n[12]),s[3]=_*(n[1]*l+n[5]*c+n[13]),p=n[2]*l+n[6]*c+n[14],d=d||p<0,_=1/(n[3]*l+n[7]*u+n[15]),s[4]=_*(n[0]*l+n[4]*u+n[12]),s[5]=_*(n[1]*l+n[5]*u+n[13]),p=n[2]*l+n[6]*u+n[14],d=d||p<0,_=1/(n[3]*h+n[7]*u+n[15]),s[6]=_*(n[0]*h+n[4]*u+n[12]),s[7]=_*(n[1]*h+n[5]*u+n[13]),p=n[2]*h+n[6]*u+n[14],d=d||p<0,this.culledByFrustrum=d}_calculateBounds(){if(this.calculateVertices(),this.culledByFrustrum)return;const t=this._texture.trim,e=this._texture.orig;!t||t.width===e.width&&t.height===e.height?this._bounds.addQuad(this.vertexData):(this.calculateTrimmedVertices(),this.trimmedCulledByFrustrum||this._bounds.addQuad(this.vertexTrimmedData))}_render(t){this.calculateVertices(),this.culledByFrustrum||(t.batch.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this))}containsPoint(t){return!this.culledByFrustrum&&super.containsPoint(t)}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}toLocal(e,r,i,s,a=t.TRANSFORM_STEP.ALL){return K.call(this,e,r,i,s,a)}isFrontFace(t){return $.call(this,t)}getDepth(t){return Z.call(this,t)}get position3d(){return this.proj.position}set position3d(t){this.proj.position.copyFrom(t)}get scale3d(){return this.proj.scale}set scale3d(t){this.proj.scale.copyFrom(t)}get euler(){return this.proj.euler}set euler(t){this.proj.euler.copyFrom(t)}get pivot3d(){return this.proj.pivot}set pivot3d(t){this.proj.pivot.copyFrom(t)}}const st={worldTransform:{get:J,enumerable:!0,configurable:!0},position3d:{get(){return this.proj.position},set(t){this.proj.position.copy(t)}},scale3d:{get(){return this.proj.scale},set(t){this.proj.scale.copy(t)}},pivot3d:{get(){return this.proj.pivot},set(t){this.proj.pivot.copy(t)}},euler:{get(){return this.proj.euler},set(t){this.proj.euler.copy(t)}}};function at(){this.proj||(this.proj=new W(this.transform),this.toLocal=H.prototype.toLocal,this.isFrontFace=H.prototype.isFrontFace,this.getDepth=H.prototype.getDepth,Object.defineProperties(this,st))}a.Container.prototype.convertTo3d=at,l.Sprite.prototype.convertTo3d=function(){this.proj||(this.calculateVertices=it.prototype.calculateVertices,this.calculateTrimmedVertices=it.prototype.calculateTrimmedVertices,this._calculateBounds=it.prototype._calculateBounds,this.containsPoint=it.prototype.containsPoint,this.pluginName="batch2d",at.call(this))},a.Container.prototype.convertSubtreeTo3d=function(){this.convertTo3d();for(let t=0;t<this.children.length;t++)this.children[t].convertSubtreeTo3d()},h.SimpleMesh.prototype.convertTo3d=h.SimpleRope.prototype.convertTo3d=function(){this.proj||(this.calculateVertices=et.prototype.calculateVertices,this._renderDefault=et.prototype._renderDefault,"batch2d"!==this.material.pluginName&&(this.material=new n.MeshMaterial(this.material.texture,{program:e.Program.from(C.defaultVertexShader,C.defaultFragmentShader),pluginName:"batch2d"})),at.call(this))};class ot extends c.Text{constructor(t,e,r){super(t,e,r),ot.prototype.__init.call(this),this.proj=new W(this.transform),this.pluginName="batch2d"}__init(){this.vertexData2d=null}get worldTransform(){return this.proj.affine?this.transform.worldTransform:this.proj.world}toLocal(e,r,i,s,a=t.TRANSFORM_STEP.ALL){return K.call(this,e,r,i,s,a)}isFrontFace(t){return $.call(this,t)}getDepth(t){return Z.call(this,t)}get position3d(){return this.proj.position}set position3d(t){this.proj.position.copyFrom(t)}get scale3d(){return this.proj.scale}set scale3d(t){this.proj.scale.copyFrom(t)}get euler(){return this.proj.euler}set euler(t){this.proj.euler.copyFrom(t)}get pivot3d(){return this.proj.pivot}set pivot3d(t){this.proj.pivot.copyFrom(t)}}var nt;ot.prototype.calculateVertices=it.prototype.calculateVertices,ot.prototype.calculateTrimmedVertices=it.prototype.calculateTrimmedVertices,ot.prototype._calculateBounds=it.prototype._calculateBounds,ot.prototype.containsPoint=it.prototype.containsPoint,ot.prototype._render=it.prototype._render;class ht extends e.Geometry{constructor(t=!1){super(),this._buffer=new e.Buffer(null,t,!1),this._indexBuffer=new e.Buffer(null,t,!0),this.addAttribute("aVertexPosition",this._buffer,2,!1,r.TYPES.FLOAT).addAttribute("aTrans1",this._buffer,3,!1,r.TYPES.FLOAT).addAttribute("aTrans2",this._buffer,3,!1,r.TYPES.FLOAT).addAttribute("aSamplerSize",this._buffer,2,!1,r.TYPES.FLOAT).addAttribute("aFrame",this._buffer,4,!1,r.TYPES.FLOAT).addAttribute("aColor",this._buffer,4,!0,r.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId",this._buffer,1,!0,r.TYPES.FLOAT).addIndex(this._indexBuffer)}}class lt{static create(t){const{vertex:r,fragment:a,vertexSize:o,geometryClass:n}=Object.assign({vertex:"precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec3 aTrans1;\nattribute vec3 aTrans2;\nattribute vec2 aSamplerSize;\nattribute vec4 aFrame;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\n\nvarying vec2 vertexPosition;\nvarying vec3 vTrans1;\nvarying vec3 vTrans2;\nvarying vec2 vSamplerSize;\nvarying vec4 vFrame;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\ngl_Position.z = 0.0;\n\nvertexPosition = aVertexPosition;\nvTrans1 = aTrans1;\nvTrans2 = aTrans2;\nvTextureId = aTextureId;\nvColor = aColor;\nvSamplerSize = aSamplerSize;\nvFrame = aFrame;\n}\n",fragment:"precision highp float;\nvarying vec2 vertexPosition;\nvarying vec3 vTrans1;\nvarying vec3 vTrans2;\nvarying vec2 vSamplerSize;\nvarying vec4 vFrame;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nuniform sampler2D uSamplers[%count%];\nuniform vec4 distortion;\n\nvoid main(void){\nvec2 surface;\nvec2 surface2;\n\nfloat vx = vertexPosition.x;\nfloat vy = vertexPosition.y;\nfloat dx = distortion.x;\nfloat dy = distortion.y;\nfloat revx = distortion.z;\nfloat revy = distortion.w;\n\nif (distortion.x == 0.0) {\nsurface.x = vx;\nsurface.y = vy / (1.0 + dy * vx);\nsurface2 = surface;\n} else\nif (distortion.y == 0.0) {\nsurface.y = vy;\nsurface.x = vx / (1.0 + dx * vy);\nsurface2 = surface;\n} else {\nfloat c = vy * dx - vx * dy;\nfloat b = (c + 1.0) * 0.5;\nfloat b2 = (-c + 1.0) * 0.5;\nfloat d = b * b + vx * dy;\nif (d < -0.00001) {\n    discard;\n}\nd = sqrt(max(d, 0.0));\nsurface.x = (- b + d) * revy;\nsurface2.x = (- b - d) * revy;\nsurface.y = (- b2 + d) * revx;\nsurface2.y = (- b2 - d) * revx;\n}\n\nvec2 uv;\nuv.x = vTrans1.x * surface.x + vTrans1.y * surface.y + vTrans1.z;\nuv.y = vTrans2.x * surface.x + vTrans2.y * surface.y + vTrans2.z;\n\nvec2 pixels = uv * vSamplerSize;\n\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\npixels.y < vFrame.y || pixels.y > vFrame.w) {\nuv.x = vTrans1.x * surface2.x + vTrans1.y * surface2.y + vTrans1.z;\nuv.y = vTrans2.x * surface2.x + vTrans2.y * surface2.y + vTrans2.z;\npixels = uv * vSamplerSize;\n\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\n   pixels.y < vFrame.y || pixels.y > vFrame.w) {\n   discard;\n}\n}\n\nvec4 edge;\nedge.xy = clamp(pixels - vFrame.xy + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\nedge.zw = clamp(vFrame.zw - pixels + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\n\nfloat alpha = 1.0; //edge.x * edge.y * edge.z * edge.w;\nvec4 rColor = vColor * alpha;\n\nfloat textureId = floor(vTextureId+0.5);\nvec2 vTextureCoord = uv;\nvec4 color;\n%forloop%\ngl_FragColor = color * rColor;\n}",geometryClass:ht,vertexSize:16},t);return nt=class extends x{constructor(t){super(t),nt.prototype.__init.call(this),nt.prototype.__init2.call(this),nt.prototype.__init3.call(this),this.shaderGenerator=new e.BatchShaderGenerator(r,a),this.geometryClass=n,this.vertexSize=o}__init(){this.defUniforms={translationMatrix:new s.Matrix,distortion:new Float32Array([0,0,1/0,1/0])}}__init2(){this.size=1e3}__init3(){this.forceMaxTextures=1}getUniforms(t){const{proj:e}=t;return null!==e.surface?e.uniforms:null!==e._activeProjection?e._activeProjection.uniforms:this.defUniforms}packInterleavedGeometry(t,e,r,s,a){const{uint32View:o,float32View:n}=e,h=s/this.vertexSize,l=t.indices,c=t.vertexData,u=t._texture._frame,p=t.aTrans,{_batchLocation:d,realWidth:_,realHeight:m,resolution:y}=t._texture.baseTexture,x=Math.min(t.worldAlpha,1),f=x<1&&t._texture.baseTexture.alphaMode?i.premultiplyTint(t._tintRGB,x):t._tintRGB+(255*x<<24);for(let t=0;t<c.length;t+=2)n[s]=c[t],n[s+1]=c[t+1],n[s+2]=p.a,n[s+3]=p.c,n[s+4]=p.tx,n[s+5]=p.b,n[s+6]=p.d,n[s+7]=p.ty,n[s+8]=_,n[s+9]=m,n[s+10]=u.x*y,n[s+11]=u.y*y,n[s+12]=(u.x+u.width)*y,n[s+13]=(u.y+u.height)*y,o[s+14]=f,n[s+15]=d,s+=16;for(let t=0;t<l.length;t++)r[a++]=h+l[t]}}}}const ct=[new s.Point,new s.Point,new s.Point,new s.Point],ut=[0,0,0,0];class pt{constructor(){pt.prototype.__init.call(this),pt.prototype.__init2.call(this),pt.prototype.__init3.call(this),pt.prototype.__init4.call(this)}__init(){this.surfaceID="default"}__init2(){this._updateID=0}__init3(){this.vertexSrc=""}__init4(){this.fragmentSrc=""}fillUniforms(t){}clear(){}boundsQuad(t,e,r){let i=e[0],s=e[1],a=e[0],o=e[1];for(let t=2;t<8;t+=2)i>e[t]&&(i=e[t]),a<e[t]&&(a=e[t]),s>e[t+1]&&(s=e[t+1]),o<e[t+1]&&(o=e[t+1]);if(ct[0].set(i,s),this.apply(ct[0],ct[0]),ct[1].set(a,s),this.apply(ct[1],ct[1]),ct[2].set(a,o),this.apply(ct[2],ct[2]),ct[3].set(i,o),this.apply(ct[3],ct[3]),r)r.apply(ct[0],ct[0]),r.apply(ct[1],ct[1]),r.apply(ct[2],ct[2]),r.apply(ct[3],ct[3]),e[0]=ct[0].x,e[1]=ct[0].y,e[2]=ct[1].x,e[3]=ct[1].y,e[4]=ct[2].x,e[5]=ct[2].y,e[6]=ct[3].x,e[7]=ct[3].y;else{for(let t=1;t<=3;t++)if(ct[t].y<ct[0].y||ct[t].y===ct[0].y&&ct[t].x<ct[0].x){const e=ct[0];ct[0]=ct[t],ct[t]=e}for(let t=1;t<=3;t++)ut[t]=Math.atan2(ct[t].y-ct[0].y,ct[t].x-ct[0].x);for(let t=1;t<=3;t++)for(let e=t+1;e<=3;e++)if(ut[t]>ut[e]){const r=ct[t];ct[t]=ct[e],ct[e]=r;const i=ut[t];ut[t]=ut[e],ut[e]=i}if(e[0]=ct[0].x,e[1]=ct[0].y,e[2]=ct[1].x,e[3]=ct[1].y,e[4]=ct[2].x,e[5]=ct[2].y,e[6]=ct[3].x,e[7]=ct[3].y,(ct[3].x-ct[2].x)*(ct[1].y-ct[2].y)-(ct[1].x-ct[2].x)*(ct[3].y-ct[2].y)<0)return e[4]=ct[3].x,void(e[5]=ct[3].y)}}}const dt=new s.Matrix,_t=new s.Rectangle,mt=new s.Point;class yt extends pt{constructor(...t){super(...t),yt.prototype.__init.call(this)}__init(){this.distortion=new s.Point}clear(){this.distortion.set(0,0)}apply(t,e){e=e||new s.Point;const r=this.distortion,i=t.x*t.y;return e.x=t.x+r.x*i,e.y=t.y+r.y*i,e}applyInverse(t,e){e=e||new s.Point;const r=t.x,i=t.y,a=this.distortion.x,o=this.distortion.y;if(0===a)e.x=r,e.y=i/(1+o*r);else if(0===o)e.y=i,e.x=r/(1+a*i);else{const t=.5*(i*a-r*o+1)/o,s=t*t+r/o;if(s<=1e-5)return e.set(NaN,NaN),e;e.x=o>0?-t+Math.sqrt(s):-t-Math.sqrt(s),e.y=(r/e.x-1)/a}return e}mapSprite(t,e,r){const i=t.texture;return _t.x=-t.anchor.x*i.orig.width,_t.y=-t.anchor.y*i.orig.height,_t.width=i.orig.width,_t.height=i.orig.height,this.mapQuad(_t,e,r||t.transform)}mapQuad(t,e,r){const i=-t.x/t.width,s=-t.y/t.height,a=(1-t.x)/t.width,o=(1-t.y)/t.height,n=e[0].x*(1-i)+e[1].x*i,h=e[0].y*(1-i)+e[1].y*i,l=e[0].x*(1-a)+e[1].x*a,c=e[0].y*(1-a)+e[1].y*a,u=e[3].x*(1-i)+e[2].x*i,p=e[3].y*(1-i)+e[2].y*i,d=e[3].x*(1-a)+e[2].x*a,_=e[3].y*(1-a)+e[2].y*a,m=n*(1-s)+u*s,y=h*(1-s)+p*s,x=l*(1-s)+d*s,f=c*(1-s)+_*s,v=n*(1-o)+u*o,g=h*(1-o)+p*o,T=l*(1-o)+d*o,w=c*(1-o)+_*o,I=dt;return I.tx=m,I.ty=y,I.a=x-m,I.b=f-y,I.c=v-m,I.d=g-y,mt.set(T,w),I.applyInverse(mt,mt),this.distortion.set(mt.x-1,mt.y-1),r.setFromMatrix(I),this}fillUniforms(t){t.distortion=t.distortion||new Float32Array([0,0,0,0]);const e=Math.abs(this.distortion.x),r=Math.abs(this.distortion.y);t.distortion[0]=1e4*e<=r?0:this.distortion.x,t.distortion[1]=1e4*r<=e?0:this.distortion.y,t.distortion[2]=1/t.distortion[0],t.distortion[3]=1/t.distortion[1]}}const xt=s.Transform.prototype.updateTransform;function ft(t){const e=this.proj,r=t.proj,i=this;return r?r._surface?(e._activeProjection=r,this.updateLocalTransform(),this.localTransform.copyTo(this.worldTransform),void(i._parentID<0&&++i._worldID)):(xt.call(this,t),void(e._activeProjection=r._activeProjection)):(xt.call(this,t),void(e._activeProjection=null))}class vt extends _{constructor(...t){super(...t),vt.prototype.__init.call(this),vt.prototype.__init2.call(this),vt.prototype.__init3.call(this),vt.prototype.__init4.call(this),vt.prototype.__init5.call(this)}__init(){this._surface=null}__init2(){this._activeProjection=null}set enabled(t){t!==this._enabled&&(this._enabled=t,t?(this.legacy.updateTransform=ft,this.legacy._parentID=-1):(this.legacy.updateTransform=s.Transform.prototype.updateTransform,this.legacy._parentID=-1))}get surface(){return this._surface}set surface(t){this._surface!==t&&(this._surface=t||null,this.legacy._parentID=-1)}applyPartial(t,e){return null!==this._activeProjection?(e=this.legacy.worldTransform.apply(t,e),this._activeProjection.surface.apply(e,e)):null!==this._surface?this.surface.apply(t,e):this.legacy.worldTransform.apply(t,e)}apply(t,e){return null!==this._activeProjection?(e=this.legacy.worldTransform.apply(t,e),this._activeProjection.surface.apply(e,e),this._activeProjection.legacy.worldTransform.apply(e,e)):null!==this._surface?(e=this.surface.apply(t,e),this.legacy.worldTransform.apply(e,e)):this.legacy.worldTransform.apply(t,e)}applyInverse(t,e){return null!==this._activeProjection?(e=this._activeProjection.legacy.worldTransform.applyInverse(t,e),this._activeProjection._surface.applyInverse(e,e),this.legacy.worldTransform.applyInverse(e,e)):null!==this._surface?(e=this.legacy.worldTransform.applyInverse(t,e),this._surface.applyInverse(e,e)):this.legacy.worldTransform.applyInverse(t,e)}mapBilinearSprite(t,e){this._surface instanceof yt||(this.surface=new yt),this.surface.mapSprite(t,e,this.legacy)}__init3(){this._currentSurfaceID=-1}__init4(){this._currentLegacyID=-1}__init5(){this._lastUniforms=null}clear(){this.surface&&this.surface.clear()}get uniforms(){return this._currentLegacyID===this.legacy._worldID&&this._currentSurfaceID===this.surface._updateID||(this._lastUniforms=this._lastUniforms||{},this._lastUniforms.translationMatrix=this.legacy.worldTransform,this._surface.fillUniforms(this._lastUniforms)),this._lastUniforms}}class gt extends l.Sprite{constructor(t){super(t),gt.prototype.__init.call(this),this.proj=new vt(this.transform),this.pluginName="batch_bilinear"}__init(){this.aTrans=new s.Matrix}_calculateBounds(){this.calculateTrimmedVertices(),this._bounds.addQuad(this.vertexTrimmedData)}calculateVertices(){const t=this.transform._worldID,r=this._texture._updateID;if(this._transformID===t&&this._textureID===r)return;this._transformID=t,this._textureID=r;const i=this._texture,s=this.vertexData,a=i.trim,o=i.orig,n=this._anchor;let h,l,c,u;if(a?(l=a.x-n._x*o.width,h=l+a.width,u=a.y-n._y*o.height,c=u+a.height):(l=-n._x*o.width,h=l+o.width,u=-n._y*o.height,c=u+o.height),this.proj._surface)s[0]=l,s[1]=u,s[2]=h,s[3]=u,s[4]=h,s[5]=c,s[6]=l,s[7]=c,this.proj._surface.boundsQuad(s,s);else{const t=this.transform.worldTransform,e=t.a,r=t.b,i=t.c,a=t.d,o=t.tx,n=t.ty;s[0]=e*l+i*u+o,s[1]=a*u+r*l+n,s[2]=e*h+i*u+o,s[3]=a*u+r*h+n,s[4]=e*h+i*c+o,s[5]=a*c+r*h+n,s[6]=e*l+i*c+o,s[7]=a*c+r*l+n,this.proj._activeProjection&&this.proj._activeProjection.surface.boundsQuad(s,s)}i.uvMatrix||(i.uvMatrix=new e.TextureMatrix(i)),i.uvMatrix.update();const p=this.aTrans;p.set(o.width,0,0,o.height,l,u),null===this.proj._surface&&p.prepend(this.transform.worldTransform),p.invert(),p.prepend(i.uvMatrix.mapCoord)}calculateTrimmedVertices(){const t=this.transform._worldID,e=this._texture._updateID,r=this;if(r.vertexTrimmedData){if(r._transformTrimmedID===t&&this._textureTrimmedID===e)return}else r.vertexTrimmedData=new Float32Array(8);r._transformTrimmedID=t,this._textureTrimmedID=e;const i=this._texture,s=r.vertexTrimmedData,a=i.orig,o=this._anchor,n=-o._x*a.width,h=n+a.width,l=-o._y*a.height,c=l+a.height;if(this.proj._surface)s[0]=n,s[1]=l,s[2]=h,s[3]=l,s[4]=h,s[5]=c,s[6]=n,s[7]=c,this.proj._surface.boundsQuad(s,s,this.transform.worldTransform);else{const t=this.transform.worldTransform,e=t.a,r=t.b,i=t.c,a=t.d,o=t.tx,u=t.ty;s[0]=e*n+i*l+o,s[1]=a*l+r*n+u,s[2]=e*h+i*l+o,s[3]=a*l+r*h+u,s[4]=e*h+i*c+o,s[5]=a*c+r*h+u,s[6]=e*n+i*c+o,s[7]=a*c+r*n+u,this.proj._activeProjection&&this.proj._activeProjection.surface.boundsQuad(s,s,this.proj._activeProjection.legacy.worldTransform)}}get worldTransform(){return this.proj}}l.Sprite.prototype.convertTo2s=function(){this.proj||(this.pluginName="sprite_bilinear",this.aTrans=new s.Matrix,this.calculateVertices=gt.prototype.calculateVertices,this.calculateTrimmedVertices=gt.prototype.calculateTrimmedVertices,this._calculateBounds=gt.prototype._calculateBounds,a.Container.prototype.convertTo2s.call(this))},a.Container.prototype.convertTo2s=function(){this.proj||(this.proj=new vt(this.transform),Object.defineProperty(this,"worldTransform",{get(){return this.proj},enumerable:!0,configurable:!0}))},a.Container.prototype.convertSubtreeTo2s=function(){this.convertTo2s();for(let t=0;t<this.children.length;t++)this.children[t].convertSubtreeTo2s()};class Tt extends c.Text{constructor(t,e,r){super(t,e,r),Tt.prototype.__init.call(this),this.proj=new vt(this.transform),this.pluginName="batch_bilinear"}__init(){this.aTrans=new s.Matrix}get worldTransform(){return this.proj}}Tt.prototype.calculateVertices=gt.prototype.calculateVertices,Tt.prototype.calculateTrimmedVertices=gt.prototype.calculateTrimmedVertices,Tt.prototype._calculateBounds=gt.prototype._calculateBounds,e.Renderer.registerPlugin("batch_bilinear",lt.create({})),t.AbstractProjection=_,t.Batch2dPluginFactory=d,t.Batch3dGeometry=p,t.BatchBilinearPluginFactory=lt,t.BatchBilineardGeometry=ht,t.BilinearSurface=yt,t.Camera3d=tt,t.Container2d=F,t.Container3d=H,t.Euler=X,t.LinearProjection=y,t.Matrix2d=g,t.Matrix3d=Y,t.Mesh2d=C,t.Mesh3d2d=et,t.ObservableEuler=k,t.ObservablePoint3d=U,t.Point3d=q,t.Projection2d=P,t.Projection3d=W,t.ProjectionSurface=vt,t.SimpleMesh2d=z,t.SimpleMesh3d2d=rt,t.Sprite2d=N,t.Sprite2s=gt,t.Sprite3d=it,t.SpriteMaskFilter2d=B,t.Surface=pt,t.Text2d=E,t.Text2s=Tt,t.Text3d=ot,t.TilingSprite2d=R,t.TilingSprite2dRenderer=I,t.UniformBatchRenderer=x,t.applySpine2dMixin=function(t){t.newMesh=function(t,e,r,i,s){return new z(t,e,r,i,s)},t.newContainer=function(){return this.proj||this.convertTo2d(),new F},t.newSprite=function(t){return new N(t)},t.newGraphics=function(){const t=new u.Graphics;return t.convertTo2d(),t},t.transformHack=function(){return 2}},t.applySpine3dMixin=function(t){t.newMesh=function(t,e,r,i,s){return new rt(t,e,r,i,s)},t.newContainer=function(){return this.proj||this.convertTo3d(),new H},t.newSprite=function(t){return new it(t)},t.newGraphics=function(){const t=new u.Graphics;return t.convertTo3d(),t},t.transformHack=function(){return 2}},t.container2dToLocal=A,t.container2dWorldTransform=S,t.container3dGetDepth=Z,t.container3dIsFrontFace=$,t.container3dToLocal=K,t.container3dWorldTransform=J,t.getIntersectionFactor=f,t.getPositionFromQuad=function(t,e,r){r=r||new s.Point;const i=1-e.x,a=1-i,o=1-e.y,n=1-o;return r.x=(t[0].x*i+t[1].x*a)*o+(t[3].x*i+t[2].x*a)*n,r.y=(t[0].y*i+t[1].y*a)*o+(t[3].y*i+t[2].y*a)*n,r},t.transformHack=m,Object.defineProperty(t,"__esModule",{value:!0})})),"undefined"!=typeof pixi_projection&&Object.assign(this.PIXI.projection,pixi_projection);
//# sourceMappingURL=pixi-projection.umd.min.js.map
